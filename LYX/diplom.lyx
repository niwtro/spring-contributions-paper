#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\usepackage{suetterl}
\usepackage[T1]{fontenc}
\usepackage{oldgerm}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "“Contribution Funktionalität”Techniken zur Servicekonfiguration für modulare Java Software durch erweitertes Spring IOC"
\pdf_author "Ortwin Probst"
\pdf_keywords "IOC, Dependency Injection, Spring, Tapestry, Contribution, Service, Konfiguration"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Titel
\end_layout

\begin_layout Standard
\align center

\series bold
\shape smallcaps
\size huge
Masterarbeit
\end_layout

\begin_layout Standard
\begin_inset VSpace 2.5cm
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\shape smallcaps
\size largest
Contribution Funktionalität
\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size largest
Techniken zur Servicekonfiguration für modulare Java Software durch erweitertes
 Spring IOC
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size large
Masterarbeit zur Erlangung des akademischen Grades Diplomingenieur der Angewandt
en Informatik an der Paris Lodron Universität Salzburg, Naturwissenschaftliche
 Fakultät, Fachbereich Computerwissenschaften
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size large
Eingereicht von
\end_layout

\begin_layout Standard
\align center

\series bold
\shape smallcaps
\size largest
Ortwin Probst
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size large
Betreuer
\end_layout

\begin_layout Standard
\align center

\series bold
\shape smallcaps
\size largest
Ao.Univ.Prof.
 Mag.Dr.
 Helge Hagenauer
\end_layout

\begin_layout Standard
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size largest
Salzburg, Jänner 2014
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size largest
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
Diese Arbeit beschäftigt sich mit 
\shape italic
Dependency Injection
\shape default
 als einer Methode zur Unterstützung von modularer Softwareentwicklung.
 Im Detail werden die Vorteile des erweiterten 
\shape italic
Dependency Injection
\shape default
 Mechanismus aus dem Java-Frameworks 
\shape italic
Tapestry
\shape default
 beleuchtet und als Inspiration für eine praktische Erweiterung des Java-Framewo
rks 
\shape italic
Spring
\shape default
 herangezogen.
 Das praktische Resultat der Arbeit ist die konkrete Umsetzung dieser Erweiterun
g in einem eigenen Spring-Modul.
 Darin werden parallel zwei unterschiedliche Konfigurationsmechanismen mit
 äquivalentem Funktionsumfang angeboten, um die Anforderungen innerhalb
 des Spring-Frameworks zur Gänze erfüllen zu können.
 Beide Konfigurationsmechanismen werden, im Detail auf deren Unterschiede
 in der Implementierung, verglichen und in ihrer Anwendung gegenübergestellt.
\end_layout

\begin_layout Dedication
Widmung
\end_layout

\begin_layout Standard
Ich widme diese Arbeit allen, die es mir ermöglicht haben in meinem Studium
 bis zu diesem Punkt zu kommen.
 Meinen Eltern für die Freiheit, die sie mir geschenkt haben.
 Meinem Betreuer Ao.Univ.Prof.
 Mag.Dr.
 Helge Hagenauer von der Universität Salzburg für seine sehr geschätzte
 Unterstützung und die hilfreiche Kritik.
 Meinem Kollegen und Betreuer Dipl.
 Ing.
 Christian Köberl auf Seiten der Porsche Informatik, für die Hilfe bei der
 Themenfindung, die Fachliche Unterstützung und die Entwicklung der Codebasis.
 Und meinem Studienkollegen Stefan Esterer für die Austauschmöglichkeit
 und die regelmäßige Portion Motivation.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Einführung
\end_layout

\begin_layout Section*
Motivation
\end_layout

\begin_layout Standard
Meine Diplomarbeit fällt thematisch in den Bereich Modulare Softwareentwicklung
 für Java Enterprise Anwendungen.
 Im Detail stehen Konfigurationsmöglichkeiten für über Module verteilte
 Services (distributed configuration) zur Diskussion .
 Dabei beschäftige ich mich im Speziellen mit der sogenannten 
\begin_inset Quotes eld
\end_inset

Contribution
\begin_inset Quotes erd
\end_inset

 Funktionalität 
\begin_inset CommandInset citation
LatexCommand cite
key "tapestry-iocConfig"

\end_inset

.
 Dies ist eine Service Konfigurationsmöglichkeit des IOC-Containers, der
 das Kernstück des 
\shape italic
Apache
\shape default
 Tapestry-Frameworks 
\begin_inset CommandInset citation
LatexCommand cite
key "tapestry-home"

\end_inset

, einem Java Framework für Web-Anwendungen, bildet.
 Ziel ist es, den Contribution-Mechanismus auf das Spring-Framework, einem
 weiteren auf 
\begin_inset Quotes eld
\end_inset

Inversion Of Control
\begin_inset Quotes erd
\end_inset

 (IOC) basierenden Java Framework, zu übertragen.
\end_layout

\begin_layout Standard
Software Module werden im Folgenden nicht als Werkzeug zur Anwendungsmodellierun
g, sondern mehr als konkretes Mittel für die Programmierung mit einer Objektorie
ntierten Programmiersprache betrachtet.
 Im Speziellen kann diese Art der Verwendung von Modulen auch als weiteres
 Mittel zur Kapselung (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Kapselung"

\end_inset

) in der Objektorientierten Entwicklung betrachtet werden.
\end_layout

\begin_layout Section*
Theorieteil
\end_layout

\begin_layout Standard
Der theoretische Teil der Arbeit soll sich, ausgehend von einer Betrachtung
 zu modularem Softwaredesign im Bereich von Java Enterprise Anwendungen,
 genauer mit den zur Verfügung stehenden Techniken für Modulare Entwicklung
 auseinandersetzen.
 Dabei wird einerseits die klassische IOC Technik der 
\shape italic
Dependency Injection
\shape default
, sowie auch die Möglichkeit der Contributions und deren Nutzen erklärt
 und gezeigt.
 Im Detail wird dabei auf die IOC-Konfiguration der beiden Frameworks 
\shape italic
Tapestry
\shape default
 und 
\shape italic
Spring
\shape default
 eingegangen.
\end_layout

\begin_layout Section*
Praxisteil
\begin_inset CommandInset label
LatexCommand label
name "sec:Praxisteil"

\end_inset


\end_layout

\begin_layout Standard
Mein Ausgangspunkt für die praktische Arbeit ist das Interesse der Porsche
 Informatik, eine bestehende, modular entworfene und auf dem Apache Tapestry-Fra
mework basierende Java Webapplikation, auf das in der Firma zum Standard
 erklärte IOC-Framework 
\shape italic
Spring
\shape default
 umzustellen.
 Um einen hohen Grad an Modularität zu erreichen, wurde die Webapplikation
 ursprünglich auf dem Open Source Framework 
\shape italic
Tapestry
\shape default
 aufgebaut.
 Diese Framework bietet einige Techniken die ein modulares Programmieren
 erleichtern.
\end_layout

\begin_layout Standard
Konkret bietet das Framework Methoden, die es ermöglichen, die Konfiguration
 eines Services aus verschiedenen, von einander unabhängigen Modulen heraus
 zu erstellen.
 Dadurch können die gesamte Anwendung und all ihre Services, nur durch das
 Einhängen eines weiteren Moduls in den Classpath, um neue Funktionalität
 erweitert werden.
 Diese Technik wird in 
\shape italic
Tapestry
\shape default
 mit 
\begin_inset Quotes eld
\end_inset

Contribution
\begin_inset Quotes erd
\end_inset

 bezeichnet.
\end_layout

\begin_layout Standard
Als anschauliches Beispiel kann man sich den Menü-Service einer Webanwendung
 vorstellen.
 Das Service dient dazu, automatisch ein Auswahlmenü über alle zur Verfügung
 stehenden Funktionen im Benutzerinterface bereit zu stellen.
 Dieses Service wird in 
\shape italic
Tapestry
\shape default
 aus der zusammengeführten Servicekonfiguration aller Module aufgebaut.
 Das heißt jedes Modul 
\begin_inset Quotes eld
\end_inset

contributet
\begin_inset Quotes erd
\end_inset

 so zu sagen seinen Teil der Menü Service Konfiguration.
 Durch das Ein- oder Aushängen eines Moduls, wird die Anwendung dann automatisch
 um dessen Menüpunkte erweitert oder verringert.
\end_layout

\begin_layout Standard
Das Ziel ist es nun, zuerst die in 
\shape italic
Tapestry
\shape default
 vorhandene Technik des Contribution Mechanismus für das Spring-Framework
 zu adaptieren und danach auf dieser Basis zusätzlich das Tapestry 
\begin_inset Quotes eld
\end_inset

Strategy Builder Service
\begin_inset Quotes erd
\end_inset

 ebenfalls für 
\shape italic
Spring
\shape default
 bereit zu stellen.
 Das Ergebnis dieser Arbeit soll ein eigenes Java Modul mit dem Namen
\noun on
 SpringContributions
\begin_inset Foot
status open

\begin_layout Plain Layout
Das 
\noun on
SpringContributions
\noun default
 Projekt wird auf Googlecode gehostet und ist unter folgender URL zu finden
 (10.12.2013): https://code.google.com/p/spring-contributions/
\end_layout

\end_inset


\noun default
 sein, mit dem die bestehende Webapplikation so umgestellt werden kann,
 dass anstelle des Tapestry Contribution-Systems das neue 
\noun on
SpringContributions
\noun default
 System verwendet wird.
\end_layout

\begin_layout Standard
Da es in 
\shape italic
Spring
\shape default
 zwei unterschiedliche Wege der Konfiguration gibt, ist es auch Ziel des
 Praxisteils, je eine Lösung für diese beiden unterschiedlichen Wege umzusetzen.
 Es wird ein Augenmerk darauf gelegt werden, im Bezug auf den Funktionsumfang
 und die Art der Anwendung, auf Gleichheit bzw.
 Ähnlichkeit der beiden Lösungen zu achten.
 Ebenso soll die Ähnlichkeit zum Vorbildsystem berücksichtigt werden und
 besonders auf Unterschiede, die sich aus der Implementierung oder konzeptionell
en Abweichungen von 
\shape italic
Tapestry
\shape default
 zu 
\shape italic
Spring
\shape default
 ergeben, eingegangen werden.
 Probleme, die sich auf dem Weg zu diesen Zielen ergeben, sollen aufgezeigt
 und erläutert werden.
\end_layout

\begin_layout Chapter
Modulare Programmierung
\end_layout

\begin_layout Standard
In allen hoch automatisierten Industriellen Fertigungsbereichen, ist der
 Ansatz der Modularisierung heute nicht mehr wegzudenken.
 Ein Paradebeispiel hierfür ist die Autoindustrie und ihr erfolgreicher
 Einsatz der Komponentenbauweise.
 Ohne die Komponentenbauweise, wäre die Nachfrage nach Automobilen wahrscheinlic
h schon seit längerem nicht mehr zu decken.
\end_layout

\begin_layout Standard
Seit vielen Jahren wird auch in der Informatik versucht, das Konzept der
 Modularisierung auch in der Software Entwicklung anzuwenden.
 Das Ziel war es auch hier, Softwarekomponenten zu bauen, die sich durch
 ihre Eigenschaften dazu eignen, in unterschiedlichsten Kompositionen als
 neue gesamte Anwendung miteinander zusammen zu arbeiten.
 Mittlerweile sind Softwarekomponenten in der Form von Frameworks sehr verbreite
t und erfreuen sich auch großer Beliebtheit und Verwendung.
\end_layout

\begin_layout Standard
Liest man von Modularer Software Entwicklung, so ist der Blickwinkel meist
 der eines Anwendungsentwicklers.
 Hier hat man eine Sichtweise die, ausgehend von der Applikation als Große
 Einheit, versucht deren modularisierten inneren Aufbau zu betrachten.
 Ich verwende hier mit 
\begin_inset Quotes eld
\end_inset

Modularer Programmierung
\begin_inset Quotes erd
\end_inset

 absichtlich einen leicht anderen Begriff für den inhaltlich gleichen Bereich
 der Informatik, um auf den etwas anderen Fokus dieser Arbeit hinzuweisen.
 In beiden Fällen beschäftigen wir uns mit Software Modulen, wenn ich aber
 Modulare Programmierung sage, dann meine ich nicht den Blickwinkel des
 Anwendungsentwicklers, sondern den des Modulentwicklers.
 Diese Sichtweise beschäftigt sich in ihrer Betrachtung mit der kleinen
 Einheit des Moduls, und deren Zusammenspiel mit anderen Modulen.
 Der Fokus liegt also auf den Modulen und nicht auf der Applikation.
\end_layout

\begin_layout Section
Software Modul bzw.
 Komponente
\end_layout

\begin_layout Standard
Der Vergleich mit Komponenten aus der Autoindustrie lässt vielleicht einen
 intuitiven Begriff davon entstehen, was eine Komponente bzw.
 ein Modul in der Softwareentwicklung sein kann.
 Um bei diesem Kernbegriff und Ausgangspunkt der Arbeit, nicht nur eine
 intuitives Verständnis vorauszusetzen, folgt hier eine Definition des Begriffes.
\end_layout

\begin_layout Paragraph*
Definition (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "Szyperski:1998"

\end_inset

)
\end_layout

\begin_layout Standard
Ein Software Modul ist eine nach außen hin über Schnittstellen definierte
 und gekapselte Einheit, die zur Kombination mit anderen Modulen vorgesehen
 ist.
 Die Kapselung bezieht sich dabei sowohl auf eine Zusammenfassung des Moduls
 in einer binären Einheit, als auch auf einen thematisch abgegrenzten Bereich.
 Die konkrete innere Struktur und Implementierung ist für den Benutzer irrelevan
t.
 Es kommt natürlich vor, dass ein Modul die zur Verfügung gestellte Funktionalit
ät nur in Zusammenarbeit mit anderen Modulen bewerkstelligen kann.
 Diese Abhängigkeiten sind jedoch nicht auf konkrete Implementierungen bezogen,
 sondern werden auch über Schnittstellen abgebildet.
 Das heißt ein Software Modul ist für sich genommen eine unabhängige Einheit.
 Die positiven Eigenschaften, die Softwaremodule (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Positive-Eigenschaften-von-Software-Modulen"

\end_inset

) mit sich bringen, entstehen großteils aus diesem Aspekt der Unabhängigkeit
 von anderen konkreten Implementierungen.
 Da sich Module, wie sie im folgenden Kontext verwendet werden, in ihren
 Eigenschaften, nach Szyperskis Definition, nicht von Komponenten unterscheiden,
 werden im Folgenden beide Begriffe als Synonyme verwendet.
\end_layout

\begin_layout Subsection
Service, Service Provider und Consumer
\end_layout

\begin_layout Subsubsection*
Definition
\end_layout

\begin_layout Standard
In dieser Arbeit wird der Begriff 
\begin_inset Quotes eld
\end_inset

Service
\begin_inset Quotes erd
\end_inset

 bzw.
 
\begin_inset Quotes eld
\end_inset

Dienst
\begin_inset Quotes erd
\end_inset

 als Zusammenfassung für, über Schnittstellen definierte und zur Verfügung
 gestellte Funktionalität verwendet.
 In der Informatik wird der Begriff häufig auch im Zusammenhang mit Verteilten
 Systemen gebraucht und assoziiert eventuell einen verteilten Kontext.
 Deshalb möchte ich hier explizit darauf hinweisen, dass im Bereich dieser
 Arbeit ein Service keine Eigenschaften für eine verteilte Anwendung mit
 sich bringt.
\end_layout

\begin_layout Standard
Da der Kontext in dem wir uns hier befinden die objektorientierte Programmierung
 ist, verbirgt sich hinter einem Service im Grunde immer ein mehr oder weniger
 komplexes Objekt.
 Die Unterscheidung von einem Service zu einem normalen Objekt ist allerdings,
 dass die Funktionalität eines Service Objekts immer über ein Interface
 definiert sein muss.
\end_layout

\begin_layout Standard
Soll ein Service nicht nur innerhalb eines Moduls, sondern auch über Modulgrenze
n hinweg, zur Verfügung gestellt werden, so muss natürlich die Interface
 Definition für andere Module sichtbar sein.
 Zur Darstellung der Verwendungsbeziehung eines Service, werden im Folgenden
 die Begriffe Service Provider (Service) und Service Consumer (Konsument)
 verwendet.
\end_layout

\begin_layout Subsection
Positive Eigenschaften von Software Modulen
\begin_inset CommandInset label
LatexCommand label
name "sub:Positive-Eigenschaften-von-Software-Modulen"

\end_inset


\end_layout

\begin_layout Standard
Ein Softwaresystem in einem Modularen Design zu entwerfen, ist ein gutes
 Mittel um Wiederverwendbarkeit (reusability), Austauschbarkeit und Erweiterbark
eit (plugability), erleichterte Wartung (maintainability) und Testbarkeit
 (testability) zu ermöglichen.
\end_layout

\begin_layout Standard
Aus den folgenden Vorteilen, die durch modulare Programmierung entstehen
 können, werden die Punkte 1-3 auch von David Parnas 
\begin_inset CommandInset citation
LatexCommand cite
key "Parnas:1972"

\end_inset

 hervorgehoben.
\end_layout

\begin_layout Enumerate
Verringerung der Entwicklungszeit, da Entwicklergruppen ohne viel Kommunikation
 getrennt an Modulen arbeiten können.
 
\end_layout

\begin_layout Enumerate
Steigerung der Flexibilität, durch die Möglichkeit, Änderungen in einem
 Modul vor zu nehmen, ohne dabei andere Module anpassen zu müssen.
 
\end_layout

\begin_layout Enumerate
Erleichterung der Verständlichkeit des Gesamtsystems, und somit auch die
 Unterstützung eines besseren Designs.
\end_layout

\begin_layout Enumerate
Erleichterung im Testen durch die Trennung von Interface, Implementierung
 und Konfiguration.
\end_layout

\begin_layout Subsection
Modulentwicklung vs.
 Zusammenstellung modularer Anwendungen
\end_layout

\begin_layout Standard
Betrachtet man die modulare Softwareentwicklung, so muss man dabei zwei
 Bereiche klar voneinander abgrenzen.
 Zum einen die Entwicklung eines Softwaremoduls und zu anderen der Aufbau
 einer Modularen Anwendung.
\end_layout

\begin_layout Standard
Die Entwicklung eines Moduls ist die Aufgabe eines Modulentwicklers.
 Dieser ist zuständig für die interne Implementierung und die Definition
 der Modulschnittstellen.
\end_layout

\begin_layout Standard
Der Aufbau einer modularen Anwendung hingegen wird durch einen Anwendungsentwick
ler durchgeführt und beschäftigt sich nicht mehr mit der Implementierung,
 sondern mit der Auswahl, der Kombination und der Konfiguration mehrerer
 Komponenten zu einer bestimmten Anwendung.
\end_layout

\begin_layout Section
Grundvoraussetzungen für Modularisierung
\end_layout

\begin_layout Standard
Auf Implementierungsebene gibt es mehrere Voraussetzungen, die zur Entwicklung
 von Komponenten notwendig sind.
 Dabei handelt es sich um die 
\begin_inset Quotes eld
\end_inset

Lose Kopplung
\begin_inset Quotes erd
\end_inset

, die 
\begin_inset Quotes eld
\end_inset

Kapselung
\begin_inset Quotes erd
\end_inset

, um 
\begin_inset Quotes eld
\end_inset

Schnittstellen
\begin_inset Quotes erd
\end_inset

 und das 
\begin_inset Quotes eld
\end_inset

Bereitstellen von Konfiguration
\begin_inset Quotes erd
\end_inset

.
 Diese vier Teilaspekte werden benötigt, will man eine Modularisierung von
 Software erreichen.
\end_layout

\begin_layout Subsubsection*
Lose Kopplung
\end_layout

\begin_layout Standard
In der klassischen Objektorientierung entstehen schon zum Zeitpunkt der
 Programmierung Abhängigkeiten zwischen Objekten.
 Benötigt zum Beispiel der Konstruktor bzw.
 die Initialisierungsmethode einer Klasse eine konkrete andere Klasse, so
 entsteht hier eine feste Kopplung 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset

 hin auf eine ganz bestimmte Implementierung.
 Für die Entwicklung von Services einer Komponente muss es aber möglich
 sein, Klassen zu schreiben, deren Laufzeitverhalten nicht schon zum Implementie
rungszeitpunkt durch ihre Abhängigkeiten festgelegt ist 
\begin_inset CommandInset citation
LatexCommand cite
key "Fabresse:2012"

\end_inset

.
 Es ist also nötig, die Implementierung auf Schnittstellendefinitionen aufzubaue
n, um die Funktionalität zwar zu definieren, aber von einer konkreten Implementi
erung unabhängig zu halten.
 So kann die Voraussetzung geschaffen werden, damit Komponenten erst zum
 Zeitpunkt der Softwareverteilung (deployment), also zum Installationszeitpunkt
 der Anwendung, oder sogar erst zum Ausführungszeitpunkt, eine konkrete
 Verbindung untereinander aufbauen.
 So ist es auch für eine Anwendungsentwickler, der keinen Einfluss auf die
 Implementierung einzelner Komponenten hat, möglich mehrere Softwarekomponente
 zu einer Anwendung zu kombinieren.
 Wie die lose Kopplung auch zu einer Erleichterung beim Testen von Komponenten
 führt wird in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Testability-durch-IOC"

\end_inset

 beschrieben.
\end_layout

\begin_layout Subsubsection*
Kapselung
\begin_inset CommandInset label
LatexCommand label
name "sub:Kapselung"

\end_inset


\end_layout

\begin_layout Standard
Um eine Lose Kopplung zu ermöglichen, benötigt man Mittel zur Kapselung
 von Programmeinheiten.
 In der objektorientierten Programmierung ist der Begriff Kapselung für
 das Zusammenfassen von Funktionalität, in von außen nur über Schnittstellen
 definierte und angreifbare Einheiten, definiert 
\begin_inset CommandInset citation
LatexCommand cite
key "Snyder:1986:EncapsulationAndInheritance"

\end_inset

.
 Wenn ich hier im Zusammenhang mit der modularen Programmierung von Kapselung
 spreche, so meine ich die gleiche Definition.
 Im modularen Kontext verschiebt sich nur die Betrachtungsebene der Kapselung
 von der Objektebene auf die des Moduls.
 Module kapseln also ihre Funktionalität in sich und bilden somit eine zusammeng
ehörige, nur durch Interfaces nach außen definierte und angreifbare Einheit.
\end_layout

\begin_layout Subsubsection*
Schnittstellen
\end_layout

\begin_layout Standard
Betrachtet man die Lose Kopplung und die Kapselung als Grundvoraussetzung
 für Modularität, so folgt daraus die Möglichkeit von Schnittstellendefinitionen
 als weitere Grundvoraussetzung.
 Die Möglichkeit von Schnittstellen bzw.
 Interfaces ist auf Klassenebene prinzipiell in allen Objektorientierten
 Sprachen gegeben.
 Mit diesen ersten drei Grundvoraussetzungen ist es in der objektorientierten
 Programmierwelt möglich, Softwaremodule zu entwickeln.
\end_layout

\begin_layout Subsubsection*
Bereitstellung und Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Bereitstellung-und-Konfiguration"

\end_inset


\end_layout

\begin_layout Standard
Sind die nötigen Schnittstellen einmal definiert und sind die dazugehörigen
 Modulimplementierungen vorhanden, so ist das nächste zu lösende Problem
 die Bereitstellung der Services für andere Module.
 Es muss also ein Weg gefunden werden, eine bestimmte Interface Implementierung
 überall dort zur Laufzeit zur Verfügung zu stellen, wo das Interface verwendet
 wird.
\end_layout

\begin_layout Standard
Dieses Problem kann durch Konfigurationsmechanismen gelöst werden.
 Man benötigt also eine von den Modulimplementierungen losgelöste Konfiguration,
 in der im einfachsten, aber nicht unbedingt elegantesten Fall, direkt alle
 Service Instanzen modulübergreifend, für die gesamte Anwendung, angelegt
 und initialisiert werden.
 Diese Konfiguration bildet dann zusammen mit allen zugehörigen Modulen
 eine Anwendung.
\end_layout

\begin_layout Standard
Es gibt verschiedenste Ansätze zur Realisierung dieser eigenständigen Konfigurat
ion.
 Einige davon werden im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Konfiguration"

\end_inset

 noch genauer beleuchtet werden.
 Alle Ansätze haben dabei aber die Gemeinsamkeit, dass sie sich auf einen
 zentralen Dienst stützen.
 Dieser Dienst bietet zum einen eine Möglichkeit zur Serviceregistrierung,
 mittels der jedes Modul die Zuordnung von Service Interface zur moduleigenen
 Implementierung, selbst als Konfiguration durchführen kann.
 Zum anderen stellt er eine Möglichkeit dar, die registrierten Services
 abzurufen und somit zu verwenden.
 Dienste die diesen Zweck erfüllen werden oft mit dem Begriff 
\begin_inset Quotes eld
\end_inset


\shape italic
Service Registry
\shape default

\begin_inset Quotes erd
\end_inset

 bezeichnet.
\end_layout

\begin_layout Standard
Je nach Flexibilitätsgrad ergeben sich unterschiedliche Zeitpunkte, zu denen
 die Anwendungskonfiguration zur Verwendung kommt.
 Beginnend bei der einfachsten Lösung, über direkte programmatische Instanziieru
ng und Initialisierung, die also schon zur Kompilierzeit die Anwendungszusammens
tellung genau festlegt.
 Die konkrete Servicelandschaft der Anwendung erst bei der Anwendungsinstallatio
n festzulegen, kann zum Beispiel über interne, also sich innerhalb des physische
n Anwendungspakets befindlichen, Konfigurationsfiles oder Klassen, im Zusammensp
iel mit Dynamischen Assemblerdiensten (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Dependency-Injection"

\end_inset

) gelöst werden.
 Liegen die Konfigurationsfiles oder der Konfigurationscode außerhalb des
 physischen Anwendungspakets, so verschiebt sich der Zeitpunkt der Auflösung
 auf den Systemstart.
\end_layout

\begin_layout Standard
Es gibt sogar Ansätze zur Konfiguration von modularen Anwendungen, die eine
 Einflussnahme auf Modulabhängigkeiten und Service Konfigurationen noch
 zur Laufzeit ermöglichen.
 Ein Komponentensoftwaresystem zur Laufzeit anzupassen, d.h.
 neue Komponenten einzufügen, andere zu entfernen und gewisse Verbindungen
 umzustellen, ist eine Eigenschaft die wegen des Aufwands nicht alle komponenten
orientierten Entwicklungsansätze verfolgen.
 Als Beispiel für die Anpassbarkeit zu Laufzeit kann hier 
\shape italic
OSGI
\shape default
, als Spezifikation einer Modul und Serviceplattform für Java, erwähnt werden.
 
\shape italic
OSGI
\shape default
 ist unter anderem im später noch genauer beschriebenen Spring-Framework
 (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-Konfiguration"

\end_inset

) umgesetzte.
 Die Möglichkeit der Anwendungskonfiguration zur Laufzeit, soll hier aber
 nur der Vollständigkeit wegen erwähnt sein und wird im Weiteren nicht mehr
 genauer behandelt.
\end_layout

\begin_layout Section
Modularisierung mit 
\begin_inset Quotes eld
\end_inset


\shape italic
Inversion of Control
\shape default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Moderne Java Frameworks zur Unterstützung von modularer Softwareentwicklung
 bieten oftmals IOC-Container an.
 Diese Container sind spezielle Formen von Serviceregistries (siehe Abschnitt
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Bereitstellung-und-Konfiguration"

\end_inset

) mit deren Hilfe eine Entkopplung von Consumer und Provider realisiert
 werden kann.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset


\shape italic
Inversion of Control
\shape default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
„Inversion of Control“ kurz IOC bezeichnet ganz allgemein die Umkehrung
 eines Kontrollflusses.
 Kontrollflussumkehrung ist aber ein sehr allgemeines Prinzip und wird somit
 auch in verschiedensten Ausprägungen in der Softwareentwicklung verwendet.
 Die für den aktuellen Kontext wichtige Ausprägungsform von IOC als 
\begin_inset Quotes eld
\end_inset


\shape italic
Dependency Injection
\shape default

\begin_inset Quotes erd
\end_inset

 wird im nächsten Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Dependency-Injection"

\end_inset

 genauer beschrieben.
 IOC und das 
\shape italic
Dependency Injection Pattern
\shape default
 sind Methoden deren Anwendung meist direkt auf Objektebene verwendet wird.
 Beide Prinzipien können aber ohne weiteres auch auf der Komponentenebene
 ihre Anwendung finden.
\end_layout

\begin_layout Paragraph*
Geschichte:
\end_layout

\begin_layout Standard
Martin Fowler 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler:2005"

\end_inset

 liefert eine eine Erklärung und Informationen zur Herkunft des Begriffs
 
\begin_inset Quotes eld
\end_inset


\shape italic
Inversion of Control
\shape default

\begin_inset Quotes erd
\end_inset

 in der Informatik.
 So findet sich bei Ralph E.
 Johnson 
\begin_inset CommandInset citation
LatexCommand cite
key "Johnson:1988"

\end_inset

 eine frühe Verwendung des Begriffes, wenn die Autoren selbst, wieder auf
 einen anderen, nicht bekannten Schöpfer des Begriffes verweisen.
 Mit dem 
\begin_inset Quotes eld
\end_inset


\shape italic
Hollywood Principle
\shape default

\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Sweet:1985"

\end_inset

 existierte schon seit 1985 ein weiterer Begriff für dasselbe Prinzip auf
 den auch Erich Gamma et.al.
 in ihrem bekannten Buch zu 
\begin_inset Quotes eld
\end_inset


\shape italic
Design Patterns
\shape default

\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset

 Bezug nehmen 
\begin_inset Quotes eld
\end_inset

Don'tcall us, we'll call you
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Das 
\shape italic
Pico Container
\shape default
 Framework (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:IOC-Frameworks-für-modulares_Entwickeln"

\end_inset

) liefert auf seiner Homepage 
\begin_inset CommandInset citation
LatexCommand cite
key "Pico:IOC-History"

\end_inset

 weitere Erläuterungen zur Geschichte des IOC Begriffs.
 Als Wegbereiter des heutigen IOC Begriffs werden hier Robert C.
 Martin, der unter der Bezeichnung 
\begin_inset Quotes eld
\end_inset


\shape italic
Dependency Inversion
\shape default

\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Martin:1996"

\end_inset

 über die Umkehrung von Abhängigkeiten zur Erreichung von unabhängigen Modulen
 schreibt, Michael Mattesson 
\begin_inset CommandInset citation
LatexCommand cite
key "Mattsson96object-orientedframeworks"

\end_inset

, Brian Foote und Joseph Yoder 
\begin_inset CommandInset citation
LatexCommand cite
key "Foote:1998-BallOfMud"

\end_inset

, sowie Ralph E.
 Johnson und Brian Foote 
\begin_inset CommandInset citation
LatexCommand cite
key "Johnson:1998-DesigningReusableClasses"

\end_inset

 erwähnt.
 Weiters finden hier die ersten Umsetzungen des IOC Prinzips mit den Projekten
 
\shape italic
Apache Avalon
\shape default
 und 
\shape italic
OSGi
\shape default
 ihre Erwähnung.
 Folgende Grafik soll die Historie von Fowler und die Timeline von 
\shape italic
Pico Container
\shape default
 zusammenführen und ergänzen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Meilensteine des IOC-Pattern 
\begin_inset CommandInset label
LatexCommand label
name "fig:Meilensteine-des-IOC"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace defskip
\end_inset


\begin_inset Graphics
	filename pics/IOC Timeline.eps
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Bedeutung:
\end_layout

\begin_layout Standard
Die allgemeine Bedeutung von IOC als Kontrollfluss Umkehr beschreibt Fowler
 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler:2004"

\end_inset

 am Beispiel vom Wechsel von einer Kommandozeilen gesteuerten Anwendung,
 die den Benutzer Schritt für Schritt nach Eingaben fragt, hin zu einer
 Steuerung über eine Benutzeroberfläche, bei der die Benutzeroberfläche
 Benutzereingaben entgegen nimmt und diese an die Anwendung weiterleitet.
 Hier wurde also der ursprüngliche Kontrollfluss umgekehrt.
\end_layout

\begin_layout Standard
Der IOC Begriff wird aber nicht immer so allgemein betrachtet.
 Das Pico Container Framework zum Beispiel verwendet den Begriff als Zusammenfas
sung ganz konkreter Techniken.
\end_layout

\begin_layout Standard
Das allgemeine IOC Prinzip kann als eine Haupteigenschaft von Frameworks
 betrachtet werden.
 Frameworks haben im Gegensatz zu einfachen Programmbibliotheken die Kontrolle
 über ihre Funktionalität großteils selbst inne.
 Eine Programmbibliothek stellt lediglich Funktionalität für einen Konsumenten
 zur Verfügung, die Kontrolle über die Funktion geht hier aber vom Konsumenten
 aus.
 Ein Framework stellt zwar auch Funktionalität zur Verfügung, im Gegensatz
 zur Programmbibliothek wird hier aber mit verschiedenen Methoden (Subclassing,
 Plugins) das eigene Programmverhalten in das Framework eingebunden.
 Das Verhalten des Frameworks wird so zu sagen für die eigenen Anwendungsbedürfn
isse konfiguriert.
\end_layout

\begin_layout Standard
Dieses Prinzip der externen Konfiguration des Programmverhaltens und der
 gleichzeitigen Beibehaltung der eigenen Kontrolle des Frameworks über die
 Funktionen an sich, kann nicht nur auf Frameworks, sondern auch auf Module
 angewandt werden.
 Ein Modul, wie zum Beispiel ein Verrechnungsmodul, kapselt einen bestimmten
 Fachlichen Aspekt und die dazu bereitgestellte Funktionalität (Rechnungserstell
ung, Stornierung, etc.).
 Das konkrete Verhalten im jeweiligen Anwendungskontext des Moduls, muss
 jedoch von eben diesem Anwendungskontext als Konfiguration bereitgestellt
 werden.
 Das heißt die Services eines Moduls werden von außen konfiguriert, behalten
 selbst aber die Kontrolle über ihre primäre Funktionalität.
 Um derartige Services realisieren und in einem Modul kapseln zu können,
 muss es möglich sein die Funktionalität eines Services von dessen konkreten
 Konfiguration zu entkoppeln.
 Dieses Entkoppeln, als die Möglichkeit zum Auflösen von konkreten Abhängigkeite
n, ist also eine Hauptvoraussetzung für Modulares Programmieren.
\end_layout

\begin_layout Standard
In der Objektorientierten Programmierwelt ist IOC eine der wichtigsten Techniken
, um eben diese Entkopplung zu erreichen.
 Auch wenn hier im Allgemeinen oft von IOC gesprochen wird, so ist im Konkreten
 oft 
\shape italic
Dependency Injection
\shape default
, eine ganz spezielle Form von IOC gemeint.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Dependency Injection
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:Dependency-Injection"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset


\shape italic
Dependency Injection
\shape default

\begin_inset Quotes erd
\end_inset

 (DI) ist ein von Martin Fowler 
\begin_inset CommandInset citation
LatexCommand citet
key "Fowler:2004"

\end_inset

 genauer beschriebenes Pattern für die objektorientierte Programmierung.
 Mit Hilfe des Patterns wird es möglich, einen sogenannten Plugin Mechanismus
 zu realisieren.
 Das heißt ein Consumer muss nur den Interface Typ des benötigten Services
 kennen, die konkrete Service Implementierung wird durch einen Assembler
 von außen als Plugin in den Consumer injiziert oder eingehängt (siehe Abbildung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Dependency Injection"

\end_inset

).
 In Java gibt es für den Vorgang der Injection mehrere unterschiedliche
 Ansätze, die je nach Anwendungsfall vor und Nachteile haben können.
 In der folgenden Auflistung können die ersten drei als die klassischen
 Wege für 
\shape italic
Dependency Injection
\shape default
 betrachtet werden.
 Die Annotation Injection ist eine eher neuere Ausprägung des 
\shape italic
Injection Pattern
\shape default
.
\end_layout

\begin_layout Paragraph
Konstruktor-Injection
\end_layout

\begin_layout Standard
Bei dieser Form von Injektion werden alle nötigen Plugins über den Konstruktor
 des Consumer injiziert.
 Alle Plugins werden hier also schon bei der Erstellung des Consumer benötigt.
 Daraus ergeben sich in der Praxis oftmals Probleme (z.B.
 Abhängigkeits-Zyklus), für deren Lösung moderne IOC-Frameworks verschiedene
 Wege (z.B.
 Lazy Loading, Proxying) anbieten.
 Für den Assembler ist es hier wichtig einen bestimmten Konstruktor für
 den Injizierungsvorgang zur Verfügung zu haben.
 Die Auswahl des Konstruktors ist hier ein wichtiges zu lösendes Problem
 und kann auf unterschiedliche Arten erfolgen (siehe Absatz 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Annotation-Injection"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Dependency Injection Pattern
\shape default

\begin_inset CommandInset label
LatexCommand label
name "fig:Dependency Injection"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/Dependency Injection-base.eps
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Setter-Injection
\end_layout

\begin_layout Standard
Wie auch hier schon der Name sagt, werden bei dieser Art der DI, Plugins
 über, vom Consumer selbst zur Verfügung gestellte Setter, in den Consumer
 eingehängt.
 Man benötigt hier für jedes Plugin einen eigenen Setter.
 Ein besonderer Vorzug der Setter Injection gegenüber der Konstruktor Injection
 ist hier, dass der Assembler den Zeitpunkt der Injection beliebig nach
 der Objekterstellung wählen kann.
\end_layout

\begin_layout Paragraph
Interface-Injection
\end_layout

\begin_layout Standard
Anstelle von einem Setter pro Plugin, gibt es bei der Interface-Injection
 für jede Instanzvariable eine über ein Injection Interface definierte Inject
 Methode zum setzen des jeweiligen Plugins.
 Das Injection Interface wird immer zusammen mit dem Plugininterface angeboten.
 Jeder Consumer, der Plugins vom Typ des Plugininterfaces verwenden möchte,
 muss gleichzeitig auch das Injection Interface für diesen Plugintyp implementie
ren, wenn er Plugins injiziert bekommen möchte.
 Somit stehen dem Assembler die Inject Methode für das Plugin zur Verfügung.
\end_layout

\begin_layout Paragraph
Annotation-Injection
\begin_inset CommandInset label
LatexCommand label
name "par:Annotation-Injection"

\end_inset


\end_layout

\begin_layout Standard
Nachdem im Java Release 5.0 Annotationen eingeführt worden waren, wurde dieses
 neue Feature sogleich von verschiedensten IOC-Frameworks verwendet, um
 eine für den Entwickler sehr komfortable, neue Art der DI zu realisieren.
 Dabei dienen nun Annotationen wie 
\family sans
@Autowired
\family default
 (
\shape italic
Spring
\shape default
 IOC) bzw.
 
\family sans
@Inject
\family default
 (
\shape italic
JSR 330
\shape default
) als Marker für das IOC-Framework, mit denen der Entwickler Instanzvariablen
 für eine durchzuführende Injection kennzeichnen kann.
 Wichtig ist hier aber, dass die Instanzvariable eben nicht über einen explizite
n Setter oder einen Konstruktor injiziert wird.
 Der Assembler injiziert die Instanzvariable direkt über Java Reflection
 in das Objekt.
\begin_inset Newline newline
\end_inset

Natürlich kann und wird die Markierfunktion von Annotationen auch in Zusammenhan
g mit allen anderen DI Arten benutzt.
 In diesen Fällen werden die Annotationen aber lediglich dazu verwendet,
 um Mehrdeutigkeiten für eine Injection Methode aufzulösen.
 Für den Fall, dass mehrere Klassen vom selben Typ existieren der injiziert
 werden soll, bieten viele IOC-Frameworks die Möglichkeit an, die Klasse
 über Injektion-Annotationen und deren Parameter genauer zu spezifizieren,
 so dass die zu injizierende Klasse wieder eindeutig festzustellen ist.
 Eine weitere Markierfunktion wird oft angeboten, um einen bestimmten Konstrukto
r für die Konstruktor Injection zu kennzeichnen oder, um bestimmte Methoden
 als Setter für die Setter-Injektion zu markieren.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Service Locator
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:Service-Locator"

\end_inset


\end_layout

\begin_layout Standard
Eine Alternative zur Entkopplung von Klassen mittels 
\shape italic
Dependency Injection
\shape default
 ist die Verwendung des 
\begin_inset Quotes eld
\end_inset


\shape italic
Service Locator Pattern
\shape default

\begin_inset Quotes erd
\end_inset

.
 Diese Methode stützt sich auf die zentrale Klasse des Service Locator,
 der Methoden anbietet, über die man Objekte von einem gewünschten Typ erhält.
 Anstatt einer Klasse bei ihrer Erstellung nun all ihre Abhängigkeiten mit
 zu geben, gibt man diese Klasse initial nur den Service Locator mit.
 Die Kontrolle über das Instanziieren von Instanzvariablen obliegt bei diesem
 Pattern nun wieder dem Objekt selbst.
 Benötigt das Objekt nun ein anderes Objekt, so kann es dieses über den
 Service Locator bekommen.
 Hier kommt es also nicht zu einer Kontrollfluss Umkehrung wie bei der zuvor
 beschriebenen DI.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Service Locator Pattern
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/Service Locator.eps
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Plugin Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:seperating configuration from use"

\end_inset


\end_layout

\begin_layout Standard
Egal welche Art der DI verwendet wurde um einen Consumer für Plugins vorzubereit
en, man benötigt zudem eine Plugin Konfiguration, wenn man den Code in einem
 Programm zur Laufzeit nutzen möchte.
 Unabhängig vom Typ der DI ist also diese Konfiguration essentiell, denn
 darin wird festgelegt, welche Plugins überhaupt zum konsumieren zur Verfügung
 stehen und welches Plugin von welchem Consumer verwendet werden soll.
 Natürlich können nur genau die Plugins von einem Consumer verwendet werden,
 für deren Verwendung er auch über die Angabe des Interfaces vorbereitet
 ist.
 Solange es nur ein konfiguriertes Plugin zu einem Interface gibt, solange
 könnte auch die Injection, also die Referenzierung von Consumer zu Plugin,
 durch den Assembler ganz automatisch durchgeführt werden.
 Da es aber vorkommen kann, dass man mehrere Plugins des selben Interfacetyps
 in einer Konfiguration angelegt hat, ist es dann auch notwendig, die Beziehung
 zwischen den Service Consumern und den Plugins explizit in der Konfiguration
 abzulegen.
 Die Verwendung einzelne Plugins von mehreren Consumern kann natürlich ebenfalls
 gewünscht sein und wird, soweit dies unterstützt ist, ebenfalls in der
 Konfiguration festgelegt.
 Bei der Konfiguration müssen natürlich so manche Probleme berücksichtigt
 werden.
 Verwendet man zum Beispiel innerhalb eines Plugins ebenfalls DI für die
 Verwaltung der Abhängigkeiten, so ist es natürlich möglich Abhängigkeits-Zyklen
 zu produzieren, indem die Konfiguration so aufgebaut wird, dass innerhalb
 der Referenzen eine Abhängigkeit von einem Plugin zu seinem eigenen Consumer
 entsteht und somit bei der Auflösung der Abhängigkeiten ein Deadlock entstehen
 würde.
 Je nach der 
\begin_inset Quotes eld
\end_inset

Intelligenz
\begin_inset Quotes erd
\end_inset

 des Assemblers, gibt es für derartige Konfigurationsproblematiken auch
 
\begin_inset Quotes eld
\end_inset

intelligente
\begin_inset Quotes erd
\end_inset

, automatische Problemauflösungs- bzw.
 Vermeidungsstrategien.
 Unabhängig von solchen automatischen Hilfestellungen, ist es die Konfiguration
 selbst, in der derartige Probleme entstehen aber eben auch vermieden werden
 können.
\end_layout

\begin_layout Subsection
Testability durch IOC
\begin_inset CommandInset label
LatexCommand label
name "sub:Testability-durch-IOC"

\end_inset


\end_layout

\begin_layout Standard
Die Verwendung von IOC zur Regelung der Abhängigkeiten von Objekten, hat
 einen ungemein positiven Effekt auf die Testbarkeit der Objektlogik.
 Es spielt dabei keine Rolle, auf welche genaue Weise die DI umgesetzt wird,
 wichtig ist einzig die Verwendung des IOC-Pattern.
 Werden zum Beispiel die Abhängigkeiten in einem Service durch diesen selbst
 geregelt, so hält das Service so zu sagen die eigene, Konfiguration unveränderb
ar in sich verborgen.
 Möchte man das Service nun in einem Unit-Test auf seine korrekte Funktionsweise
 testen, so ist man gezwungen, nicht nur die Einheit (Unit), also das Service
 selbst, sondern auch alle Abhängigkeiten des Service und deren Verhalten
 mit zu berücksichtigen.
 Über das Verhalten dieser Abhängigkeiten hat man im Test aber keinerlei
 Kontrolle.
\end_layout

\begin_layout Standard
Wenn das Service so geschrieben ist, dass es seine Konfiguration durch IOC
 von außen übergeben bekommt, so kann man dies in einem Unit-Test für eine
 spezielle Testkonfiguration nutzen.
 Es wird also möglich, zu jeder Abhängigkeit des Service sogenannte Mock-Objekte
 zu schreiben und diese dann für den Test zu übergeben (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler:2004"

\end_inset

).
 Diese Mock-Objekte sind spezielle Implementierungen mit denen man die vom
 Service benötigten Abhängigkeiten ersetzen kann und, wie Dave Thomas und
 Andy Hunte zusammenfassen 
\begin_inset CommandInset citation
LatexCommand cite
key "Thomas:2002"

\end_inset

, über deren Verhalten man nun die volle Kontrolle hat.
 Es ist dann also zum Beispiel möglich, in einem Mock-Objekt genau festzulegen,
 welchen Rückgabewert dieses liefern wird, wenn das getestete Service eine
 Methode auf dem Mock aufruft.
 Dadurch ist nun also das Service als unabhängige Einheit testbar.
\end_layout

\begin_layout Section
IOC-Frameworks für modulares Entwickeln
\begin_inset CommandInset label
LatexCommand label
name "sec:IOC-Frameworks-für-modulares_Entwickeln"

\end_inset


\end_layout

\begin_layout Standard
Die in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Dependency-Injection"

\end_inset

 beschriebenen Varianten des 
\begin_inset Quotes eld
\end_inset


\shape italic
Inversion of Control Pattern
\shape default

\begin_inset Quotes erd
\end_inset

 sind heute Kernstücke unterschiedlicher IOC-Frameworks (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:IOC-Frameworks"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IOC-Frameworks
\begin_inset CommandInset label
LatexCommand label
name "tab:IOC-Frameworks"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
Framework
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
IOC-Varianten
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
Konfiguration
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Spring
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Konstruktor,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Setter,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Annotation,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Service Locator
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
statisch (XML, Annotationen)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
programmatisch
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Tapestry (Apache)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Konstruktor,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Setter,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Annotation,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Service Locator
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
statisch (Annotationen)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
programmatisch
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Guice (Google)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Konstruktor,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Setter,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Annotation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Annotationen
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Java-CDI (Oracle)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Konstruktor in Kombination 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
mit Annotation,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Annotation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
statisch (Annotationen, XML)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Silk DI
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Konstruktor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
programmatisch
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Pico-Container
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Konstruktor,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Setter,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Annotation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
statisch (Annotationen)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
programmatisch
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Durch die Eigenschaft der Entkopplungsmöglichkeit die diese Frameworks bieten,
 können sie sehr hilfreich als Basis für eine modulare Softwareentwicklung
 eingesetzt werden.
 In der Praxis setzt mittlerweile ein Großteil der namhaften Softwareentwickler
 IOC-Frameworks zur leichteren Modularisierung ihrer Software ein.
 Mit dem selbst entwickelten IOC-Framework 
\shape italic
Google Guice
\shape default
 setzt z.B.
 auch der Suchmaschinen Anbieter ganz stark auf IOC.
 Neben 
\shape italic
Guice
\shape default
 gibt es weiter IOC-Frameworks wie 
\shape italic
Pico Container
\shape default
, 
\shape italic
Silk DI
\shape default
, 
\shape italic
Apache Tapestry
\shape default
 oder 
\shape italic
Oracle CDI
\shape default
.
 Manche dieser IOC-Frameworks sind sehr spezialisiert.
 So ist z.B.
 das Tapestry-Framework rein auf die Entwicklung von Webanwendungen ausgerichtet.
\end_layout

\begin_layout Standard
Der wahrscheinlich bekannteste Vertreter aus der Gruppe der IOC-Frameworks
 ist unter dem Namen 
\begin_inset Quotes eld
\end_inset


\shape italic
Spring
\shape default

\begin_inset Quotes erd
\end_inset

 bekannt.
 Mit 
\shape italic
Spring
\shape default
 ist die Zusammenfassung einer Vielzahl von Modulen gemeint, deren Einsatzbereic
h sehr breit gestreut ist.
 Einen Überblick über die Modularität und die Vielfalt der Module kann unter
 
\begin_inset CommandInset citation
LatexCommand cite
key "SpringIntro"

\end_inset

 gefunden werden.
 Bei aller Vielfalt der durch 
\shape italic
Spring
\shape default
 zur Verfügung gestellten Funktionalität, bleibt aber der IOC-Container
 mit seiner 
\shape italic
Dependency Injection
\shape default
 Funktionalität das Herzstück von 
\shape italic
Spring
\shape default
.
 Dieses Herzstück ermöglicht zum einen den eigenen modularen Aufbau des
 Spring-Frameworks, kann aber auch für die Entwicklung von eigenständiger
 modularer Java-Software eingesetzt werden.
\end_layout

\begin_layout Chapter
IOC Konfiguration
\end_layout

\begin_layout Standard
Wie bereits im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:seperating configuration from use"

\end_inset

 erklärt wurde, muss man bei der Verwendung des 
\shape italic
Dependency Injection Pattern
\shape default
 immer auch eine konkrete Konfiguration für die zur Verfügung stehenden
 und benötigten Plugins bereit stellen.
 Wie diese Konfiguration für bestimmte IOC-Container konkret aussieht soll
 im Folgenden beleuchtet werden.
\end_layout

\begin_layout Section

\shape italic
Spring
\end_layout

\begin_layout Standard

\shape italic
Spring
\shape default

\begin_inset Foot
status open

\begin_layout Plain Layout
Wenn nicht anders angegeben, beziehen sich im gesamten Text Referenzen zum
 Spring-Framework auf 
\shape italic
Spring
\shape default
 in der Releaseversion 3.1.
\end_layout

\end_inset

 ist ein mittlerweile sehr weit verbreitetes, und äußerst umfangreiches
 Java Framework.
 Ungeachtet der zahlreichen Erweiterungen die das Framework seit seinem
 ersten Release erfahren hat, ist der Kern des Spring-Frameworks immer noch
 dessen IOC-Container.
 Die zentrale Rolle des IOC-Containers führte auch dazu, dass im laufe der
 Framework Entwicklung mehrere verschiedene Arten zur IOC-Konfiguration
 entstanden sind und aus Gründen der Flexibilität parallel angeboten werden.
 
\end_layout

\begin_layout Standard
Das Java Interface 
\family sans
\shape italic
org.springframework.beans.factory.BeanFactory
\family default
\shape default
 repräsentiert den 
\shape italic

\begin_inset Newline linebreak
\end_inset

Spring
\shape default
 IOC-Container.
 Über dieses Interface werden alle notwendigen Aktionen abgedeckt.
 Eine 
\family sans
\shape italic
FactoryBean
\family default
\shape default
 Implementierung kann also zum Registrieren von Objekten (Plugins), zum
 Instanziieren von registrierten Objekten, sowie zur Aufbewahrung und Rückgabe
 dieser Instanzen verwendet werden.
 Darüber hinaus übernimmt eine 
\family sans
\shape italic
BeanFactory
\family default
\shape default
 die Aufgabe des Assemblers aus dem DI-Pattern.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Spring
\shape default
 IOC Konfiguration 
\begin_inset CommandInset citation
LatexCommand cite
key "Spring:3.0:TheIoCcontainer"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Spring-IOC-Konfiguration"

\end_inset


\end_layout

\end_inset


\begin_inset Graphics
	filename pics/container-magic.png
	scale 59

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Eine Klasse deren Lebenszyklus durch den 
\shape italic
Spring
\shape default
 IOC-Container verwaltet wird, nennt man ein 
\begin_inset Quotes eld
\end_inset

Bean
\begin_inset Quotes erd
\end_inset

.
 Innerhalb einer 
\shape italic
Spring
\shape default
 Anwendung existieren sowohl Beans als auch ganz normale Java-Klassen nebeneinan
der.
 Beans sind ebenso ganz normale Java-Klassen, nur eben mit dem Zusatz, dass
 sie durch den IOC-Container verwaltet werden.
 Um deren Verwaltung überhaupt durchführen zu können, benötigt der IOC-Container
 eine Konfiguration für die Menge der Beans.
 Diese Konfiguration wird als 
\begin_inset Quotes eld
\end_inset

Configuration Metadata
\begin_inset Quotes erd
\end_inset

 bezeichnet und enthält Metadaten, die Aussage darüber geben welche Beans
 überhaupt in einer Anwendung zur Verfügung stehen und welche Abhängigkeiten
 diese Beans untereinander haben.
 
\shape italic
Spring
\shape default
 bietet verschiedenste Implementierungen des 
\family sans
\shape italic

\begin_inset Newline linebreak
\end_inset

FactoryBean
\family default
\shape default
 Interfaces an.
 Dabei besteht unter anderem die Möglichkeit, die Configuration Metadata
 direkt über Javacode, über Annotationen mit 
\begin_inset Quotes eld
\end_inset

Component scanning
\begin_inset Quotes erd
\end_inset

, über Java-Konfigurationsklassen, oder über XML-Konfigurationsfiles, die
 aus der historischen Entwicklung heraus in 
\shape italic
Spring
\shape default
 als Standardkonfigurationsmethode gelten, festzulegen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Spring-IOC-Konfiguration"

\end_inset

 gibt einen Überblick zur Verwendung des 
\shape italic
Spring
\shape default
 IOC-Containers.
\end_layout

\begin_layout Subsection
Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Spring-Konfiguration"

\end_inset


\end_layout

\begin_layout Standard
Dieser Abschnitt gibt eine kurze Einführung in die beiden Möglichkeiten
 der Konfiguration (XML-Konfiguration und Java-Konfiguration)
\begin_inset Foot
status open

\begin_layout Plain Layout
Die beiden Konfigurationsmethoden werden in der gesamten Arbeit abwechselnd
 behandelt.
 Um in Überschriften anschaulich zu kennzeichnen welche Methode gerade gemeint
 ist, wird der Überschrift entweder (XML) bzw (Java) vorangestellt.
\end_layout

\end_inset

, die in 
\shape italic
Spring
\shape default
 zu Verfügung stehen.
 Die beiden Listings (
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Spring-Bean-Definition-in-XML"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Spring-Bean-Definition-in-Java"

\end_inset

) zeigen die einfache Definition des Service 
\family sans
\shape italic
MyServiceImpl
\family default
\shape default
 als Bean.
 In beiden Varianten wird dasselbe Bean konfiguriert.
 Um die jeweilige Konfiguration zur Anwendung zu bringen, muss sie nur dem
 
\shape italic
Spring
\shape default
 IOC-Container übergeben werden.
\end_layout

\begin_layout Subsubsection*
XML-Variante der 
\shape italic
Spring
\shape default
 Konfiguration
\end_layout

\begin_layout Standard
Ein 
\shape italic
Spring
\shape default
 XML-Konfiguration besteht aus mindestens einer XML-Datei.
 Innerhalb dieser XML-Datei können beliebig viele Beandefinitionen konfiguriert
 werden.
 Diese sind durch den XML-Tag 
\family sans
\series bold
<bean>
\family default
\series default
 gekennzeichnet.
 Alle Beandefinitionen werden innerhalb des Wurzelelements 
\family sans
\series bold
<beans>
\family default
\series default
 angelegt.
 Die Beankonfiguration benötigt dabei mindestens zwei Angaben.
 Zum einen muss im XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
class
\family default

\begin_inset Quotes erd
\end_inset

 der voll qualifizierte Name der Java-Klasse und zum anderen im XML-Attribut
 
\begin_inset Quotes eld
\end_inset


\family sans
id
\family default

\begin_inset Quotes erd
\end_inset

 eine eindeutige Identifikation für das Bean festgelegt werden.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},language=XML,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout
\align left

\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Spring
\shape default
 Beandefinition in XML-Datei
\begin_inset CommandInset label
LatexCommand label
name "lis:Spring-Bean-Definition-in-XML"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout

	<beans
\end_layout

\begin_layout Plain Layout

		xmlns="http://www.springframework.org/schema/beans" 
\end_layout

\begin_layout Plain Layout

		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
\end_layout

\begin_layout Plain Layout

		xsi:schemaLocation=
\end_layout

\begin_layout Plain Layout

			"http://www.springframework.org/schema/beans
\end_layout

\begin_layout Plain Layout

		http://www.springframework.org/schema/beans/
\end_layout

\begin_layout Plain Layout

			spring-beans-3.0.xsd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<bean id="MyBeanId" class="MyServiceImpl">
\end_layout

\begin_layout Plain Layout

			<!-- weitere Metadaten zum jeweiligen Bean -->
\end_layout

\begin_layout Plain Layout

		</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	</beans>
\end_layout

\begin_layout Plain Layout

</xml>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
Java-Variante der Spring Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Java-Variante-der-Spring-Konfig"

\end_inset


\end_layout

\begin_layout Standard
Eine Spring Java-Konfiguration besteht aus mindestens einer Java-Klasse,
 die mit der Annotation 
\family sans
@Configuration
\series bold
 
\family default
\series default
über dem Klassennamen als Spring-Konfiguration markiert ist.
 Um nun in dieser Java-Klasse ein Bean zu definieren, wird eine mit der
 Annotation 
\family sans
@Bean
\family default
 gekennzeichnete Methode benötigt, die eine Instanz der gewünschten Bean-Klasse
 zurück gibt.
 Der Name des Bean kann innerhalb der 
\family sans
@Bean
\family default
 Annotation über den Parameter 
\begin_inset Quotes eld
\end_inset


\family sans
\series bold
name
\family default
\series default

\begin_inset Quotes erd
\end_inset

 angegeben werden.
 Wird der Name nicht explizit definiert, so wird der Methodenname als Name
 für das Bean herangezogen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Spring
\shape default
 Beandefinition in Java-Klasse
\begin_inset CommandInset label
LatexCommand label
name "lis:Spring-Bean-Definition-in-Java"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import org.springframework.context.annotation.Configuration;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@Bean
\end_layout

\begin_layout Plain Layout

	public static MyServiceInterface myBeanId()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyServiceImpl();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Im folgenden Kapitel wird das Tapestry-Framework beschrieben werden.
 Dieses diente als Inspiration und Vorbild für die 
\noun on
SpringContributions.

\noun default
 Dabei kann die gerade beschriebene 
\shape italic
Spring
\shape default
 Java-Konfiguration, durch den Umstand, dass diese ebenfalls in Java-Klassen
 durchgeführt wird, wohl etwas einfacher mit der Tapestry-Variante verglichen
 werden.
 Dasselbe gilt auch für alle späteren Abschnitte.
\end_layout

\begin_layout Section

\shape italic
Tapestry
\end_layout

\begin_layout Standard

\shape italic
Apache Tapestry
\shape default
 
\begin_inset Foot
status open

\begin_layout Plain Layout
Wenn nicht anders angegeben, beziehen sich im gesamten Text Referenzen zum
 Tapestry-Framework auf 
\shape italic
Tapestry 
\shape default
in der Releaseversion 5.0 auch bezeichnet als 
\shape italic
Tapestry 5
\shape default
.
\end_layout

\end_inset

 ist ein Framework zur Entwicklung von Webanwendungen mit Java.
 
\shape italic
Tapestry
\shape default
 unterstützt dabei auch besonders den modularen Aufbau einer Webanwendung.
 Auch hier bildet ein Framework eigener IOC-Container zusammen mit eine
 Reihe von Services das Kernstück des Frameworks.
 Darüber wird die Konfiguration der Module und ihrer Dienste ermöglicht.
 Durch die Verwendung eines IOC-Containers findet die 
\shape italic
Dependency Injection
\shape default
, in ihren verschiedensten Ausprägungen (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Dependency-Injection"

\end_inset

), eine umfassende Verwendung innerhalb aller Teile eines Tapestry-Moduls.
\end_layout

\begin_layout Standard
Ein mit 
\shape italic
Tapestry
\shape default
 entwickeltes Modul wird als Java Archiv (.jar) gepackt und lässt sich in
 dieser Form mit anderen Tapestry-Modulen kombinieren.
 Innerhalb des Archivs wird ein Tapestry-Modul durch eine Modul-Klasse repräsent
iert.
 Diese Klasse stellt dem Framework Informationen über die im Modul vorhandenen
 Services zur Verfügung.
 Der Inhalt der Modul Klasse entspricht hier dem der Konfiguration-Metadaten
 des Spring-Frameworks (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-Konfiguration"

\end_inset

).
\end_layout

\begin_layout Subsection
Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Konfiguration"

\end_inset


\end_layout

\begin_layout Standard
Die Konfiguration eines Tapestry-Moduls besteht aus reinem Javacode.
 
\shape italic
Tapestry
\shape default
 bietet für das Festlegen der Modulkonfiguration innerhalb der Modul-Klasse
 eigene Namenskonventionen und Annotationen an.
 Das Framework erkennt dann zum Beispiel am Anfang eines Methodennamen,
 dass es sich hier um eine Servicedefinition handelt.
 In der Modul-Klasse stehen mehrere Konfigurationsmöglichkeiten zur Verfügung.
 Folgende vier Arten zeigen einen Großteil der Möglichkeiten, wobei wir
 uns in der Folge nur noch mit den ersten beiden beschäftigen werden.
\end_layout

\begin_layout Itemize

\noun on
\begin_inset Quotes eld
\end_inset

Bind
\begin_inset Quotes erd
\end_inset


\noun default
: Das Definieren eines Services, durch das Zuweisen einer Service Implementierun
g zu dem zugehörigen Service Interface
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\noun on
Contribute
\noun default

\begin_inset Quotes erd
\end_inset

: Das Bereitstellen von Service Konfigurationsdaten
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\noun on
Build
\noun default

\begin_inset Quotes erd
\end_inset

: Das Definieren und Bauen eines Services durch expliziten Javacode
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\noun on
Decorate
\noun default

\begin_inset Quotes erd
\end_inset

: Das Dekorieren eines Services, wie es aus dem 
\begin_inset Quotes eld
\end_inset


\shape italic
Decorator Pattern
\shape default

\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset

 bekannt ist
\end_layout

\begin_layout Standard
Eine Servicedefinition in 
\shape italic
Tapestry
\shape default
 entspricht in etwa einer Beandefinition in der Spring-Konfiguration.
 In beiden Fällen handelt es sich um Konfigurationsdaten die dem jeweiligen
 IOC-Container die nötigen Informationen geben, um dem System eine, über
 ein Interface definierte Funktionalität, bereitstellen zu können.
\end_layout

\begin_layout Standard
In 
\shape italic
Tapestry
\shape default
 gibt es verschiedenen Möglichkeiten, ein Service zu definieren.
 Im Allgemeinen existiert für ein Tapestry-Service ein Interface und mindestens
 eine zugehörige Implementierung.
 Um das Service dem System bekannt zu geben wird die 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

bind
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode in Zusammenspiel mit dem 
\family sans
\shape italic
org.apache.tapestry5.ioc.ServiceBinder
\family default
\shape default
 verwendet.
 Über den 
\family sans
\shape italic
ServiceBinder
\family default
\shape default
 wird das Framework informiert, welche Serviceimplementierung für ein Service
 Interface zur Verwendung hinterlegt werden soll (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "tapestry-bind"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tapestry-bind"

\end_inset

 
\shape italic
Tapestry
\shape default
: Registrierung eines Dienstes 
\begin_inset Quotes eld
\end_inset

binding
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void bind(ServiceBinder binder)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		binder.bind(MyServiceInterface.class, MyServiceImpl.class);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Eine weitere Möglichkeit der Service Definition passiert über eine sogenannte
 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

build
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode, die mit dem Service Interface als Rückgabewert definiert wird.
 Bei dieser Art der Servicedefinition können auch gleich Setupmethoden auf
 dem Serviceobjekt durchgeführt werden (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "tapestry-build"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tapestry-build"

\end_inset

 
\shape italic
Tapestry
\shape default
: Definition einer Serviceimplementierung innerhalb der Modulklasse
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static MyServiceInterface build()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyServiceInterface()
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			//service methods and implementation
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Der Konfigurationsmechanismus im Tapestry-Framework unterstützt aber nicht
 nur das Definieren von Services.
 Eine der besonderen Stärken des Frameworks liegt in der Möglichkeit via
 IOC einem Service eine Liste von Objekten des selben Interfacetyps zu übergeben.
 Diese Art der Konfiguration wird in 
\shape italic
Tapestry
\shape default
 mit 
\begin_inset Quotes eld
\end_inset

Contribution
\begin_inset Quotes erd
\end_inset

 bezeichnet.
 Eine genaue Beschreibung des Tapestry Contribution-Mechanismus mit allen
 möglichen Übergabeformen wird im nächsten Kapitel gegeben.
\end_layout

\begin_layout Chapter
Tapestry-Contributions
\end_layout

\begin_layout Standard
Die meisten Services können die Dienste die sie anbieten nicht komplett
 selbstständig erledigen.
 Also stehen Services oft in Abhängigkeit zu anderen Services.
 Es gibt viele Fälle in denen eine solche Abhängigkeit nicht nur in einer
 1:1 Beziehung besteht.
 Es kommt vor, dass sich ein Service einer ganzen Liste an Implementierungen
 eines anderen Serviceinterfaces bedient, um seine Aufgaben zu lösen.
 In einer herkömmlichen Java Anwendung würde diese Liste, bei der Initialisierun
g des Dienstes, an diesen mitgegeben werden.
 In einer durch einen IOC-Container verwalteten Anwendung, benötigen wir
 die Möglichkeit, diese Liste als Konfiguration für das Service bereit zu
 stellen.
 In 
\shape italic
Tapestry
\shape default
 erledigen wir diese Aufgabe über eine 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode in der Konfiguration.
 Laut Namenskonvention beginnt diese Konfigurationsmethode mit der Bezeichnung
 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
contribute
\family default
\shape default

\begin_inset Quotes erd
\end_inset

, gefolgt von dem Namen des Services, für den die Konfiguration und somit
 die Liste gedacht ist (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "tapestry-contribute"

\end_inset

).
 Dadurch entsteht eine eindeutige Zuordnung zwischen der Liste und dem Service
 das sie konsumiert.
\end_layout

\begin_layout Standard
Ein großer Vorteil, den diese Art der Servicekonfiguration durch die Indirektion
 über den IOC-Container mit sich bringt, ist die Möglichkeit jener Liste,
 derer sich der Service bedienen soll, modulübergreifend weitere Implementierung
en hinzuzufügen.
\end_layout

\begin_layout Section
\begin_inset Quotes eld
\end_inset

Configuration
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Wenn man nun einem Service eine Liste von Objekten übergeben möchte, so
 bedient man sich innerhalb der 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode eines Konfiguration-Objekts
\end_layout

\begin_layout Standard
(
\family sans
\shape italic
org.apache.tapestry5.ioc.Configuration<T>
\family default
\shape default
), in dem man die einzelnen Objektdefinitionen ablegen kann (siehe Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tapestry-contribute"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tapestry-contribute"

\end_inset

 
\shape italic
Tapestry
\shape default
: Einfache Listenübergabe
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void contributeMyServiceInterface(Configuration<MyServiceDependen
cyElement> configuration)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		configuration.add(new MyServiceDependencyElementImplOne());
\end_layout

\begin_layout Plain Layout

		configuration.add(new MyServiceDependencyElementImplTwo());
\end_layout

\begin_layout Plain Layout

		// ...
 more Elements to be added to the list
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Der Konfigurationsmechanismus im Tapestry-Framework unterstützt aber nicht
 nur eine einfache Listenübergabe über das Interface 
\end_layout

\begin_layout Standard

\family sans
\shape italic
org.apache.tapestry5.ioc.Configuration<T>
\family default
\shape default
 als Servicecontribution, sondern bietet noch weitere, komplexere Übergabeformen.
\end_layout

\begin_layout Section
\begin_inset Quotes eld
\end_inset

Ordered-Configuration
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Es gibt Anwendungsfälle in denen es nicht ausreicht, einem Service eine
 einfache Liste von Objekten zu übergeben.
 Bei der Verwendung der übergebenen Liste wird diese üblicherweise sequenziell
 abgehandelt.
 Man kann sich nun leicht Fälle vorstellen, bei denen die Reihenfolge der
 Objekte in der Liste nicht beliebig sein kann.
 Wenn zum Beispiel Abhängigkeiten zwischen den einzelnen Diensten aus der
 Liste bestehen, so hat die Reihenfolge ihrer Abarbeitung Auswirkungen auf
 das Ergebnis.
 Für den Fall, dass man also die Reihenfolge der Dienste in der Liste beeinfluss
en möchte bzw.
 muss, bietet 
\shape italic
Tapestry
\shape default
 die Übergabeform einer geordneten Liste über das Interface
\end_layout

\begin_layout Standard

\family sans
\shape italic
org.apache.tapestry5.ioc.OrderedConfiguration<T> 
\family default
\shape default
an.
 Wie eine derartige 
\begin_inset Quotes eld
\end_inset

Ordered Contribution
\begin_inset Quotes eld
\end_inset

 als Konfiguration durchgeführt wird zeigt das Codebeispiel in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tapestry-ordered-contribution"

\end_inset

.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Tapestry
\shape default
: Sortierte Listenübergabe
\begin_inset CommandInset label
LatexCommand label
name "lis:tapestry-ordered-contribution"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void contributeMyServiceInterface(OrderedConfiguration<MyServiceD
ependencyElement> configuration)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		configuration.add("last", new LastService(), "after:*");
\end_layout

\begin_layout Plain Layout

		configuration.add("second", new SecondService(), "after:first");
\end_layout

\begin_layout Plain Layout

		configuration.add("first", new FirstService(), "before:*");
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		// ...
 more Elements to be added to the ordered list
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tapestry-ordered-contribution"

\end_inset

 wird eine Servicekonfiguration durchgeführt, in der festgelegt ist, dass
 einem Service, der das Interface 
\family sans
\shape italic
MyServiceInterface
\family default
\shape default
 implementiert, eine sortierte Liste von Services übergeben werden soll.
 Die Sortierung der Liste kann dabei durch die Schlüsselwörter 
\begin_inset Quotes eld
\end_inset


\family sans
before
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
after
\family default

\begin_inset Quotes erd
\end_inset

 in Zusammenhang mit dem Wildcardzeichen 
\family sans

\begin_inset Quotes eld
\end_inset


\series bold
*
\series default

\begin_inset Quotes erd
\end_inset


\family default
 oder dem direkten Bezug auf ein anderes Element der Liste beschrieben werden.
 Um den direkten Bezug auf andere Elemente zu ermöglichen, müssen den einzelnen
 Elementen eindeutige Namen zugeordnet werden.
 Die Sortierung der Liste ist im Beispiel so eingestellt, dass das Service
 
\family sans
\shape italic
FirstService
\family default
\shape default
 an erster Stelle, vor allen anderen kommt, gefolgt von dem Service 
\family sans
\shape italic
SecondService
\family default
\shape default
 und dem Service 
\family sans
\shape italic
LastService
\family default
\shape default
, der das Ende der Liste bildet.
\end_layout

\begin_layout Section
\begin_inset Quotes eld
\end_inset

Mapped-Configuration
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:Mapped-Configuration"

\end_inset


\end_layout

\begin_layout Standard
Es lassen sich aber auch Anwendungsfälle finden, in denen die Datenstruktur
 einer Liste, sei sie geordnet oder ungeordnet, als Übergabeform für ein
 zu konfigurierendes Service nicht ausreicht, um die ihm gestellten Aufgaben
 zu bewältigen.
 In manchen Fällen ist es notwendig, Services anhand von Schlüsselelementen
 zu identifizieren.
 Für diese Zuordnung kann eine Listenstruktur nicht mehr verwendet werden.
 Sehr wohl lässt sich aber eine derartige Anforderung in Java durch den
 Objekttyp einer 
\family sans
\shape italic
Map
\family default
\shape default
 realisieren.
 Damit es nun auch möglich ist, Services mit Schlüsseln in Beziehung zu
 bringen, und dies auch als Konfiguration im IOC-Container abzulegen, bietet
 
\shape italic
Tapestry
\shape default
 das Interface 
\family sans
\shape italic
org.apache.tapestry5.ioc.MappedConfiguration<K,V>
\family default
\shape default
 an.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Tapestry
\shape default
: Serviceübergabe mit Schlüsselmapping
\begin_inset CommandInset label
LatexCommand label
name "lis:tapestry-mapped-ordered-contribution"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void contributeMyServiceInterface(MappedConfiguration<String,
 MyServiceDependency> configuration)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		configuration.add("keyFoo", new FooService());
\end_layout

\begin_layout Plain Layout

		configuration.add("keyFooFoo", new FooFooService());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// ...
 more key/value pairs to be added to the map
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tapestry-mapped-ordered-contribution"

\end_inset

 wird die Verwendung einer 
\begin_inset Quotes eld
\end_inset

Mapped Contribution
\begin_inset Quotes erd
\end_inset

 gezeigt.
 Dabei wird eine Servicekonfiguration angelegt, die einem Service, das das
 Interface 
\family sans
\shape italic
MyServiceInterface
\family default
\shape default
 implementiert, eine Map übergibt.
 Über die Schlüssel 
\begin_inset Quotes eld
\end_inset


\family sans
keyFoo
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
keyFooFoo
\family default

\begin_inset Quotes erd
\end_inset

 kann das Service dann Zugriff auf die zwei, den Schlüsseln zugeordneten,
 Objekte erhalten.
\end_layout

\begin_layout Chapter
Bean-Listen und Bean-Maps in 
\shape italic
Spring
\end_layout

\begin_layout Standard
In 
\shape italic
Spring
\shape default
 gibt es von Haus aus die Möglichkeit, unterschiedliche Beans vom selben
 Interfacetyp in Listen oder in Maps zusammenzufassen und via 
\shape italic
Dependency Injection
\shape default
 an andere Beans weiterzugeben.
 Dieser Dienst des IOC-Containers ist in seiner Form etwas wie eine leichtgewich
tige Minimalform des Tapestry Contribution-Services.
 
\shape italic
Spring
\shape default
 stellt diese Funktionalität automatisch zur Verfügung und sieht dafür keine
 eigenständige Konfigurationssyntax vor.
 Der Mechanismus läuft dabei folgendermaßen ab.
 Sobald der IOC-Container ein Bean instanziieren muss, dessen Konstruktor
 eine Liste von Objekten erwartet, die dasselbe Interface implementieren,
 werden alle im IOC-Container befindlichen Beans auf die diese Eigenschaft
 zutrifft, in eine Liste verpackt und dem konsumierenden Bean bei der Erstellung
 übergeben.
\end_layout

\begin_layout Standard
Dasselbe Prinzip wird auch für Map-Parameter angewandt, wobei die einzelnen
 Beans nun als Werte in einer Map zusammengefasst werden.
 Als Schlüssel wird jeweils der in der Konfiguration festgelegte Name des
 Beans herangezogen.
 Zur Beschreibung dieses Mechanismus zeigt Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Spring:-leichtgewichtige-Standard-Contribution-Classes"

\end_inset

 zwei Java Klassen als Konsumenten und Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Spring:-leichtgewichtige-Standard-Contribution-Config"

\end_inset

 die zugehörige, benötigte Spring-Beankonfiguration.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Spring
\shape default
: 
\begin_inset Quotes eld
\end_inset

leichtgewichtige
\begin_inset Quotes erd
\end_inset

 Standard-Contribution Konsumenten
\begin_inset CommandInset label
LatexCommand label
name "lis:Spring:-leichtgewichtige-Standard-Contribution-Classes"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Java-Implementierung eines Listen-Konsumenten
\end_layout

\begin_layout Plain Layout

public class ListValueHolder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public ListValueHolder(List<String> contributedStringList)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//do something with the list
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Java-Implementierung eines Map-Konsumenten
\end_layout

\begin_layout Plain Layout

public class MapValueHolder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public MapValueHolder(Map<String, String> contributedStringMap)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//do something with the map
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\shape italic
Spring
\shape default
: 
\begin_inset Quotes eld
\end_inset

leichtgewichtige
\begin_inset Quotes erd
\end_inset

 Standard-Contribution Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "lis:Spring:-leichtgewichtige-Standard-Contribution-Config"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Bean Konfig des Listen-Konsumenten -->
\end_layout

\begin_layout Plain Layout

<bean name="listValueHolder" class="org.springframework.contributions.ListValueHold
er" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Bean Konfig des Map-Konsumenten -->
\end_layout

\begin_layout Plain Layout

<bean name="mapValueHolder" class="org.springframework.contributions.MapValueHolder
" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Konfiguration der Elemente für die Liste und die Map-->
\end_layout

\begin_layout Plain Layout

<bean name="string1" class="java.lang.String" value="String 1" />
\end_layout

\begin_layout Plain Layout

<bean name="string2" class="java.lang.String" value="String 2" />
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Die eine Klasse 
\family sans
\shape italic
ListValueHolder
\family default
\shape default
 erwartet in ihrem Konstruktor eine Liste von Strings.
 Da in der XML-Beankonfiguration zwei Beans vom Typ 
\family sans
\shape italic
String
\family default
\shape default
 angegeben sind, wird 
\shape italic
Spring
\shape default
 beim Instanziieren des Beans 
\family sans
\shape italic
ListValueHolder
\family default
\shape default
 diese beiden Strings in eine Liste verpacken und diese Liste an den Konstruktor
 übergeben.
 Im Vergleich zur Tapestry-Variante der Konfiguration hat man hier auf die
 Reihenfolge der Beans in der Liste keine explizite Einflussmöglichkeit.
\end_layout

\begin_layout Standard
Die zweite Klasse 
\family sans
\shape italic
MapValueHolder
\family default
\shape default
 erwartet in ihrem Konstruktor eine 
\family sans
\shape italic
Map
\family default
\shape default
 mit 
\family sans
\shape italic
Strings
\family default
\shape default
 als Schlüssel und Wert.
 Hier würde 
\shape italic
Spring
\shape default
 beim Instanziieren der Klasse automatisch eine 
\family sans
\shape italic
Map
\family default
\shape default
 erstellen, dieser die beiden String-Beans als Werte mit deren Beannamen
 als Schlüssel hinzufügen und die 
\family sans
\shape italic
Map
\family default
\shape default
 dem Konstruktor übergeben.
 Auch hier bietet die Konfiguration keine komplexeren Möglichkeiten, wie
 zum Beispiel das Verwenden von Enumeration-Werten als Schlüssel.
\end_layout

\begin_layout Chapter

\noun on
SpringContributions - Eine 
\noun default
Umsetzung als Spring-Erweiterung
\end_layout

\begin_layout Standard
Das Spring-Framework ist selbst aus Komponenten aufgebaut.
 Aus diesem Grund bietet es auch die einfache Möglichkeit, neue Komponenten
 in das Framework zu integrieren.
 Dies hat sowohl Vorteile für die interne Weiterentwicklung, als auch für
 die Entwicklung von Erweiterungen durch Außenstehende.
 Um die aus dem Tapestry-Framework bekannte Contribution-Funktionalitäten
 auch in 
\shape italic
Spring
\shape default
 einführen zu können, wurde genau diese Möglichkeit verwendet und die eigene
 Spring-Komponente 
\noun on
SpringContributions
\noun default
 entwickelt.
\end_layout

\begin_layout Standard
Seit den Anfängen der Spring-Framework Entwicklung gibt es auch den klassischen
 XML-Konfigurationsmechanismus des Frameworks.
 Wenn das Framework um neue Funktionalität und damit einhergehend die Konfigurat
ion um neue Schlüsselwörter erweitert wurden, so geschah dies also immer
 über die Definition von XML-Elementen.
 Im Rahmen dieser Arbeit wurde zu Beginn genau dieser klassische Weg gewählt,
 um die 
\noun on
SpringContributions 
\noun default
Erweiterung umzusetzen.
\end_layout

\begin_layout Standard
Seit der Hauptversion 3.0 bietet 
\shape italic
Spring
\shape default
, parallel zur XML-Konfiguration, einen weiteren Weg der Konfiguration an.
 Die neue Möglichkeit, 
\shape italic
Spring
\shape default
 zu verwenden, nennt sich 
\begin_inset Quotes eld
\end_inset

Java Configuration
\begin_inset Quotes erd
\end_inset

 und wurde aus der zuvor eigenständig entwickelten Projekt 
\begin_inset Quotes eld
\end_inset


\shape italic
Spring JavaConfig
\shape default

\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "SpringJavaConfig:2013"

\end_inset

 in das Spring-Framework übernommen.
 Dabei handelt es sich, wie der Name bereits vermuten lässt, um eine Möglichkeit
, mittels der man die gesamte Spring-Konfiguration eines Projektes in Java-Klass
en vornehmen kann.
 Es ist ein Einfaches, sich vorzustellen, dass es viele Vorteile geben kann,
 die Konfiguration eines Projektes, statt in einer Auszeichnungssprache
 wie XML, in einer Programmiersprache wie Java durchführen zu können.
 Daher war es auch ein Ziel bei der Entwicklung der 
\noun on
SpringContributions 
\noun default
Erweiterung, eben auch diese zweite Konfigurationsmöglichkeit anzubieten.
 Wie die Herangehensweise bei der Umsetzung des jeweiligen Konfigurationsmechani
smus aussieht, wird in den Unterabschnitten 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-Erweiterung-mittels-XML-Config"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-Erweiterung-mittels_Java-Config"

\end_inset

 behandelt.
\end_layout

\begin_layout Section
Konzeptionelle Unterschiede von 
\shape italic
Tapestry
\shape default
 zu 
\noun on
SpringContributions
\end_layout

\begin_layout Standard
Das Spring IOC-Modell unterscheidet sich in manchen Punkten deutlich vom
 Tapestry IOC-Modell.
 Einer der Unterschiede wirkt sich dabei auch maßgeblich auf die Umsetzung
 und die Funktionalität der 
\noun on
SpringContributions
\noun default
 aus.
 Es handelt sich dabei um den Umstand, dass in 
\shape italic
Spring
\shape default
 jedes Konfigurationseinheit in einem Bean abgebildet wird.
 Das Bean-Konzept in 
\shape italic
Spring
\shape default
 schreibt vor, dass jedes Bean auf jeden Fall eine eindeutige Identifikation
 besitzen muss.
 Dieser Umstand wurde in der Konzeption der 
\noun on
SpringContributions
\noun default
 miteinbezogen und konnte dazu genutzt werden, durch eine kleine Abweichung
 vom Vorbild des Tapestry Contribution-Mechanismus, einen Mehrwert in den
 Verwendungsmöglichkeiten zu gewinnen.
\end_layout

\begin_layout Standard
In 
\shape italic
Tapestry
\shape default
 verhält es sich so, dass eine Contribution immer eindeutig einem Konsumenten
 zugeordnet ist.
 In der Spring-Konfiguration wird jede Contribution als eigenes Konfigurationsel
ement und somit als eigenes Objekt bzw.
 Bean behandelt.
 Wie bereits erwähnt, erhält nun jedes Bean zur Identifikation auch einen
 eigenen, eindeutigen Namen.
 Daraus ergibt sich, dass in 
\shape italic
Spring
\shape default
 eine Contribution, die ja als eigenes und über den eindeutigen Namen eindeutig
 referenzierbares Objekt existiert, nicht nur von einem bestimmten, sondern
 von vielen beliebigen Konsumenten verwendet werden kann.
 Ist ein Contribution-Bean also einmal definiert, so kann jedes Bean das
 sich nun dieser Contribution anschließen oder sich ihrer bedienen will,
 über deren eindeutigen Namen das tatsächliche Bean referenzieren.
 Dieser Vorteil, aber auch die zu beachtenden Risiken bei der mehrfachen
 Verwendung einer Contributions, wird im Unterabschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Contributions-mehrfach-konsumier"

\end_inset

 noch genauer beleuchtet.
\end_layout

\begin_layout Standard
Der eben erwähnte Mehrwert in der Verwendung bringt aber auch gleichzeitig
 neue Herausforderungen für den Anwender.
 Dieser ist nämlich selbst für die Vergabe der Namen für Contributions verantwor
tlich und muss sich deshalb selbst um deren Eindeutigkeit kümmern.
 Wie der Name für ein Contribution-Bean definiert wird, ist im Detail im
 Unterabschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Contribution-Bean-Identifikation"

\end_inset

 beschrieben.
\end_layout

\begin_layout Standard
Zusätzlich ist es im Unterschied zur Tapestry-Vorlage, durch das Wegfallen
 der eindeutigen Zuordnung einer Contribution zu genau einem Konsumenten,
 nötig den Namen der Contribution innerhalb der Konfiguration des Konsumenten
 zu wissen und anzugeben.
 Das automatische Auflösen der Referenzen von Konsument zu Contribution
 durch den IOC-Container kann also in den 
\noun on
SpringContributions
\noun default
 nur mehr auf Basis des eindeutigen Namen funktionieren.
\end_layout

\begin_layout Standard
Ein weiterer, konzeptioneller Unterschied zur Tapestry-Vorlage betrifft
 die Abbildung der Listenform einer Contribution.
 In den 
\noun on
SpringContributions
\noun default
 wird nicht mehr extra zwischen unsortierten und sortierten Listen unterschieden.
 Dieser Weg wurde gewählt, um die Menge der unterschiedlichen Konfigurationselem
ente möglichst gering zu halten.
 Es wird also nur noch ein Konfigurationselement für eine Contribution-Liste
 benötigt, egal ob diese sortiert oder unsortiert sein soll.
 Die Angabe einer Reihenfolge der Listenelemente wird über eine optionale
 Sortierungsangabe ermöglicht.
 Demnach besteht nur noch die Unterscheidung zwischen Listenübergabe und
 
\begin_inset Quotes eld
\end_inset

gemappter
\begin_inset Quotes erd
\end_inset

 Übergabeform.
 Im 
\noun on
SpringContributions
\noun default
-Kontext werden für diese beiden Übergabeformen von nun an die Bezeichnungen
 Contribution-Liste und Contribution-Map verwendet.
\end_layout

\begin_layout Section
Die zwei Wege der Spring-Erweiterung
\end_layout

\begin_layout Standard
Dieser Abschnitt soll zeigen was genau gemacht werden muss, wenn man 
\shape italic
Spring
\shape default
 mit einer der beiden angebotenen Möglichkeiten um ein Modul erweitern möchte.
 Zuerst wird auf die Erweiterung mit der klassischen XML-Konfiguration eingegang
en, danach folgt eine ausführliche Beschreibung der Erweiterung über die
 Java-Konfiguration.
\end_layout

\begin_layout Subsection
Erweiterung mittels Spring XML-Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Spring-Erweiterung-mittels-XML-Config"

\end_inset


\end_layout

\begin_layout Standard
Entscheidet man sich, bei der Erweiterung von 
\shape italic
Spring
\shape default
 dafür, den klassischen Weg der XML-Konfiguration anzubieten, so sind die
 Ausgangspunkte in der Entwicklung der neuen Komponente ein eigener Namensraum
 und das zugehöriges XML-Schema.
 Die für 
\shape italic
Spring
\shape default
 ab der Version 3.0 entwickelten 
\noun on
SpringContributions
\noun default
 verwenden das XML-Schema 
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset


\family sans
\size footnotesize
http://www.springframework.org/schema/contributions/spring-contributions-3.0.xsd
\family default
\size default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
mit dem XML-Namensraum 
\begin_inset Quotes eld
\end_inset


\family sans
\size footnotesize
http://www.springframework.org/schema/contributions
\family default
\size default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Um die Grundlage für den 
\shape italic
Spring
\shape default
 Contribution-Mechanismus zu legen, werden im XML-Schema einige neue Konfigurati
onselemente definiert.
 Jede einzelne dieser Konfigurationsmöglichkeiten wird in Unterabschnitt
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:XML--und-Java-Konfiguration-im-Detail"

\end_inset

 genauer beschrieben werden.
 Dabei werden die zur Verwendung stehenden XML-Elemente und XML-Attribute,
 ausgehend von ihrer Schemadefinition und im Hinblick auf ihre Anwendung,
 eingeführt.
\end_layout

\begin_layout Subsection
Spring-Erweiterung mittels Java-Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Spring-Erweiterung-mittels_Java-Config"

\end_inset


\end_layout

\begin_layout Standard
Will man für eine eigene Spring-Komponente die Konfiguration auch als Spring
 Java-Konfiguration (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Java-Variante-der-Spring-Konfig"

\end_inset

) ermöglichen, so gibt es zwei unterschiedliche Wege der Umsetzung.
 Zum einen bietet 
\shape italic
Spring
\shape default
 eine Eingriffsmöglichkeit, bei der man sich direkt in die früheste Phase
 der Registrierung von Beandefinitionen einschalten kann (siehe Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Spring-Java-Konfiguration_Eingriff während der Bean Definition Registrierung"

\end_inset

).
 Zum anderen kann man nach Ablauf der Standardregistrierung von Beandefinitionen
 eingreifen und die bestehenden Definitionen verwenden, anpassen und auch
 neue Definitionen hinzufügen (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Spring-Java-Konfiguration_Eingriff nach der Bean Definition Registrierung"

\end_inset

).
 Für eine erste Umsetzung der Java-Konfiguration für die 
\noun on
SpringContributions
\noun default
 habe ich mich für die zweite Variante entschieden, wobei ein kleiner Teil
 der Umsetzung sich auch auf die erste Variante stützt.
 Auf die Gründe für diese Entscheidung und die Umsetzung werde ich nach
 der Beschreibung der beiden möglichen Varianten genauer eingehen.
\end_layout

\begin_layout Paragraph*
Eingriff während der Beandefinition Registrierung (Variante 1):
\begin_inset CommandInset label
LatexCommand label
name "par:Eingriff-während-der-Registrierung_Variante-1"

\end_inset


\end_layout

\begin_layout Standard
Ebenso wie ein XML-Konfigurationsfile muss auch eine Spring Java-Konfigurationsk
lasse zuallererst geparst werden.
 Danach werden alle Annotationen (
\family sans
@PropertySource
\family default
, 
\family sans
@ComponentScan
\family default
, 
\family sans
@Import
\family default
,
\family sans
\series bold
 
\series default
@Bean
\family default
, etc.
 ) und deren Metadaten in einer festen Reihenfolge abgearbeitet.
 Jeder Schritt in dieser Abarbeitungskette behandelt eine ganz bestimmte
 Annotation und den zugehörigen Konfigurationscode.
 Dabei bietet die Abarbeitung der 
\family sans
\series bold
@Import
\family default
\series default
 Annotationen, die noch vor der 
\family sans
@Bean
\family default
 Annotation an dritter Stelle behandelt wird, den Anknüpfungspunkt für eigene
 Erweiterungen der Java-Konfiguration.
 Über diesen Weg lässt sich ein eigener 
\family sans
\shape italic
ImportBeanDefinitionRegistrar
\family default
\shape default
 definieren, in den die Logik zum Registrieren der Beandefinitionen kommt.
 Diese Klasse lässt sich dann über die 
\family sans
@Import
\family default
 Annotation an eine eigens definierte Annotation (z.B.
 
\family sans
@EnableContributions
\family default
) binden.
 Verwendet man nun diese selbst definierte Annotation innerhalb einer Java-Konfi
guration, so wird also beim Abarbeiten der Imports die 
\family sans
\shape italic
registerBeanDefinitions
\family default
\shape default
 Methode der 
\family sans
\shape italic
ImportBeanDefinitionRegistrar
\family default
\shape default
 Klasse aufgerufen und die eigenen Logik zum registrieren von Beandefinitionen
 angewandt.
\end_layout

\begin_layout Standard
Bei diesem Weg der Erweiterung befindet man sich zeitlich noch vor der 
\shape italic
Spring
\shape default
 eigenen Beandefinition Registrierung und damit sehr früh in der Abfolge
 der IOC-Registry Erstellung.
 Das würde den Vorteil ergeben, dass alle mit 
\family sans
@Bean
\family default
 definierten Services bereits die Contribution-Konfiguration verwenden könnten.
 Umgekehrt besteht natürlich nicht die Möglichkeit, bei der Abarbeitung
 der Contribution-Konfiguration, bereits auf die Beandefinitionen zuzugreifen.
 Wenn man also die Beans für die Contribution schon zu diesem Zeitpunkt
 benötigt, so muss man sich ebenfalls selbst darum kümmern.
 Das heißt, man müsste äquivalent zur 
\family sans
@Bean
\family default
 Annotation, eine eigene Konfiguration für Beans anbieten.
 Darüber könnte man schließlich Beans definieren, deren Definition dann
 bereits zum Erstellungszeitpunkt der Contribution-Konfiguration zur Verfügung
 stehen würden.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spring Java-Konfiguration Erweiterung (Variante 1)
\begin_inset CommandInset label
LatexCommand label
name "fig:Spring-Java-Konfiguration_Eingriff während der Bean Definition Registrierung"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/CreatingBeanDefinitionsFromConfigurations (JAVA).eps
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph*
Eingriff nach der Beandefinition Registrierung (Variante 2):
\begin_inset CommandInset label
LatexCommand label
name "par:Java-Konfig-Variante2"

\end_inset


\end_layout

\begin_layout Standard
Bei dieser Variante kann mittels eines Postprozessors, in einer zuletzt
 gereihten Phase beim Erstellen des 
\family sans
\shape italic
ApplicationContext
\family default
\shape default
, die vom Spring-Kern erstellte IOC-Konfiguration angepasst werden.
 Zu diesem späten Zeitpunkt sind bereits alle 
\shape italic
Spring
\shape default
 eigenen Standardkonfigurationen als Beandefinitionen in der IOC-Registry
 abgelegt.
 Nun kann man innerhalb einer Implementierung des Interfaces 
\family sans
\shape italic
BeanDefinitionRegistryPostProcessor
\family default
\shape default
 den Code zur Abarbeitung der 
\noun on
SpringContributions
\noun default
 Konfiguration realisieren.
 Hier ist es dann natürlich möglich, alle bereits bestehenden Beandefinitionen
 in der Abarbeitung der Contribution-Konfiguration zu berücksichtigen und
 zu referenzieren.
 Man hat hier also den Vorteil, sich selbst nur um die Cotribution-Bean
 Erstellung und nicht um die normale Beankonfiguration Erstellung kümmern
 zu müssen, da diese ja bereits im Spring-Kern erstellt wurden.
\end_layout

\begin_layout Standard
Natürlich besteht bei dieser Variante nicht die Möglichkeit, dass in der
 normalen Beandefinition Abarbeitung bereits auf die Contribution-Definitionen
 zugegriffen werden kann, da diese ja erst im Postprozessor erstellt werden.
 Konkret bedeutet das für die Umsetzung der 
\noun on
SpringContributions
\noun default
, dass für die normalen mit 
\family sans
@Bean
\family default
 annotierten Beankonfigurationen eine Indirektion zum Zugriff auf Conribution-Be
ans verwendet werden muss.
 Dazu müssen eigene 
\begin_inset Quotes eld
\end_inset

Resolver Services
\begin_inset Quotes erd
\end_inset

 angeboten werden, die schon zum Erstellungszeitpunkt der Beans zur Verfügung
 stehen und später, beim Instanziieren der Beans, einen Zugriff auf die
 Contribution-Beans ermöglichen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spring Java-Konfiguration Erweiterung (Variante 2)
\begin_inset CommandInset label
LatexCommand label
name "fig:Spring-Java-Konfiguration_Eingriff nach der Bean Definition Registrierung"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/CreatingBeanDefinitionsFromConfigurations (JAVA)_postprocess.eps
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subparagraph
Ehemals mögliche Variante 3:
\end_layout

\begin_layout Standard
Bevor die Java-Konfiguration in das Spring-Kernprojekt übernommen wurde,
 existierte sie als eigenes Projekt mit dem Namen 
\begin_inset Quotes erd
\end_inset


\shape italic
Spring Java Configuration
\shape default

\begin_inset Quotes erd
\end_inset

.
 Die Entwickler dieses Projektes hatten sich einen angenehmen Weg der Erweiterun
g der Java-Konfiguration ausgedacht.
 Dabei lehnten sie sich an den aus dem Spring-Framework bekannten Namespacehandl
er-Mechanismus für die Erweiterung der XML-Konfiguration an.
 Umgesetzt war die Erweiterbarkeit über eine eigens definierte Annotation
 
\family sans
@Plugin
\family default
 und das angebotene Interface 
\family sans
\shape italic
ConfigurationPlugin
\family default
\shape default
.
 Das Interface musste implementiert werden und enthielt dann den nötigen
 Code für die neue Java-Konfiguration Funktionalität.
 Diese Implementierung konnte dann mit der 
\family sans
@Plugin
\family default
 Annotation an eine eigene Annotation gebunden werden.
 Über die eigene Annotation konnte dann die neue Funktionalität in jeder
 normalen Konfigurationsklasse mit eingebunden werden.
 Diese Art der Erweiterung war ähnlich der zuvor vorgestellten Variante
 1 und wurde dann auch nicht in das Kernprojekt von 
\shape italic
Spring
\shape default
 mit übernommen.
\end_layout

\begin_layout Subparagraph
Auswahl von Variante 2 für die konkrete Umsetzung:
\end_layout

\begin_layout Standard
Für die Implementierung der 
\noun on
SpringContributions
\noun default
 Java-Konfiguration fiel die Entscheidung auf die zweite Variante, da für
 die erste Variante die komplette Beankonfiguration Generierung von 
\shape italic
Spring
\shape default
 erneut implementiert hätte werden müssen.
 Da sich aber der interne Spring-Code für die Beankonfiguration Generierung
 nicht zur Wiederverwendung eignet, hätte hier all zu viel recht komplexer
 Code dupliziert werden müssen.
 Dieses Unterfangen wäre nicht nur besonders fehleranfällig gewesen, sondern
 hätte auch besonders intensive Wartungsarbeit erfordert, wenn sich im Zuge
 von Versionsänderungen die diesbezügliche Logik im Spring-Framework geändert
 hätte.
 Demzufolge wäre das gesamte 
\noun on
SpringContributions
\noun default
 Modul durch eine Umsetzung der ersten Variante sehr fragil geworden.
\end_layout

\begin_layout Standard
Durch die Wahl der zweiten Variante, entsteht nun aber die Notwendigkeit
 der Entkopplung von Referenzen auf Contribution-Beans.
 Dies muss durch die Verwendung von eigenen 
\begin_inset Quotes eld
\end_inset

Resolver Services
\begin_inset Quotes erd
\end_inset

 (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:(Java)-Contributions-Referenzier_Resolver-Services"

\end_inset

) realisiert werden.
 Da aber die Umsetzung dieser Services keinen großen Aufwand bedeutet, und
 die Verwendung von derartigen Services das Benutzen der Java-Konfiguration
 auch nicht erheblich komplexer gestaltet, gibt es auch deshalb keinen triftigen
 Grund, der ersten Variante den Vorzug zu geben.
 Deshalb fiel die Wahl bei der Umsetzung auf die Variante 2, und damit auf
 das Abarbeiten der Contribution-Konfiguration über das Postprocessing.
\end_layout

\begin_layout Subparagraph
Probleme in der Umsetzung:
\end_layout

\begin_layout Standard
Bei der Konzeption der Contribution-Map Funktionalität für die Java-Konfiguratio
n ergaben sich einige Probleme dabei, exakt dasselbe Set an Konfigurationsmöglic
hkeiten zur Verfügung zu stellen, wie es bereits in der XML-Variante umgesetzt
 worden war.
 In 
\shape italic
Spring
\shape default
 hat man sich bei der Java-Konfiguration dafür entschieden, Konfigurationsmetada
ten über Annotationen abzubilden.
 Aus Gründen der Konsistenz baut die Java-Konfiguration der 
\noun on
SpringContributions
\noun default
 ebenfalls auf Annotationen auf.
 Diese Entscheidung bringt leider auch einen Nachteil gegenüber der Tapestry-Var
iante der Konfiguration mit sich.
 In 
\shape italic
Tapestry
\shape default
 werden die Konfigurationsmetadaten auch ohne Annotationen, großteils in
 Verbindung mit eigenen Builder-Services, geregelt.
 Es werden die Konfigurationsmetadaten also hauptsächlich im Javacode der
 einzelnen Konfigurationsmethoden angegeben.
 Dadurch ist es in einer Tapestry-Konfigurationsklasse möglich, für die
 Konfiguration auch auf Objekte bzw.
 Variablen zuzugreifen.
 Dabei kann dann natürlich auch die Syntaxprüfung des Compilers genutzt
 werden.
 Verwendet man jedoch den in 
\shape italic
Spring
\shape default
 gängigen Weg der Java-Konfiguration und benutzt hauptsächlich Annotationen
 als Konfigurations-Metadaten, dann fällt die Unterstützung der Syntaxprüfung
 durch den Compiler, in Zusammenhang mit verwendeten Objekten bzw.
 Variablen, dieser Entscheidung zum Opfer.
 Das liegt daran, dass es in Annotationen nicht möglich ist, Objektreferenzen
 als Parameter anzugeben.
\end_layout

\begin_layout Standard
Aus der ausschließlichen Verwendung von Annotationen zur Abbildung der Konfigura
tionsmetadaten ergab sich darüber hinaus noch eine Schwierigkeit in der
 Umsetzung des von der XML-Lösung bekannten Funktionsumfangs.
 Die momentane Implementierung bildet daher einen Kompromiss aus dem Streben
 nach Äquivalenz zur XML-Konfiguration und dem Bemühen, die Java-Konfiguration
 überschaubar und verwendbar zu gestalten.
 So wurde zum Beispiel die Möglichkeit weggelassen, konkrete Beans beziehungswei
se Objekte als Schlüsselelement einer Contribution-Map verwenden zu können.
 Auf diese Möglichkeit musste verzichtet werden, da man eben in einer Annotation
 keine konkreten Objektinstanzen übergeben kann.
\end_layout

\begin_layout Standard
Da Enumerationen sich, seit ihrer Einführung in Java, einer sehr hohen Beliebthe
it erfreuen, war es wichtig die Möglichkeiten der Verwendung von Enumerationen
 als Schlüssel der Contribution-Map umzusetzen.
 Dies konnte leider, wieder aufgrund der Eigenschaften von Annotationen,
 nur über die Verwendung der zwei Parameter Enumeration-Klasse und Enumeration-W
ert verwirklicht werden (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(Java)-Contribution-Map:-Enumeration Key Definition"

\end_inset

).
 Die direkte Angabe einer konkreten Enumeration, wie dies in der XML-Konfigurati
on möglich ist, konnte nicht umgesetzt werden.
 Daraus ergibt sich, dass sich der Vorteil der IDE-Unterstützung bezüglich
 der Referenzsuche im Javacode, im Falle der Konfiguration für eine Contribution
-Map mit Enumeration als Schlüssel, nicht ausnutzen lässt.
\end_layout

\begin_layout Standard
Ein letzter wichtiger Punkt war die Verwendung von Klassen als Schlüssel
 der Contribution-Map.
 Da es bei der Verwendung des Strategy-Services (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Strategy-Service"

\end_inset

) unbedingt notwendig ist, Klassen als Schlüssel in einer Contribution-Map
 zu verwenden, konnte auf diese Funktionalität nicht verzichtet werden.
\end_layout

\begin_layout Section
XML- und Java-Konfiguration im Detail
\begin_inset CommandInset label
LatexCommand label
name "sub:XML--und-Java-Konfiguration-im-Detail"

\end_inset


\end_layout

\begin_layout Standard
In diesem Abschnitt werden die einzelnen Konfigurationselemente der beiden
 Konfigurationsarten (XML, Java) im Bezug auf ihre Anwendung beschrieben.
 Dabei wird abwechslungsweise, für jede Art von Konfiguration, zuerst die
 XML-Variante und darauf folgend die Java-Variante erläutert.
\end_layout

\begin_layout Subsection
(XML) Contributions Referenzieren
\begin_inset CommandInset label
LatexCommand label
name "sub:SpringContribution:XML-cotribution-ref"

\end_inset


\end_layout

\begin_layout Standard
Die folgenden beiden XML-Elemente können verwendet werden um Contributions
 der verschiedenen Typen zu referenzieren.
\end_layout

\begin_layout Subparagraph
XML-Element 
\begin_inset Quotes eld
\end_inset

contribution-ref
\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset

mapped-contribution-ref
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "par:XML-Elemente-contribution-ref"

\end_inset

:
\end_layout

\begin_layout Standard
Über das Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 wird ein Contribution-Listen Objekt referenziert.
 Möchte man eine Contribution-Map referenzieren, so muss man das XML-Element
 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 verwenden.
 Für beide Typen gilt, dass in dem XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
name
\family default

\begin_inset Quotes erd
\end_inset

 der Name des zu verwendenden Contribution-Bean angegeben wird.
 Beide XML-Elemente können nun an allen möglichen Stellen, also z.B.
 innerhalb einer Konstruktor Definition oder auch in einer Setter Definition
 eines Beans, als Referenzierung auf das Contribution-Bean verwendet werden
 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:Contribution-Reference"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
XML-Schema für 
\begin_inset Quotes eld
\end_inset

contribution-ref
\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset

mapped-contribution-ref
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions:-XML-Schema_contr-ref"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<xsd:element name="contribution-ref" type="ContributionType"/>
\end_layout

\begin_layout Plain Layout

<xsd:element name="mapped-contribution-ref" type="ContributionType"/>
\end_layout

\begin_layout Plain Layout

<xsd:complexType name="ContributionType">
\end_layout

\begin_layout Plain Layout

	<xsd:attribute name="name" type="xsd:string">
\end_layout

\begin_layout Plain Layout

		<xsd:annotation>
\end_layout

\begin_layout Plain Layout

			<xsd:documentation><![CDATA[The name of the contribution, beans were
 added to.]]></xsd:documentation>
\end_layout

\begin_layout Plain Layout

		</xsd:annotation>
\end_layout

\begin_layout Plain Layout

	</xsd:attribute>
\end_layout

\begin_layout Plain Layout

</xsd:complexType>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Die zu den beiden XML-Elementen gehörende XML-Schemadefinition wird in Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions:-XML-Schema_contr-ref"

\end_inset

 gezeigt.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:Contribution-Reference"

\end_inset

(XML) Contribution Referenzen bei Konstruktor- und Setter-Injection
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout

	<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w
3.org/2001/XMLSchema-instance"	xmlns:ctr="http://www.springframework.org/schema/con
tributions" xsi:schemaLocation="http://www.springframework.org/schema/beans	
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springfr
amework.org/schema/contributions http://www.springframework.org/schema/contribution
s/spring-contributions-3.0.xsd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<!-- Referenzierung einer Contribution-Liste und einer "Mapped-Configuration"
 in einem Bean mit Konstruktor-Injektion -->
\end_layout

\begin_layout Plain Layout

		<bean id="constructorClassName" class="MyConstructorInitializedService">
\end_layout

\begin_layout Plain Layout

			<constructor-arg>
\end_layout

\begin_layout Plain Layout

				<ctr:contribution-ref name="contributionName" />
\end_layout

\begin_layout Plain Layout

				<ctr:mapped-contribution-ref name="mappedContributionName" />
\end_layout

\begin_layout Plain Layout

			</constructor-arg>
\end_layout

\begin_layout Plain Layout

			<!-- weitere Metadaten zum jeweiligen Bean -->
\end_layout

\begin_layout Plain Layout

		</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<!-- Referenzierung einer Contribution-Liste und einer Contribution-Map
 in einem Bean mit Setter-Injektion -->
\end_layout

\begin_layout Plain Layout

		<bean id="setterClassName" class="MySetterInitializedService" >
\end_layout

\begin_layout Plain Layout

			<property name="listDependency" >
\end_layout

\begin_layout Plain Layout

				<value>
\end_layout

\begin_layout Plain Layout

					<ctr:contribution-ref name="contributionName" />
\end_layout

\begin_layout Plain Layout

				</value>
\end_layout

\begin_layout Plain Layout

			</property>
\end_layout

\begin_layout Plain Layout

			<property name="mappedDependency" >
\end_layout

\begin_layout Plain Layout

				<value>
\end_layout

\begin_layout Plain Layout

					<ctr:mapped-contribution-ref name="mappedContributionName" />
\end_layout

\begin_layout Plain Layout

				</value>
\end_layout

\begin_layout Plain Layout

			</property>
\end_layout

\begin_layout Plain Layout

		</bean>
\end_layout

\begin_layout Plain Layout

	</beans>
\end_layout

\begin_layout Plain Layout

</xml>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
(Java) Contributions Referenzieren
\begin_inset CommandInset label
LatexCommand label
name "sub:(Java)-Contributions-Referenzier_Resolver-Services"

\end_inset


\end_layout

\begin_layout Standard
Für die 
\noun on
SpringContributions
\noun default
 wurden zwei 
\begin_inset Quotes eld
\end_inset

Resolver Services
\begin_inset Quotes erd
\end_inset

 (
\family sans
\shape italic
OrderedContributionResolver
\family default
\shape default
 und 
\family sans
\shape italic
MappedContributionResolver
\family default
\shape default
) implementiert, mit deren Hilfe es leicht möglich ist, ein Contribution-Objekt,
 nur durch die Angabe des Contribution-Namen, zu erhalten.
 Die Notwendigkeit für diese beiden Services resultiert daraus, dass die
 Java-Konfiguation der 
\noun on
SpringContributions
\noun default
 in ihrer aktuellen Umsetzung (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Java-Konfig-Variante2"

\end_inset

) erst nach der Standard-Beankonfiguration durchgeführt wird.
 Zur Abarbeitungszeit der Standard-Beankonfiguration stehen aber noch keine
 Contribution-Objekte bereit und die Abhängigkeiten von Beans auf Contribution-O
bjeke können vom IOC-Container noch nicht aufgelöst werden.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
(
\noun default
Java) Referenzierung von Contribution-Containern
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-Java:-Referenzierung"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

@EnableContributions
\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	// Referenzierung einer Contribution-Liste und einer Contribution-Map in
 einem Bean mit Konstruktor
\end_layout

\begin_layout Plain Layout

	@Bean()
\end_layout

\begin_layout Plain Layout

	public static MyConstructorInitializedService constructorClassName(
\end_layout

\begin_layout Plain Layout

		OrderedContributionResolver<MyListElement> list,
\end_layout

\begin_layout Plain Layout

		MappedContributionResolver<MyMapElement> map)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyKonstructorServiceImpl(list.resolve("contributionName"), map.resolv
e("mappedContributionName");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Referenzierung einer Contribution-Liste und einer Contribution-Map in
 einem Bean mit Setter
\end_layout

\begin_layout Plain Layout

	@Bean()
\end_layout

\begin_layout Plain Layout

	public static MySetterInitializedService setterClassName(
\end_layout

\begin_layout Plain Layout

		OrderedContributionResolver<MyListElement> list,
\end_layout

\begin_layout Plain Layout

		MappedContributionResolver<MyMapElement> map)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		MySetterInitializedService service = new MySetterServiceImpl();
\end_layout

\begin_layout Plain Layout

		service.setList(list.resolve("contributionName"));
\end_layout

\begin_layout Plain Layout

		service.setMap(map.resolve("mappedContributionName"));
\end_layout

\begin_layout Plain Layout

		return service;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Würde man also in einer Beankonfiguration direkt auf ein Contribution-Objekt
 zugreifen wollen, so müsste das zu einem Fehler führen.
 Durch die Indirektion über die beiden Resolver Services kann dieses Problem
 umgangen werden.
 In der XML-Konfiguration werden die beiden Services nicht benötigt, da
 diese gleichzeitig mit der normalen Spring XML-Konfiguration verarbeitet
 werden und somit Contribution-Objekte wie Beans in der selben Phase, so
 zu sagen 
\begin_inset Quotes eld
\end_inset

gleichzeitig
\begin_inset Quotes erd
\end_inset

, erstellt werden.
\end_layout

\begin_layout Standard
Die Resolver Services bieten, wegen der Typisierbarkeit ihrer Rückgabe,
 auch noch den Vorteil, dass im Vergleich zu einem Beanobjekt das man direkt
 aus dem Spring Applicationcontext bezieht, keine Typspezifizierung mittels
 
\begin_inset Quotes eld
\end_inset

Typecast
\begin_inset Quotes erd
\end_inset

 Befehl mehr auf das gelieferte Objekt angewendet werden muss.
\end_layout

\begin_layout Standard
Zusätzlich kommt den Resolver Services noch die Aufgabe der Fehlerbehandlung
 zu.
 Für den Fall, dass ein Contribution-Objekt tatsächlich nicht vorhanden
 ist, wird durch sie eine Warnung ausgegeben.
 Anstatt des Contribution-Objekts wird dann eine leere Liste oder Map zurückgege
ben.
 Wie die Referenzierung von Contribution-Containern über die beiden Resolver
 Services in einer Java-Konfiguration durchgeführt wird zeigt Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-Java:-Referenzierung"

\end_inset

.
\end_layout

\begin_layout Standard
Da der Beanname jedes Contribution-Containers, bei der Erstellung seiner
 Beandefinition, ein Namenspräfix erhält (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Contribution-Bean-Identifikation"

\end_inset

), muss dieser natürlich auch dem eigentlichen Namen aus der Konfiguration
 vorangestellt werden, möchte man das Bean über den Namen aus dem IOC-Container
 laden.
 Diese Aufgabe wird einem ebenfalls durch die beiden Resolver Services abgenomme
n.
 Die Verwendung des Namenspräfix ist somit für den Benutzer sowohl in der
 Vergabe als auch in der Verwendung transparent.
\end_layout

\begin_layout Subsection
(XML) Hinzufügen von Beans zu einer Contribution-Liste
\begin_inset CommandInset label
LatexCommand label
name "sub:Die-Contribution-Liste-in-XML"

\end_inset


\end_layout

\begin_layout Standard
Da uns in XML sowohl Elemente als auch Attribute zur Verfügung stehen, haben
 wir aus Flexibilitätsgründen die Möglichkeit zum Hinzufügen von Beans zu
 einer Contribution-Liste auf drei Arten realisiert.
\end_layout

\begin_layout Standard
Will man also ein Bean zu einer Contribution-Liste hinzuzufügen, so kann
 man sich der drei folgenden Varianten bedienen: 
\end_layout

\begin_layout Subparagraph
XML-Attribut 
\begin_inset Quotes eld
\end_inset

contributeTo
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
Mit diesem Attribut legt man in der Konfiguration fest, dass das eben definierte
 Bean ein Element der Contribution-Liste, mit dem im XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
contributeTo
\family default

\begin_inset Quotes erd
\end_inset

 definierten Namen, werden soll (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contributeTo"

\end_inset

).
 Die zugehörige XML-Schemadefinition wird in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions:-XML-Schema_contributeTo"

\end_inset

 gezeigt.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:contributeTo"

\end_inset


\noun on
(XML) 
\noun default
Einfache Elementdefinition zur Listenkonfiguration über das XML-Attribut
 
\begin_inset Quotes eld
\end_inset

contributeTo
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- Auszug aus einer XML-Konfiguration -->
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<bean id="className" class="classToBeContributed"
\end_layout

\begin_layout Plain Layout

	contributeTo="contributionName">
\end_layout

\begin_layout Plain Layout

	<!-- weitere Metadaten -->
\end_layout

\begin_layout Plain Layout

</bean>
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
XML-Schema für das XML-Attribut 
\begin_inset Quotes eld
\end_inset

contributeTo
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions:-XML-Schema_contributeTo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:attribute name="contributeTo" type="xsd:string"></xsd:attribute>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
XML-Element 
\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
Mit dem XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribute
\family default

\begin_inset Quotes erd
\end_inset

 erreicht man dasselbe Ergebnis wie mit dem XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
contributeTo
\family default

\begin_inset Quotes erd
\end_inset

 und kann also ein Bean zu einer Contribution-Liste hinzufügen (siehe Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contribute"

\end_inset

).
 Zusätzlich ist es bei dieser Methode aber möglich, das 
\begin_inset Quotes eld
\end_inset


\family sans
constraints
\family default

\begin_inset Quotes eld
\end_inset

 Attribut zu verwenden, um damit die Reihenfolge des Elements in der Contributio
n-Liste zu beeinflussen.
 Die zugehörige XML-Schemadefinition wird in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions:-XML-Schema_contribute"

\end_inset

 gezeigt.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:contribute"

\end_inset


\noun on
(XML) 
\noun default
Einfache Elementdefinition zur Listenkonfiguration über das XML-Element
 
\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- Auszug aus einer XML-Konfiguration -->
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<bean id="className" class="classToBeContributed">
\end_layout

\begin_layout Plain Layout

	<contribute to="contributionName" constraints="after:*"/>
\end_layout

\begin_layout Plain Layout

	<!-- weitere Metadaten -->
\end_layout

\begin_layout Plain Layout

</bean>
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
XML-Schema für das XML-Element 
\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions:-XML-Schema_contribute"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="contribute">
\end_layout

\begin_layout Plain Layout

	<xsd:complexType>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="to" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation><![CDATA[The name of the contribution this bean is
 added to.]]></xsd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="constraints" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation><![CDATA[The sort constraints for this contribution.]]></x
sd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

	</xsd:complexType>
\end_layout

\begin_layout Plain Layout

</xsd:element>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
XML-Element 
\begin_inset Quotes eld
\end_inset

contribution
\begin_inset Quotes erd
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "par:XML-Element-contribution:"

\end_inset


\end_layout

\begin_layout Standard
Über das XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribution
\family default

\begin_inset Quotes erd
\end_inset

 kann man gleich mehrere Beans zu einer Contribution-Liste hinzufügen.
 Die Angabe des Namens des Contribution-Objekts, zu dem die Elemente hinzugefügt
 werden sollen, wird auch hier über das Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
to
\family default

\begin_inset Quotes erd
\end_inset

 bewerkstelligt.
 Im Gegensatz zum Tapestry Contribution-Mechanismus unterscheiden die 
\noun on
SpringContributions 
\noun default
nicht zwischen der sortierten und der unsortierten Listenübergabeform.
 Jede Konfiguration einer Contribution-Liste kann über das XML-Attribut
 
\begin_inset Quotes eld
\end_inset


\family sans
constraints
\family default

\begin_inset Quotes erd
\end_inset

 optional mit Sortierungsinformationen versehen werden.
 Lässt man die Sortierungsinformationen weg, so bestimmt die Reihenfolge
 des Vorkommens im Konfigurationstext die Ordnung der Elemente in der Liste.
 Die Syntax für die Sortierung wird, wie innerhalb einer Tapestry-Konfiguration,
 über die Schlüsselwörter 
\begin_inset Quotes eld
\end_inset


\family sans
before
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
after
\family default

\begin_inset Quotes erd
\end_inset

 in Verbindung mit einem konkreten Elementnamen, der Stern Wildcard 
\begin_inset Quotes eld
\end_inset


\family sans
*
\family default

\begin_inset Quotes erd
\end_inset

 oder einem regulären Ausdruck festgelegt.
\end_layout

\begin_layout Standard
Das XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
ref
\family default

\begin_inset Quotes erd
\end_inset

 wird wie auch sonst in der Spring-Konfiguration als Verweis auf ein, an
 einer anderen Stelle definiertes, Bean verwendet.
 Das bedeutet, dass zu jedem über das XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
Entry
\family default

\begin_inset Quotes erd
\end_inset

 definierte Element der Contribution-Liste, eine referenzierbare Beandefinition
 innerhalb der Konfigurationsfiles vorliegen muss (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contribution-Element"

\end_inset

).
 Die Beandefinition muss aber im Konfigurationsfile nicht wie im Beispiel
 direkt vor seiner Referenzierung platziert werden.
 Die zugehörige XML-Schemadefinition wird in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions:-XML-Schema_contribution"

\end_inset

 gezeigt.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:contribution-Element"

\end_inset

(XML) 
\noun default
Mehrfache Elementdefinition für normale und sortierte Listenkonfiguration
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- Auszug aus einer XML-Konfiguration -->
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<bean name="myContributedService" class="MyContributedService" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<ctr:contribution to="contributionName">
\end_layout

\begin_layout Plain Layout

	<ctr:entry name="myContributedService" ref="myContributedService" constraints="
after:*" />
\end_layout

\begin_layout Plain Layout

	<!-- weitere Elemente -->
\end_layout

\begin_layout Plain Layout

</ctr:contribution>
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
XML-Schema für das XML-Element 
\begin_inset Quotes eld
\end_inset

contribution
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions:-XML-Schema_contribution"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<xsd:element name="contribution">
\end_layout

\begin_layout Plain Layout

	<xsd:annotation>
\end_layout

\begin_layout Plain Layout

		<xsd:documentation source="java:org.springframework.beans.factory.config.ListFactor
yBean">
\end_layout

\begin_layout Plain Layout

			Builds a List instance, populated with the specified content.
\end_layout

\begin_layout Plain Layout

		</xsd:documentation>
\end_layout

\begin_layout Plain Layout

		<xsd:appinfo>
\end_layout

\begin_layout Plain Layout

			<tool:annotation>
\end_layout

\begin_layout Plain Layout

				<tool:exports type="java.util.List"/>
\end_layout

\begin_layout Plain Layout

			</tool:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:appinfo>
\end_layout

\begin_layout Plain Layout

	</xsd:annotation>
\end_layout

\begin_layout Plain Layout

	<xsd:complexType>
\end_layout

\begin_layout Plain Layout

		<xsd:group ref="contributionElements"/>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="to" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation><![CDATA[The name of the contribution this bean is
 added to.]]></xsd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

	</xsd:complexType>
\end_layout

\begin_layout Plain Layout

</xsd:element>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:group name="contributionElements">
\end_layout

\begin_layout Plain Layout

	<xsd:sequence>
\end_layout

\begin_layout Plain Layout

		<xsd:element ref="beans:description" minOccurs="0"/>
\end_layout

\begin_layout Plain Layout

		<xsd:element name="entry" minOccurs="1" maxOccurs="unbounded">
\end_layout

\begin_layout Plain Layout

			<xsd:complexType>
\end_layout

\begin_layout Plain Layout

				<xsd:complexContent>
\end_layout

\begin_layout Plain Layout

					<xsd:extension base="beans:propertyType">
\end_layout

\begin_layout Plain Layout

						<xsd:attribute name="constraints" type="xsd:string">
\end_layout

\begin_layout Plain Layout

							<xsd:annotation>
\end_layout

\begin_layout Plain Layout

								<xsd:documentation>
\end_layout

\begin_layout Plain Layout

									<![CDATA[The sort constraints for this contribution.]]>
\end_layout

\begin_layout Plain Layout

								</xsd:documentation>
\end_layout

\begin_layout Plain Layout

							</xsd:annotation>
\end_layout

\begin_layout Plain Layout

						</xsd:attribute>
\end_layout

\begin_layout Plain Layout

					</xsd:extension>
\end_layout

\begin_layout Plain Layout

				</xsd:complexContent>
\end_layout

\begin_layout Plain Layout

			</xsd:complexType>
\end_layout

\begin_layout Plain Layout

		</xsd:element>
\end_layout

\begin_layout Plain Layout

	</xsd:sequence>
\end_layout

\begin_layout Plain Layout

</xsd:group>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
(Java) Hinzufügen von Beans zu einer Contribution-Liste
\end_layout

\begin_layout Paragraph*
Die Contribution-Liste in Java:
\end_layout

\begin_layout Standard
In der Java-Konfiguration gibt es nicht, wie in der XML-Konfiguration, drei
 Schreibweisen (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Die-Contribution-Liste-in-XML"

\end_inset

), sondern nur noch eine Möglichkeit, ein Bean zu einer Contribution-Liste
 hinzuzufügen.
 Dafür wird die Annotation 
\family sans
@Contribution
\family default
 mit dem Parameter 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
to
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 verwendet (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-Java:_Listenübergabe"

\end_inset

).
 Ob das Element eine festgelegte Position in der Contribution-Liste erhalten
 soll oder nicht, wird über das Hinzufügen oder Weglassen des Parameters
 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
constraints
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 gesteuert.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
(
\noun default
Java) Einfache und sortierte Listenübergabe
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-Java:_Listenübergabe"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

@EnableContributions
\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Ein Bean das der Contribution-Liste "elements" als Element hinzugefügt
 wird;
\end_layout

\begin_layout Plain Layout

	// ohne Information zu Positionierung in der Liste
\end_layout

\begin_layout Plain Layout

	@Contribution(to="elements")
\end_layout

\begin_layout Plain Layout

	@Bean(name="MyServiceDependencyElementImplOne")
\end_layout

\begin_layout Plain Layout

	public MyServiceDependencyElement one()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyServiceDependencyElementImplOne();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Ein weiteres Bean das der Contribution-Liste "elements" als Element
 hinzugefügt wird;
\end_layout

\begin_layout Plain Layout

	// mit Information zur Positionierung in der Liste
\end_layout

\begin_layout Plain Layout

	@Contribution(to="elements", constraints="after:*")
\end_layout

\begin_layout Plain Layout

	@Bean(name="MyServiceDependencyElementImplTwo")
\end_layout

\begin_layout Plain Layout

	public MyServiceDependencyElement two()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyServiceDependencyElementImplTwo();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
(XML) Hinzufügen von Beans zu einer Contribution-Map
\end_layout

\begin_layout Subparagraph
XML-Element 
\begin_inset Quotes eld
\end_inset

mapped-contribution
\begin_inset Quotes erd
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "par:XML-Element-mapped-contribution:"

\end_inset


\end_layout

\begin_layout Standard
Möchte man mehrere Elemente zu einer Contribution-Map (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Mapped-Configuration"

\end_inset

) hinzufügen, so muss man sich des XML-Elements 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution
\family default

\begin_inset Quotes erd
\end_inset

 bedienen.
 Der innere, komplexe Datentyp dieses Elements entspricht dem einer 
\family sans
\shape italic
java.util.Map
\family default
\shape default
, und benötigt daher für jedes Element auch die Angabe von Schlüssel und
 zugeordnetem Wert über die Attribute 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
key
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
value
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 bzw.
 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
key-ref
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
value-ref
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:mapped-contribution-Element"

\end_inset

).
 In den beiden Attributen 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
key
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
value
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 können direkt Schlüssel und Wert angegeben werden.
 Über die Attribute 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
key-ref
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
value-ref
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 können Beandefinitionen, die an einer anderen Stelle der Konfiguration
 definiert werden, über deren Namen referenziert und somit als Schlüssel
 und Wert angegeben werden.
 Die zugehörige XML-Schemadefinition wird in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions:-XML-Schema_mapped-contribution"

\end_inset

 gezeigt.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
XML-Schema für das XML-Element 
\begin_inset Quotes eld
\end_inset

mapped-contribution
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions:-XML-Schema_mapped-contribution"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="mapped-contribution">
\end_layout

\begin_layout Plain Layout

	<xsd:annotation>
\end_layout

\begin_layout Plain Layout

		<xsd:documentation source="java:org.springframework.beans.factory.config.MapFactory
Bean">
\end_layout

\begin_layout Plain Layout

			Builds a Map instance of the specified type, populated with the specified
 content.
\end_layout

\begin_layout Plain Layout

		</xsd:documentation>
\end_layout

\begin_layout Plain Layout

		<xsd:appinfo>
\end_layout

\begin_layout Plain Layout

			<tool:annotation>
\end_layout

\begin_layout Plain Layout

				<tool:exports type="java.util.Map"/>
\end_layout

\begin_layout Plain Layout

			</tool:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:appinfo>
\end_layout

\begin_layout Plain Layout

	</xsd:annotation>
\end_layout

\begin_layout Plain Layout

	<xsd:complexType>
\end_layout

\begin_layout Plain Layout

		<xsd:complexContent>
\end_layout

\begin_layout Plain Layout

			<xsd:extension base="beans:mapType">
\end_layout

\begin_layout Plain Layout

				<xsd:attribute name="to" type="xsd:string">
\end_layout

\begin_layout Plain Layout

					<xsd:annotation>
\end_layout

\begin_layout Plain Layout

						<xsd:documentation><![CDATA[The name of the contribution this bean
 is added to.]]></xsd:documentation>
\end_layout

\begin_layout Plain Layout

					</xsd:annotation>
\end_layout

\begin_layout Plain Layout

				</xsd:attribute>
\end_layout

\begin_layout Plain Layout

			</xsd:extension>
\end_layout

\begin_layout Plain Layout

		</xsd:complexContent>
\end_layout

\begin_layout Plain Layout

	</xsd:complexType>
\end_layout

\begin_layout Plain Layout

</xsd:element>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:mapped-contribution-Element"

\end_inset

(XML) 
\noun default
Mehrfache Elementdefinition für eine Contribution-Map
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<!-- Auszug aus einer XML-Konfiguration -->
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<bean name="myContributedService" class="MyContributedService" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<ctr:mapped-contribution to="contributionName">
\end_layout

\begin_layout Plain Layout

	<ctr:entry key="myServiceKey" value-ref="myContributedService" />
\end_layout

\begin_layout Plain Layout

	<!-- weitere Elemente -->
\end_layout

\begin_layout Plain Layout

</ctr:mapped-contribution>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
(Java) Hinzufügen von Beans zu einer Contribution-Map
\end_layout

\begin_layout Standard
Das Hinzufügen von Beans zu einer Contribution-Map geschieht in der Java-Variant
e der Konfiguration über die 
\family sans
@ContributionMapped
\family default
 Annotation und deren Parameter 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
to
\family default
\shape default

\begin_inset Quotes erd
\end_inset

.
 Mit diesem obligatorischen Parameter wird der Name der Contribution-Map
 festgelegt, zu der das Bean hinzugefügt werden soll.
 Auf welches Bean sich die Annotation bezieht, wird über den Parameter 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
name
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 festgelegt.
 Dieser Parameter muss nicht unbedingt angegeben werden, da dann einfach
 der Name der Konfigurationmethode als Name herangezogen wird.
 Beim Abarbeiten der Konfiguration wird über diesen Namen die zugehörige
 Beandefinition aus dem IOC-Container geladen und kann dann der Contribution-Map
 hinzugefügt werden.
 Die Konfiguration funktioniert natürlich nur, wenn auch eine Beandefinition
 mit diesem Namen existiert.
 Aus diesem Grund wird also entweder der 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
name
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 Parameter oder der Bezeichner der zur Annotation gehörenden Konfigurationsmetho
de, mit dem Parameter 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
name
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 der zugehörigen
\family sans
 @Bean
\family default
 Annotation übereinstimmen müssen.
\end_layout

\begin_layout Standard
Da jedes Bean in einer Contribution-Map auch einen Schlüsselwert benötigt,
 gibt es nun auch dafür Parameter.
 Möchte man einfach einen 
\family sans
\shape italic
String
\family default
\shape default
 als Schlüssel verwenden, dann verwendet man den Parameter 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
key
\family default
\shape default

\begin_inset Quotes erd
\end_inset

.
 Möchte man aber eine Klasse als Schlüsselwert verwenden, so muss man den
 Parameter 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
keyClass
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 dementsprechend setzen.
 Die bisher beschriebenen Parameter sind in der Beispielkonfiguration in
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-Java:mapped-contribution-Element"

\end_inset

 zu sehen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-Java:mapped-contribution-Element"

\end_inset

(
\noun default
Java
\noun on
) 
\noun default
Beandefinition und Übergabe an eine Contribution-Map
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

@EnableContributions
\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@ContributionMapped(name="myService1",
\end_layout

\begin_layout Plain Layout

		to="stringKeyContributionMap", key="myServiceKey")
\end_layout

\begin_layout Plain Layout

	@Bean(name="myService1")
\end_layout

\begin_layout Plain Layout

	public MyContributedService myService1()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyContributedServiceImpl();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@ContributionMapped(to="classKeyContributionMap", keyClass="Interger.class")
\end_layout

\begin_layout Plain Layout

	@Bean(name="myService2")
\end_layout

\begin_layout Plain Layout

	public MyContributedService myService2()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyContributedServiceImpl();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Will man eine Bean zu einer Contribution-Map hinzufügen und dabei als Schlüssele
lement eine Enumeration verwenden, so kann dies über die Verwendung der
 optionalen Attribute 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
keyEnumClass
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
keyEnumValue
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 erreicht werden.
 Dabei erwartet der Parameter 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
keyEnumClass
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 eine Java-Klasse vom Typ Enumeration und der Parameter 
\begin_inset Quotes erd
\end_inset


\family sans
\shape italic
keyEnumValue
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 den Namen eines Wertes aus der angegebenen Enumeration-Klasse als 
\family sans
\shape italic
String
\family default
\shape default
.
 Natürlich müssen diese beiden Parameter immer in Kombination auftreten.
 Wird nur einer der beiden Parameter angegeben, so kommt es beim Starten
 des Spring Applicationkontext zu einem Fehler.
 Eine Beispielkonfiguration zu einem Contribution-Map Element mit einer
 Enumeration als Schlüssel ist in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(Java)-Contribution-Map:-Enumeration Key Definition"

\end_inset

 angegeben.
\end_layout

\begin_layout Standard
Die Verwendung von zwei Attributen ist hier deshalb notwendig, da es nicht
 möglich ist direkt einen Enumeration-Wert in einer Annotation zu referenzieren.
 Diese Art der Umsetzung ergibt sich aus der Entscheidung für die Verwendung
 von Annotationen zur Angabe der Konfigurations-Metadaten.
 Auf diese Weise entfällt zwar der mögliche Vorteil einer Syntaxprüfung
 durch den Compiler, den man bei der Verwendung von Java-Klassen als Konfigurati
on nutzen könnte, doch man erhält, bezüglich der Verwendung von Enumerationen,
 auf jeden Fall die gewünschte Gleichheit zum Funktionsumfang der XML-Konfigurat
ion.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:(Java)-Contribution-Map:-Enumeration Key Definition"

\end_inset

(Java) Contribution-Map: Enumeration Schlüssel Definition
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Hinzufügen eines Schlüssel/Wert-Paares zu einer Contribution-Map mit einer
 Enumeration als Schlüssel
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ContributionMapped(to="myMappedContribution", keyEnumClass=KeyEnum.class,
 keyEnumValue="keyOne")
\end_layout

\begin_layout Plain Layout

@Bean(name="enumOneKeyObject")
\end_layout

\begin_layout Plain Layout

public Object enumOneKeyObject()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return new Object();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Die verwendete Enumeration-Klasse mit ihren Werten
\end_layout

\begin_layout Plain Layout

public enum KeyEnum
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	keyOne,
\end_layout

\begin_layout Plain Layout

	keyTwo;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Realisierung
\end_layout

\begin_layout Standard
In den letzten Abschnitten wurden die Anwendungsmöglichkeiten der 
\noun on
SpringContributions
\noun default
 gezeigt.
 In diesem Abschnitt soll nun in drei Teilen ein Einblick in die Implementierung
 des Moduls gegeben werden.
\end_layout

\begin_layout Standard
Zuerst wird gezeigt, wie der traditionell über XML gesteuerte Spring Konfigurati
onsmechanismus erweitert wird, damit die neuen Schlüsselwörter wie z.B.
 
\begin_inset Quotes eld
\end_inset


\family sans
contribution
\family default

\begin_inset Quotes eld
\end_inset

 erkannt und in Beandefinitionen umgewandelt werden können.
\end_layout

\begin_layout Standard
Die 
\noun on
SpringContributions 
\noun default
unterstützen auch die in 
\shape italic
Spring
\shape default
 neu vorhandene Möglichkeit der Java-Konfiguration.
 Ein weiterer Unterabschnitt zeigt ebenfalls die dafür nötigen Erweiterungen
 im Detail.
\end_layout

\begin_layout Standard
Abschließend wird die, für beide Konfigurationsarten gleiche, Erstellung
 der Beandefinitionen genauer beschrieben und ein Überblick über das Zusammenspi
el von 
\shape italic
Spring
\shape default
 und der neu entstandene 
\noun on
SpringContributions
\noun default
 Konfiguration gegeben.
\end_layout

\begin_layout Subsection
(XML) Erweiterung der Spring-Konfiguration
\end_layout

\begin_layout Standard

\shape italic
Spring
\shape default
 bietet grundsätzlich eine Möglichkeit zur Erweiterung seines XML-Konfigurations\SpecialChar \-

mechanismus.
 Konkret werden von dem Framework die abstrakte Klasse 
\family sans
\shape italic
NamespaceHandlerSupport 
\family default
\shape default
und die Interfaces 
\family sans
\shape italic
NamespaceHandler, BeanDefinitionParser 
\family default
\shape default
und
\family sans
\shape italic
 BeanDefinitionDecorator
\family default
\shape default
 bereit gestellt.
 Die Implementierung des Interfaces 
\family sans
\shape italic
NamespaceHandler,
\family default
\shape default
 als Erweiterung der Klasse 
\family sans
\shape italic
NamespaceHandlerSupport,
\family default
\shape default
 ermöglicht es, einen eigenen XML-Namensraum für die Spring-Konfiguration
 festzulegen.
 Die Umsetzung für die 
\noun on
SpringContributions
\noun default
 geschieht in der Klasse 
\family sans
\shape italic
ContributionsNamespaceHandler
\family default
\shape default
 zusammen mit dem Namensraum http://www.springframework.org/schema/contributions.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:XML-Schema:-spring-contributions"

\end_inset

XML-Schema Auszug aus 
\family sans
\shape italic
spring-contributions-3.0.xsd
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<xsd:attribute name="contributeTo" type="xsd:string"></xsd:attribute>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="contribute">
\end_layout

\begin_layout Plain Layout

	<xsd:complexType>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="to" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation>
\end_layout

\begin_layout Plain Layout

					<![CDATA[The name of the contribution this bean is added to.]]>
\end_layout

\begin_layout Plain Layout

				</xsd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="constraints" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation>
\end_layout

\begin_layout Plain Layout

					<![CDATA[The sort constraints for this contribution.]]>
\end_layout

\begin_layout Plain Layout

				</xsd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

	</xsd:complexType> 	
\end_layout

\begin_layout Plain Layout

</xsd:element>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Das dazugehörige XML-Schema 
\family sans
\shape italic
spring-contributions-3.0.xsd
\family default
\shape default
 - ein Auszug ist in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:XML-Schema:-spring-contributions"

\end_inset

 zu sehen - beschreibt alle benötigten Elemente und Attribute und legt damit
 die Syntax der 
\noun on
SpringContributions
\noun default
 Konfiguration fest.
 
\shape italic
Spring
\shape default
 erhält die Information über den neuen Namensraum über zwei Konfigurationsfiles
 im META-INF Verzeichnis des 
\noun on
SpringContributions
\noun default
 Moduls.
 In dem einen 
\begin_inset Quotes eld
\end_inset


\family sans
spring.schemas
\family default

\begin_inset Quotes erd
\end_inset

 wird das neue XML-Schema www.springframework.org/schema/contributions/spring-cont
ributions-3.0.xsd, in dem anderen 
\begin_inset Quotes eld
\end_inset


\family sans
spring.handlers
\family default

\begin_inset Quotes erd
\end_inset

 die dazugehörige Klasse 
\family sans
\shape italic
ContributionsNamespaceHandler
\family default
\shape default
 eingetragen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
(XML) UML zur Erweiterung der Spring-Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "fig:NamespaceExtentionUML"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/ExtendingSpringKonfiguration2.eps
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Damit der 
\family sans
\shape italic
NamespaceHandler
\family default
\shape default
 mit neu definierten, für 
\shape italic
Spring
\shape default
 bisher unbekannten XML-Elementen umgehen und aus ihnen Beandefinitionen
 erstellen kann, nimmt die Klasse 
\family sans
\shape italic
NamespaceHandlerSupport
\family default
\shape default
 Implementierungen des Interfaces 
\family sans
\shape italic
BeanDefinitionParser
\family default
\shape default
 entgegen.
 Für die beiden Contibution-Basistypen, der Contibution-Liste und der Contibutio
n-Map, werden hier zwei separate Parser, der 
\family sans
\shape italic
OrderedContributionBeanDefinitionParser
\family default
\shape default
 und der
\family sans
\shape italic
 MappedContributionBeanDefinitionParser,
\family default
\shape default
 verwendet.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:NamespaceExtentionUML"

\end_inset

 gibt einen Überblick zu den erwähnten Klassen.
\end_layout

\begin_layout Subsection
(Java) Erweiterung der Spring-Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:(Java)-Erweiterung-der-Konfiguration"

\end_inset


\end_layout

\begin_layout Standard
Wie in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-Erweiterung-mittels_Java-Config"

\end_inset

 beschrieben, ist die Java-Konfiguration der 
\noun on
SpringContributions
\noun default
 über die Implementierung des Interfaces 
\family sans
\shape italic
BeanDefinitionRegistryPostProcessor
\family default
\shape default
 umgesetzt worden.
\end_layout

\begin_layout Standard
Dieser Postprozessor registriert, nach dem 
\shape italic
Spring
\shape default
 eigenen Initialisieren der Beans, alle in Konfigurationsklassen definierten
 Contributions.
 Damit der Postprozessor beim Erstellen des IOC-Containers vom Framework
 automatisch verwendet wird, muss dieser selbst als Service-Bean definiert
 werden.
 Dies geschieht in der 
\noun on
SpringContributions
\noun default
 Basiskonfigurationsklasse (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-Java:EnableContributions-Annotation"

\end_inset

) für die Java-Konfiguration 
\family sans
\shape italic
AnnotationContributionConfig
\family default
\shape default
.
 In dieser Konfigurationsklasse werden auch die beiden übrigen, notwendigen
 Services 
\family sans
\shape italic
OrderedContributionResolver
\family default
\shape default
 und 
\family sans
\shape italic
MappedContributionResolver
\family default
\shape default
 als Beans definiert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
(JAVA) UML zur Erweiterung der Spring-Konfiguration 
\begin_inset CommandInset label
LatexCommand label
name "fig:ExtendingSpringKonfiguration_JAVA"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/ExtendingSpringKonfiguration_JAVA_2.eps
	scale 37

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Möchte man nun die 
\noun on
SpringContributions
\noun default
 Funktionalität in einer Konfigurationsklasse verwenden, so würde es nun
 genügen, die Basiskonfigurationsklasse, z.B.
 über die Annotation 
\family sans
@Import,
\family default
 in einer eigenen Konfigurationsklasse mit einzubinden.
 Um einen eleganteren und 
\shape italic
Spring
\shape default
 üblichen Weg zur Aktivierung der 
\noun on
SpringContributions
\noun default
 anzubieten, bietet das Modul zusätzlich die Annotation 
\family sans
@EnableContributions
\family default
.
 Eine detaillierte Beschreibung hierzu folgt im nächsten Unterabschnitt
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Zur-Verfügung-stellen-von-Java-Contribution"

\end_inset

.
 Einen Überblick zu den eben erwähnten Klassen gibt Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ExtendingSpringKonfiguration_JAVA"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Aktivierung der 
\noun on
SpringContributions
\noun default
 in Java Konfigurationsklassen
\begin_inset CommandInset label
LatexCommand label
name "sub:Zur-Verfügung-stellen-von-Java-Contribution"

\end_inset


\end_layout

\begin_layout Standard
Will man die 
\noun on
SpringContributions
\noun default
 Funktionalität in Java Konfigurationsklassen verwenden, so müssen alle
 notwendigen Services natürlich selbst als Beans innerhalb des Spring Applicatio
ncontextes zur Verfügung stehen.
 Dafür sind alle nötigen Dienste, wie der 
\family sans
\shape italic
AnnotationContributionPostProcessor
\family default
\shape default
 und die beiden Resolver Services, in einer Basis\SpecialChar \-
konfigurationsklasse als
 Beans definiert.
 Zusätzlich wird ein eigener 
\family sans
\shape italic
ImportSelector
\family default
\shape default
 definieren.
 Diese Klasse lässt sich dann über die Annotation
\family sans
\series bold
 
\series default
@Import
\family default
 an die Annotation 
\family sans
@EnableContributions
\family default
 binden.
 Diese Annotation ist für das Aktivieren der Java-Konfiguration vorgesehen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-Java:EnableContributions-Annotation"

\end_inset

(
\noun default
Java
\noun on
) 
\noun default
Basis Konfigurationsklasse
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

//Spring Java-Configuration-Klasse AnnotationContributionConfig:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

public class AnnotationContributionConfig
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@Bean()
\end_layout

\begin_layout Plain Layout

	public static BeanFactoryPostProcessor buildContributionPostProcessor()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new AnnotationContributionPostProcessor();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Bean(name="orderedContributionResolver")
\end_layout

\begin_layout Plain Layout

	public OrderedContributionResolver<?> buildOrderedContributionResolver(Applicat
ionContext context)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return  new OrderedContributionResolver(context);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Bean(name="mappedContributionResolver")
\end_layout

\begin_layout Plain Layout

	public MappedContributionResolver<?, ?> buildMappedContributionResolver(Applica
tionContext context)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return  new MappedContributionResolver(context);
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Verwendet man nun diese Annotation auf Klassenebene in einer Java-Konfiguration,
 so stehen für diese Konfiguration nun alle Dienste der 
\noun on
SpringContributions
\noun default
 Java-Konfiguration zur Verfügung und können somit innerhalb der eigenen
 Konfigurationsklasse genutzt werden.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-Java:EnableContributions-Annotation"

\end_inset

 zeigt die Basiskonfigurationsklasse der 
\noun on
SpringContributions
\noun default
.
 In dieser sind alle, für die Java-Konfiguration notwendigen, Service-Beans
 definiert.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-Java:EnableContributions-Annotation-2"

\end_inset

(
\noun default
Java
\noun on
) 
\noun default
Implementierung der 
\family sans
\series bold
@EnableContributions
\family default
\series default
 Annotation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

//Java-Klasse ContributionContributionSelector:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * This {@link ImportSelector} implementation returns the configuration
 class {@link AnnotationContributionConfig}
\end_layout

\begin_layout Plain Layout

 * and can be used in annotations which should be used for enabling Spring-Contr
ibutions in configuration classes.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

public class ContributionContributionSelector implements ImportSelector
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public String[] selectImports(AnnotationMetadata importingClassMetadata)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new String[] { AnnotationContributionConfig.class.getName()};
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Java-Klasse EnableContributions:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import java.lang.annotation.Documented;
\end_layout

\begin_layout Plain Layout

import java.lang.annotation.ElementType;
\end_layout

\begin_layout Plain Layout

import java.lang.annotation.Retention;
\end_layout

\begin_layout Plain Layout

import java.lang.annotation.RetentionPolicy;
\end_layout

\begin_layout Plain Layout

import java.lang.annotation.Target;
\end_layout

\begin_layout Plain Layout

import org.springframework.context.annotation.Import;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * This annotation can be used to activate Spring-Contribution functionality
 in a Spring java configuration
\end_layout

\begin_layout Plain Layout

 * class annotated with the {@link Configuration} annotation.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

@Target(ElementType.TYPE)
\end_layout

\begin_layout Plain Layout

@Retention(RetentionPolicy.RUNTIME)
\end_layout

\begin_layout Plain Layout

@Documented
\end_layout

\begin_layout Plain Layout

@Import(ContributionContributionSelector.class)
\end_layout

\begin_layout Plain Layout

public @interface EnableContributions{}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-Java:EnableContributions-Annotation-2"

\end_inset

 ist zu sehen, wie diese Basiskonfiguration an die Annotation
\family sans
\series bold
 
\series default
@EnableContributions
\family default
 gebunden wird, so dass über diese Annotation die 
\noun on
SpringContributions
\noun default
 Funktionalität in der Spring Konfigurationsklasse aktiviert werden kann.
 Die Klassen aus Listings 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-Java:EnableContributions-Annotation"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-Java:EnableContributions-Annotation-2"

\end_inset

 und deren Zusammenhang sind zusätzlich in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ExtendingSpringKonfiguration_JAVA"

\end_inset

 als UML-Diagramm dargestellt.
\end_layout

\begin_layout Subsection
XML-Konfiguration VS Java-Konfiguration
\end_layout

\begin_layout Standard
Tabelle 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Gegenüberstellung-von-XML-und-Java"

\end_inset

 zeigt eine Gegenüberstellung der Konfigurationselemente von XML- und Java-Konfi
guration.
 Es ist hier zu sehen, dass für die Java-Variante weniger Elemente zur Verfügung
 stehen als in der XML-Variante.
 Dies resultiert aus der geringeren Komplexität der Java-Variante.
 In der Java-Variante gibt es zum Beispiel nicht die Möglichkeit, über eine
 Konfigurationsmethode eine ganze Liste von Beans als Elemente zu einer
 Contribution-Liste hinzuzufügen.
 Ebenso können nicht mehrere Schlüssel/Wert-Paare mit einer Konfigurationsmethod
e an eine Contribution-Map übergeben werden.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Gegenüberstellung-von-XML-und-Java"

\end_inset

Gegenüberstellung von XML- / Java-Konfigurationschlüsselwörtern
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
Hinzufügen von ...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
XML-Element / -Attribut
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
Java-Annotation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
...
 einzelnen Beans zu einer Liste
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
 
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
contributeTo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
contribute
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
contribution
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
@Contribution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
...
 mehreren Beans zu einer Liste
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
contribution
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
...
 einzelnen Beans zu einer Map
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
mapped-contribution
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
@Contribution-Mapped
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
...
 mehreren Beans zu einer Map
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
mapped-contribution
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
Referenzieren einer ...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
XML-Element / -Attribut
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\series bold
Java-Klasse
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
...
 Contribution-Liste
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
contribution-ref
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
OrderedContributionResolver
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
...
 Contribution-Map
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
mapped-contribution-ref
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
MappedContributionResolver
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Von der Konfiguration zum Spring-Bean
\end_layout

\begin_layout Standard
Will man nun von einer Contibution-Konfiguration zu einer fertigen Beandefinitio
n im IOC-Container gelangen, so sind zwei Schritte zu erledigen.
 Zum einen müssen die Contribution-Container, also die Beandefinitionen
 für Contribution-Liste oder Contribution-Map, erstellt werden.
 Zum anderen müssen die einzelnen Elemente der Container ebenso als Beandefiniti
on, der Konfiguration entsprechend, zu der Beandefinition des Containers
 hinzugefügt werden.
 In den Klassen, die sich um die Abarbeitung der Konfigurationsdaten kümmern,
 werden die jeweils nötigen Schritte durchgeführt.
 Dabei wird der erste Schritt, also das Erstellen eines Contribution-Containers
 für jede spezielle Contribution-Liste oder Contribution-Map, nur einmal
 benötigt.
 Ist die Beandefinition für eine Contribution-Liste oder Contribution-Map
 bereits erstellt, so können diese Definitionen jederzeit geladen und mit
 Element-Definitionen befüllt werden.
\end_layout

\begin_layout Subsubsection
(XML) Abarbeitung der Konfigurationsschlüsselwörter 
\begin_inset CommandInset label
LatexCommand label
name "sub:(XML)-Abarbeitung-der-Konfigurationsschlüsselwörter"

\end_inset


\end_layout

\begin_layout Standard
Je nach gewünschten Eigenschaften eines Schlüsselwortes in der Konfiguration
 und auch abhängig von seinen möglichen Positionen im XML-File, bietet 
\shape italic
Spring
\shape default
 unterschiedliche Interfaces und abstrakte Klassen an, mit deren Hilfe das
 Parsen und das Umwandeln der Schlüsselwörter in Beandefinitionen durchgeführt
 werden kann.
 Alle, für diesen Zweck entstehenden, Parser Implementierungen können dann
 in einem eigenen 
\family sans
\shape italic
NamespaceHandler
\family default
\shape default
 registriert und somit zur Behandlung der XML-Konfiguration an 
\shape italic
Spring
\shape default
 übergeben werden.
 Der Spring-Parser identifiziert dann über den Namensraum im XML-Konfigurationsf
ile den 
\family sans
\shape italic
NamespaceHandler
\family default
\shape default
 und erhält von diesem die registrierten Parser.
 Für die 
\noun on
SpringContributions
\noun default
 wurde der 
\family sans
\shape italic
NamespaceHandler
\family default
\shape default
 in der Klasse 
\family sans
\shape italic
ContributionsNamespaceHandler
\family default
\shape default
 implementiert.
 Einen schematischen Überblick zur Namens\SpecialChar \-
raumerweiterung gibt Abbildung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:NamespaceExtentionFlow"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spring-Namensraumerweiterung
\begin_inset CommandInset label
LatexCommand label
name "fig:NamespaceExtentionFlow"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/CreatingBeanDefinitionsFromConfigurations.eps
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Die Beschreibung zur Verarbeitung der Schlüsselwörter beginne ich mit den
 Wörtern, mit deren Hilfe Contribution-Container in einer XML-Konfiguration
 referenziert werden können.
 Die XML-Elemente 
\begin_inset Quotes eld
\end_inset


\family sans
contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 werden dafür angeboten.
 Sie können beispielsweise dazu dienen, einen Contribution-Container als
 Konstruktorargument einem konsumierenden Bean zu übergeben (siehe Absatz
 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:XML-Elemente-contribution-ref"

\end_inset

).
 Für die Abarbeitung der beiden XML-Elemente wurde jeweils eine Implementierung
 der abstrakten Klasse 
\family sans
\shape italic
AbstractSingleBeanDefinitionParser
\family default
\shape default
 realisiert.
 Diese abstrakte Klasse wird von 
\shape italic
Spring
\shape default
 angeboten, um einzelne Beandefinitionen aus einer XML-Konfiguration zu
 gewinnen.
 Für unserer beiden Referenzierungselemente 
\begin_inset Quotes eld
\end_inset


\family sans
contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

, wollen wir genau das erreichen, und für den Fall, dass der referenzierte
 Contribution-Container noch nicht existiert, diesen erstellen.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:XML-Contributions-Ref:parse-Methode"

\end_inset

 zeigt als Beispiel die 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

parse
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode für das XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 aus der Klasse 
\family sans
\shape italic
MappedContributionRefBeanDefinitionParser
\family default
\shape default
.
 Die Implementierung für das XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 in der Klasse 
\family sans
\shape italic
OrderedContributionRefBeanDefinitionParser
\family default
\shape default
 ist ähnlich zu dieser und wird daher nicht extra gezeigt.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:XML-Contributions-Ref:parse-Methode"

\end_inset


\noun default
Parser Implementierung für das XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution-ref
\family default

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Auszug aus der Java-Klasse MappedContributionRefBeanDefinitionParser
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

protected void doParse(Element element, ParserContext parserContext,
\end_layout

\begin_layout Plain Layout

	BeanDefinitionBuilder builder)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String contributionName = element.getAttribute("name");
\end_layout

\begin_layout Plain Layout

	String beanName = MAPPED_CONTRIBUTION_PREFIX + contributionName;
\end_layout

\begin_layout Plain Layout

	BeanDefinitionRegistry registry = parserContext.getRegistry();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (!registry.containsBeanDefinition(beanName))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		BeanDefinitionBuilder contributionBeanBuilder =
\end_layout

\begin_layout Plain Layout

			BeanDefinitionBuilder.rootBeanDefinition(MapFactoryBean.class);
\end_layout

\begin_layout Plain Layout

		contributionBeanBuilder.addPropertyValue("sourceMap", new ManagedMap());
\end_layout

\begin_layout Plain Layout

		parserContext.getRegistry().registerBeanDefinition(beanName, contributionBeanBui
lder.getBeanDefinition());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	builder.addPropertyValue("targetBeanName", beanName);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Kommen wir nun zu den beiden Schlüsselwörtern 
\begin_inset Quotes eld
\end_inset


\family sans
contribution
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution
\family default

\begin_inset Quotes erd
\end_inset

, die als Beankonfigurationelemente der obersten Ebene im XML-File verwendet
 werden.
 Damit es möglich ist, eigene Konfiguration-Metadaten über XML-Elemente
 der obersten Ebene, also direkt unterhalb des Wurzeltags 
\family sans
\series bold
<beans>
\family default
\series default
, zu definieren, bietet 
\shape italic
Spring
\shape default
 das Interface 
\family sans
\shape italic
BeanDefinitionParser
\family default
\shape default
 an.
 Implementierungen dieses Interfaces ist es gestattet, während des Parsen
 des zugeordneten Elements, nicht nur eine sondern beliebig viele Beandefinition
en zu erstellen.
 Genau das ist es auch, was wir für die beiden Konfigurations-Elemente benötigen
, denn in beiden können ja eines oder mehrere Beanelemente definiert werden.
 Für die Behandlung des Elements 
\begin_inset Quotes eld
\end_inset


\family sans
contribution
\family default

\begin_inset Quotes erd
\end_inset

 mit seinem Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
to
\family default

\begin_inset Quotes erd
\end_inset

 (siehe Absatz 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:XML-Element-contribution:"

\end_inset

), zur Konfiguration von Contribution-Listen, wurde das 
\family sans
\shape italic
BeanDefinitionParser
\family default
\shape default
 Interface in der Klasse 
\family sans
\shape italic
OrderedContributionBeanDefinitionParser
\family default
\shape default
 umgesetzt.
 Für die Konfiguration einer Contribution-Map über das Element 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution
\family default

\begin_inset Quotes erd
\end_inset

, ebenfalls mit seinem Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
to
\family default

\begin_inset Quotes erd
\end_inset

 (siehe Absatz 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:XML-Element-mapped-contribution:"

\end_inset

), wurde dasselbe Interface in der Klasse 
\family sans
\shape italic
MappedContributionBeanDefinitionParser
\family default
\shape default
 implementiert.
 Beide Parser Implementierungen fügen dem jeweils definierten Contribution-Conta
iner alle, innerhalb des Konfigurationselements befindlichen, Beandefinitionen
 hinzu.
 Zusätzlich kümmern auch sie sich um die
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:XML-Contributions_List_Map:parse-Methoden"

\end_inset


\family sans
\shape italic
\noun default

\begin_inset Quotes erd
\end_inset

pars
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methoden für die XML-Elemente 
\begin_inset Quotes eld
\end_inset


\family sans
contribution
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution
\family default

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Auszug aus der Java-Klasse MappedContributionBeanDefinitionParser
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public BeanDefinition parse(Element element, ParserContext parserContext)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String contributionName = element.getAttribute("to");
\end_layout

\begin_layout Plain Layout

	BeanDefinitionBuilder builder =
\end_layout

\begin_layout Plain Layout

		BeanDefinitionBuilder.rootBeanDefinition(MapFactoryBean.class);
\end_layout

\begin_layout Plain Layout

	element.setAttribute("merge", "true");
\end_layout

\begin_layout Plain Layout

	Map parsedMap = parserContext.getDelegate()
\end_layout

\begin_layout Plain Layout

		.parseMapElement(element, builder.getRawBeanDefinition());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return MappedContributionUtils
\end_layout

\begin_layout Plain Layout

		.addContribution(contributionName, parsedMap, parserContext.getRegistry());
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Auszug aus der Java-Klasse OrderedContributionBeanDefinitionParser
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public BeanDefinition parse(final Element element,
\end_layout

\begin_layout Plain Layout

	final ParserContext parserContext)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		String contributionName = element.getAttribute("to");
\end_layout

\begin_layout Plain Layout

		NodeList entryList = element
\end_layout

\begin_layout Plain Layout

			.getElementsByTagNameNS(CONTRIBUTION_NAMESPACE, "entry");
\end_layout

\begin_layout Plain Layout

		List<OrderedContributionBeenContext> beans =
\end_layout

\begin_layout Plain Layout

			new ArrayList<OrderedContributionBeenContext>();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < entryList.getLength(); i++)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Element entry = (Element) entryList.item(i);
\end_layout

\begin_layout Plain Layout

			String name = entry.getAttribute("name");
\end_layout

\begin_layout Plain Layout

			String constraints = entry.getAttribute("constraints");
\end_layout

\begin_layout Plain Layout

			Object beanValueOrReference = parserContext
\end_layout

\begin_layout Plain Layout

				.getDelegate().parsePropertyValue(entry, null, name);
\end_layout

\begin_layout Plain Layout

			beans.add(new OrderedContributionBeenContext(name,
\end_layout

\begin_layout Plain Layout

				beanValueOrReference, constraints));
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return OrderContributionUtils
\end_layout

\begin_layout Plain Layout

		.addToContribution(contributionName, beans, parserContext.getRegistry());
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset

Erstellung der Beandefinition des Contribution-Containers, falls diese noch
 nicht anderweitig erstellt wurde.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:XML-Contributions_List_Map:parse-Methoden"

\end_inset

 zeigt die beiden 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

parse
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methoden, in denen jeweils nur die einzelnen Elemente identifiziert und
 in einer Liste, beziehungsweise in einer Map, abgelegt werden.
 Der Code zum Erstellen des Contribution-Containers ist unabhängig vom Konfigura
tionstyp und ist daher in eigenen Hilfsklassen (
\family sans
\shape italic
OrderContributionUtils
\family default
\shape default
, 
\family sans
\shape italic
MappedContributionUtils
\family default
\shape default
) umgesetzt, die auch von der Java-Variante der Konfiguration verwendet
 werden.
 Einen Auszug aus einer dieser Klassen zeigt Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:MappedContributionUtils-Klasse"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Registrierung-eines-Beans"

\end_inset

Registrierung eines Beans zu einer Contribution-Liste: Auszug aus dem 
\family sans
\shape italic
ContributionBeanDefinitionDecorator
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

private void addToContributionService(String contributionName,
\end_layout

\begin_layout Plain Layout

	BeanDefinition contribution, ParserContext parserContext)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	final String beanName = ORDERED_CONTRIBUTION_PREFIX 
\end_layout

\begin_layout Plain Layout

		+ contributionName;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	final BeanDefinitionRegistry registry = 
\end_layout

\begin_layout Plain Layout

		parserContext.getRegistry();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (registry.containsBeanDefinition(beanName))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		BeanDefinition beanDefinition = parserContext.getRegistry()
\end_layout

\begin_layout Plain Layout

			.getBeanDefinition(beanName);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		List list = (List) beanDefinition.getPropertyValues()
\end_layout

\begin_layout Plain Layout

			.getPropertyValue("contributionList").getValue();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		list.add(contribution);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		BeanDefinitionBuilder builder = 
\end_layout

\begin_layout Plain Layout

			BeanDefinitionBuilder.rootBeanDefinition(
\end_layout

\begin_layout Plain Layout

				OrderedConfigurationFactoryBean.class
\end_layout

\begin_layout Plain Layout

			);
\end_layout

\begin_layout Plain Layout

		List contributionList = new ManagedList();
\end_layout

\begin_layout Plain Layout

		contributionList.add(contribution);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		builder.addPropertyValue("contributionList",
\end_layout

\begin_layout Plain Layout

			contributionList);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        parserContext.getRegistry().registerBeanDefinition(
\end_layout

\begin_layout Plain Layout

			beanName, builder.getBeanDefinition()
\end_layout

\begin_layout Plain Layout

		);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Die letzten beiden Schlüsselwörter sind das XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
contributeTo
\family default

\begin_inset Quotes erd
\end_inset

 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contributeTo"

\end_inset

) und das XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribute
\family default

\begin_inset Quotes erd
\end_inset

 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contribute"

\end_inset

).
 Damit es möglich ist, selbst definierte XML-Attribute und Elemente innerhalb
 von allen XML-Beandefinitionen zu verwenden, bietet 
\shape italic
Spring
\shape default
 das Interface 
\family sans
\shape italic
BeanDefinitionDecorator
\family default
\shape default
 an.
 Alle beiden Schlüsselwörter werden in der 
\family sans
\shape italic
BeanDefinitionDecorator
\family default
\shape default
 Implementierung 
\family sans
\shape italic
ContributionBeanDefinitionDecorator 
\family default
\shape default
behandelt.
 Der 
\family sans
\shape italic
ContributionBeanDefinitionDecorator
\family default
\shape default
 ist dann dafür zuständig, die eigentliche Beandefinition zu erstellen und
 in einem 
\family sans
\shape italic
OrderedContribution
\family default
\shape default
 Objekt abzulegen.
 In diesem Objekt werden auch die Parameter des 
\begin_inset Quotes eld
\end_inset


\family sans
constraints
\family default

\begin_inset Quotes eld
\end_inset

 Attributs, zur Festlegung der Position des Beans innerhalb der Contribution-Lis
te, abgelegt.
 Anschließend wird das Objekt als Element zur Contribution-Liste hinzugefügt
 und somit in der 
\family sans
\shape italic
OrderedConfigurationFactoryBean
\family default
\shape default
 abgelegt.
 Wenn das entsprechende Bean das erste Element ist, das zur Contribution-Liste
 hinzugefügt werden soll, dann muss, wie auch bei den anderen Parser-Klassen,
 vor dem Hinzufügen zuerst noch die Beandefinition der Contribution-Liste
 selbst angelegt und in der 
\family sans
\shape italic
BeanDefinitionRegistry
\family default
\shape default
, also dem IOC-Container, registriert werden (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Registrierung-eines-Beans"

\end_inset

).
 Das heißt also, dass der 
\family sans
\shape italic
ContributionBeanDefinitionDecorator
\family default
\shape default
 hauptsächlich Beans zu Contribution-Listen hinzufügt, aber auch selbst
 Beandefinitionen zu Contribution-Listen erstellt, wenn diese noch nicht
 existieren und ihnen aber ein Bean als Element hinzugefügt werden soll.
\end_layout

\begin_layout Subsubsection
(Java) Abarbeitung der Konfigurationsschlüsselwörter 
\begin_inset CommandInset label
LatexCommand label
name "sub:(Java)-Abarbeitung-der-Konfigurationsschlüsselwörter"

\end_inset


\end_layout

\begin_layout Standard
Damit die 
\noun on
SpringContributions
\noun default
 Funktionalität auch in der Spring Java-Konfiguration verwendet werden kann,
 steht ein IOC-Postprozessor zur Verfügung (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:(Java)-Erweiterung-der-Konfiguration"

\end_inset

).
 Dieser 
\family sans
\shape italic
AnnotationContributionPostprocessor
\family default
\shape default
 kümmert sich um die Abarbeitung aller Contribution-Konfigurationen aus
 den bereitgestellten Konfigurationsklassen.
 Dabei dienen die beiden Annotationen 
\family sans
@Contribution
\family default
 und 
\family sans
@MappedContribution
\family default
 als Konfigurationsmetainformationen, die von dem Postprozessor abgearbeitet
 werden.
 Der Postprozessor implementiert das Spring-Interface 
\family sans
\shape italic
BeanDefinitionRegistryPostProcessor
\family default
\shape default
, welches eine Methode definiert, mit deren Hilfe die, nach der Standardinitiali
sierung in der IOC-Registry existierenden, Beandefinitionen verändert werden
 können.
 Zum Aufrufzeitpunkt dieser Methode existieren also bereits alle Beandefinitione
n aus der Konfiguration, es wurde aber noch kein einziges Bean auf Basis
 dieser Definitionen vom IOC-Container instanziiert.
 Wie der Postprozessor nun, aus der Java-Konfiguration und den Metainformationen
, Beandefinitionen für Contribution-Container und deren Elemente erstellt,
 ist auszugsweise in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:AnnotationContributionPostprocessor"

\end_inset

 zu sehen und wird im Folgenden erläutert.
\end_layout

\begin_layout Standard
Als erstes werden, in der Methode 
\family sans
\shape italic
postProcessBeanFactory,
\family default
\shape default
 alle Konfiguration-Beans geladen.
 Dabei handelt es sich um Klassen, die über die Annotation 
\family sans
@Configuration
\family default
 als Spring Java-Konfiguration ausgezeichnet sind.
 Diese Konfiguration-Beans werden nun zuerst nach Konfiguration-Methoden
 durchsucht, die mit der Annotation 
\family sans
@Contribution
\family default
 ausgezeichnet sind.
 In derartigen Konfigurationsklassen sind somit Beans definiert, die zu
 einer Contribution-Liste hinzugefügt werden sollen.
 Die Abarbeitung der Annotation ist ebenso in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:AnnotationContributionPostprocessor"

\end_inset

 in der Methode 
\family sans
\shape italic
handleOrderedContributions
\family default
\shape default
 dargestellt.
 In dieser Methode werden die Informationen zum Namen der Contribution-Liste
 (
\begin_inset Quotes eld
\end_inset


\family sans
to
\family default

\begin_inset Quotes erd
\end_inset

 Parameter) und zur Positionierung in der Liste (
\begin_inset Quotes eld
\end_inset


\family sans
constraints
\family default

\begin_inset Quotes erd
\end_inset

 Parameter) ausgelesen.
 Nach dem Auf-
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:AnnotationContributionPostprocessor"

\end_inset

 Auszug aus dem 
\family sans
\shape italic
AnnotationContributionPostprocessor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
 throws BeansException
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Map<String, Object> beans = 
\end_layout

\begin_layout Plain Layout

		beanFactory.getBeansWithAnnotation(Configuration.class);
\end_layout

\begin_layout Plain Layout

	for(String configuration : beans.keySet())
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		BeanDefinition beanDefinition =
\end_layout

\begin_layout Plain Layout

			beanFactory.getBeanDefinition(configuration);
\end_layout

\begin_layout Plain Layout

		if (beanDefinition instanceof AnnotatedBeanDefinition)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			AnnotatedBeanDefinition beanDef = (AnnotatedBeanDefinition) beanDefinition;
\end_layout

\begin_layout Plain Layout

			Set<MethodMetadata> orderedContributions =
\end_layout

\begin_layout Plain Layout

				beanDef.getMetadata().getAnnotatedMethods(Contribution.class.getName());
\end_layout

\begin_layout Plain Layout

			handleOrderedContributions(beanFactory, orderedContributions);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			Set<MethodMetadata> mappedContributions =
\end_layout

\begin_layout Plain Layout

				beanDef.getMetadata().getAnnotatedMethods(ContributionMapped.class.getName());
\end_layout

\begin_layout Plain Layout

			handleMappedContributions(beanFactory, mappedContributions);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private void handleOrderedContributions(
\end_layout

\begin_layout Plain Layout

	ConfigurableListableBeanFactory beanFactory, Set<MethodMetadata> orderedContrib
utions)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	for(MethodMetadata metadata : orderedContributions)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Map<String, Object> attributes = metadata.
\end_layout

\begin_layout Plain Layout

			getAnnotationAttributes(Contribution.class.getName());
\end_layout

\begin_layout Plain Layout

		String contributionName = (String)attributes.get("to");
\end_layout

\begin_layout Plain Layout

		String constraints = (String)attributes.get("constraints");
\end_layout

\begin_layout Plain Layout

		String beanName = getBeanName(metadata, attributes);
\end_layout

\begin_layout Plain Layout

		Object beanValueOrReference = beanFactory.getBeanDefinition(beanName);
\end_layout

\begin_layout Plain Layout

		OrderedContributionBeenContext beanContext = 
\end_layout

\begin_layout Plain Layout

			new OrderedContributionBeenContext(
\end_layout

\begin_layout Plain Layout

				beanName, beanValueOrReference, constraints);
\end_layout

\begin_layout Plain Layout

		OrderContributionUtils.addToContribution(contributionName, 
\end_layout

\begin_layout Plain Layout

			beanContext, (BeanDefinitionRegistry)beanFactory);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset

ruf der Methode sucht der Postprozessor die Konfiguration-Methoden, die
 mit der Annotation 
\family sans
@ContributionMapped
\family default
 ausgezeichnet wurden.
 Ergebnis dieser beiden Schritte sind in der IOC-Registry registrierte Beandefin
itionen zu Contribution-Containern und deren Elementen.
 Der Code zum Erstellen des Contribution-Containers ist unabhängig vom Konfigura
tionstyp und ist daher in eigenen Hilfsklassen (
\family sans
\shape italic
OrderContributionUtils
\family default
\shape default
, 
\family sans
\shape italic
MappedContributionUtils
\family default
\shape default
) umgesetzt, die auch von der XML-Variante der Konfiguration verwendet werden.
 Einen Auszug aus einer dieser Klassen zeigen Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:MappedContributionUtils-Klasse"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Gemeinsam verwendete Util-Klassen
\end_layout

\begin_layout Standard
Die beiden Hilfsklassen 
\family sans
\shape italic
OrderContributionUtils
\family default
\shape default
 und 
\family sans
\shape italic
MappedContributionUtils
\family default
\shape default
 werden sowohl beim Abarbeiten einer XML-Konfiguration (siehe Abschnitt
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:(XML)-Abarbeitung-der-Konfigurationsschlüsselwörter"

\end_inset

), als auch beim Abarbeiten der Java-Konfiguration (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:(Java)-Abarbeitung-der-Konfigurationsschlüsselwörter"

\end_inset

) verwendet.
 Diese Synergie ist möglich, da in beiden Fällen, nach dem unterschiedlichen
 Weg der Gewinnung der Konfigurationsinformationen, genau der selbe Schritt
 durchgeführt werden muss.
 Bei diesem Schritt handelt es sich um die finale Registrierung der Beandefiniti
onen für Contribution-Container und deren Elemente.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:MappedContributionUtils-Klasse"

\end_inset


\noun default
Auszug aus der Klasse 
\family sans
\shape italic
MappedContributionUtils
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

//Auszug aus der Java-Klasse MappedContributionUtils
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public static BeanDefinition addToContribution(
\end_layout

\begin_layout Plain Layout

	String contributionName, Map map, BeanDefinitionRegistry registry)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	final String beanName = 
\end_layout

\begin_layout Plain Layout

		MAPPED_CONTRIBUTION_PREFIX + contributionName;
\end_layout

\begin_layout Plain Layout

	BeanDefinition beanDefinition;
\end_layout

\begin_layout Plain Layout

	if (registry.containsBeanDefinition(beanName))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		beanDefinition = registry.getBeanDefinition(beanName);
\end_layout

\begin_layout Plain Layout

		beanDefinition.getPropertyValues().addPropertyValue("sourceMap", map);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		BeanDefinitionBuilder builder = 
\end_layout

\begin_layout Plain Layout

			BeanDefinitionBuilder.rootBeanDefinition(MapFactoryBean.class);
\end_layout

\begin_layout Plain Layout

		builder.addPropertyValue("sourceMap", map);
\end_layout

\begin_layout Plain Layout

		beanDefinition = builder.getBeanDefinition();
\end_layout

\begin_layout Plain Layout

		registry.registerBeanDefinition(beanName, beanDefinition);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return beanDefinition;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:MappedContributionUtils-Klasse"

\end_inset

 ist zu sehen, wie zuerst versucht wird, die Beandefinition des Contribution-Con
tainers aus der IOC-Registry zu bekommen oder diese zu erstellen, falls
 sie noch nicht existiert.
 Danach werden die einzelnen Elemente, die hier in einer 
\family sans
\shape italic
Map
\family default
\shape default
 enthalten sind, in dem Container abgelegt.
\end_layout

\begin_layout Subsubsection
Sortierung von Contribution-Listen
\end_layout

\begin_layout Standard
Um die Sortierung der Beans in einer Contribution-Liste zu ermöglichen,
 implementiert die Klasse 
\family sans
\shape italic
OrderedContribution
\family default
\shape default
 das Interface 
\family sans
\shape italic
Orderable
\family default
\shape default
.
 Dadurch kann die 
\family sans
\shape italic
OrderedConfigurationFactoryBean
\family default
\shape default
, mit Hilfe der Klasse 
\family sans
\shape italic
Orderer
\family default
\shape default
, die einzelnen Positionierungsangaben der Listenelemente berücksichtigen
 (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Contributionliste"

\end_inset

).
\end_layout

\begin_layout Standard
Wenn nun ein Bean, das eine Contribution-Liste benötigt, von der Spring
 IOC-Registry instanziiert wird, so bedient sich diese der 
\family sans
\shape italic
OrderedConfigurationFactoryBean,
\family default
\shape default
 um die Contri\SpecialChar \-
bution-Liste zu erhalten.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Contribution-Liste 
\begin_inset CommandInset label
LatexCommand label
name "fig:Contributionliste"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/OrderedContribution.eps
	scale 40
	rotateOrigin center

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Contribution-Bean Identifikation
\begin_inset CommandInset label
LatexCommand label
name "sub:Contribution-Bean-Identifikation"

\end_inset


\end_layout

\begin_layout Standard
Egal über welche Art der Konfiguration ein Contribution-Container erstellt
 wird, die 
\noun on
SpringContributions
\noun default
 versehen dessen Namen beziehungsweise dessen Identifikation in der Beandefiniti
on mit einem bestimmten Präfix.
 Diese Maßnahme soll helfen, Namenskollisionen mit anderen Beandefinitionen
 zu vermeiden.
 Namenskollisionen würden entstehen, wenn zwei Beandefinitionen den selben
 Namen beziehungsweise die selbe Identifikation innehaben.
 Eine solche Namenskollision führt in 
\shape italic
Spring
\shape default
 zu einem Fehler, da der IOC-Container nicht mehr zwischen den beiden Beandefini
tionen unterscheiden kann.
 Daher gilt es, bei der Verwendung von 
\shape italic
Spring,
\shape default
 auf die Verschiedenheit der Identifikation von Beandefinitionen zu achten.
 In kleinen Software-Projekten ist das relativ leicht zu bewerkstelligen.
 Mit wachsender Anzahl von Beandefinitionen erhöht sich aber generell auch
 die Möglichkeit von Namenskollisionen.
 Sobald ein Software-Projekt über seine eigenen Modulgrenzen hinaus noch
 fremde, auf 
\shape italic
Spring
\shape default
 basierende Module mit einbindet, existiert bezüglich der Namenskollisionen
 eine externe, nicht beeinflussbare Fehlerquelle.
 Das resultiert daraus, da man auf die Namensgebung in Fremdmodulen keinen
 Einfluss hat.
\end_layout

\begin_layout Standard
Das Spring-Framework bietet für diese Problematik keine automatisierte Hilfestel
lung oder Problemlösung an.
 Beans erhalten im IOC-Container immer genau die Identifikation, die in
 der Konfiguration vom Benutzer festgelegt wurde.
 Die Modulzugehörigkeit oder eventuelle Packetinformationen finden hier
 keine Berücksichtigung.
 Das hat den Vorteil, dass der Benutzer sich nicht mit irgendwelchen 
\begin_inset Quotes eld
\end_inset

magischen
\begin_inset Quotes erd
\end_inset

 Namensgebungen herumschlagen muss.
 Auf der anderen Seite ist der Benutzer des Spring-Frameworks hier in der
 Pflicht, sich eigene Maßnahmen zu dieser Problematik zu überlegen.
 In der Regel definiert man zur Vermeidung von Namenskollisionen eigene
 Namenskonventionen, wie zum Beispiel das Voranstellen des Modulnamen bei
 jeder Beanidentifikation.
 Die 
\noun on
SpringContributions
\noun default
 gehen hier mit der automatischen Vergabe des Identifikationspräfix einen
 anderen Weg als es das Spring-Framework macht.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(Java)-Namenspräfix"

\end_inset

 zeigt die beiden Präfixdefinitionen, auf die in Verschiedenen Listings
 zur Konfiguration verwiesen wird.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:(Java)-Namenspräfix"

\end_inset

(Java) Namenspräfix für Contribution-Container Definitionen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

* Prefix for mapped contributions.
\end_layout

\begin_layout Plain Layout

*/ 
\end_layout

\begin_layout Plain Layout

public static final String MAPPED_CONTRIBUTION_PREFIX = 
\end_layout

\begin_layout Plain Layout

	"org.springframework.contributions.mapped.";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

* Prefix for ordered contributions.
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

public static final String ORDERED_CONTRIBUTION_PREFIX = 
\end_layout

\begin_layout Plain Layout

	"org.springframework.contributions.ordered.";
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Anwendungsbeispiele
\end_layout

\begin_layout Standard
In den folgenden Anwendungsbeispielen folgt den Listings mit XML-Konfiguration
 sogleich ein Listing mit äquivalenter Java-Konfiguration.
 Dies soll der Vergleichbarkeit der beiden Konfigurationsmethoden dienen.
 Die beiden Konfigurationen werden danach in einem Unit-Test verwendet,
 in dem die Contribution in ihrer Verwendung gezeigt wird.
\end_layout

\begin_layout Subsection
(XML / Java) ValueHolder-Service und sortierte Contribution-Liste
\end_layout

\begin_layout Standard
Ein Anwendungsbeispiel des 
\noun on
SpringContributions
\noun default
 Mechanismus wird in den Listings 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(XML) OrderedContributionTest-Konfiguration"

\end_inset

 bis 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:OrderedContributionTest-Test"

\end_inset

 gegeben.
\end_layout

\begin_layout Standard
Dabei handelt es sich in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(XML) OrderedContributionTest-Konfiguration"

\end_inset

 um eine XML-Konfiguration einer Contribution-Liste und ihres Konsumenten.
 In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(Java) OrderedContributionTest-Konfiguration"

\end_inset

 wird, als Gegenüberstellung zur XML-Konfiguration, die analoge Java-Konfigurati
on angegeben.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:(XML) OrderedContributionTest-Konfiguration"

\end_inset

 (XML) Spring-Bean und Sortierte Contribution-Liste Test-Konfiguration
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Bean Konfig des Konsumenten -->
\end_layout

\begin_layout Plain Layout

<bean class="org.springframework.contributions.ValueHolder">
\end_layout

\begin_layout Plain Layout

	<constructor-arg>
\end_layout

\begin_layout Plain Layout

		<ctr:contribution-ref name="value-list" />
\end_layout

\begin_layout Plain Layout

	</constructor-arg>
\end_layout

\begin_layout Plain Layout

</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Konfiguration der Contribution-Listen Elemente -->
\end_layout

\begin_layout Plain Layout

<ctr:contribution to="value-list">
\end_layout

\begin_layout Plain Layout

	<ctr:entry name="string2" value="String 2"
\end_layout

\begin_layout Plain Layout

		constraints="after:string1" />
\end_layout

\begin_layout Plain Layout

	<ctr:entry name="string1" value="String 1"
\end_layout

\begin_layout Plain Layout

		constraints="before:*" />
\end_layout

\begin_layout Plain Layout

</ctr:contribution>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:(Java) OrderedContributionTest-Konfiguration"

\end_inset

 (Java) Spring-Bean und Sortierte Contribution-Liste Test-Konfiguration
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// (Java) Bean Konfig des Konsumenten
\end_layout

\begin_layout Plain Layout

@Bean(name="valueHolder") public ValueHolder valueHolder(OrderedContributionReso
lver<String> values)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return new ValueHolder(values.resolve("value-list"));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// (Java) Konfiguration der Contribution-Listen Elemente
\end_layout

\begin_layout Plain Layout

@Contribution(to="value-list", constraints="after:string1")
\end_layout

\begin_layout Plain Layout

@Bean(name="string2") public String string2()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return "String 2";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Contribution(to="value-list", constraints="before:*")
\end_layout

\begin_layout Plain Layout

@Bean(name="string1") public String string1()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return "String 1";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In dem Beispiel wird ein 
\family sans
\shape italic
ValueHolder
\family default
\shape default
 Service als Spring-Bean sowie eine
\family sans
\shape italic
 
\family default
\shape default
sortierte Contribution-Liste mit dem Namen 
\family sans
\shape italic
"value-list"
\family default
\shape default
 definiert werden.
 Das 
\family sans
\shape italic
ValueHolder
\family default
\shape default
 Service erwartet die Contribution-Liste als Konstruktor-Argument.
 Innerhalb der Contribution-Liste sind zwei Strings ("
\family sans
\shape italic
String 1
\family default
\shape default
", "
\family sans
\shape italic
String 2
\family default
\shape default
") als Elemente definiert.
 Jedem Element wird durch seine jeweiligen 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
constraints
\family default
\shape default

\begin_inset Quotes eld
\end_inset

 Einstellungen eine bestimmte Position innerhalb der Liste zugewiesen.
\end_layout

\begin_layout Standard
Im Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:OrderedContributionTest-Test"

\end_inset

 findet sich zum Einen die Implementierung des 
\family sans
\shape italic
ValueHolder
\family default
\shape default
 Service.
 Zum Anderen wird die zuvor definierte Spring-Konfiguration in einem Unit-Test
 
\end_layout

\begin_layout Standard
(
\family sans
\shape italic
OrderedContributionIntegrationTest
\family default
\shape default
) verwendet.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:OrderedContributionTest-Test"

\end_inset

 
\family sans
\shape italic
ValueHolder
\family default
\shape default
 Service und Ordered Contribution als JUnit-Test
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// Java-Klasse ValueHolder:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class ValueHolder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private final List<String> values;
\end_layout

\begin_layout Plain Layout

	public ValueHolder(final List<String> values)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.values = values;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public List<String> getValues()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return values;
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// JUnit-Test OrderedContributionIntegrationTest:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// hier wird das XML-Konfigurationsfile angegeben
\end_layout

\begin_layout Plain Layout

// oder die äquivalente Java-Konfiguration als Klasse
\end_layout

\begin_layout Plain Layout

// z.B.
 OrderedContributionIntegrationTestConfiguration.class
\end_layout

\begin_layout Plain Layout

@ContextConfiguration("classpath:spring-contributions-ordered.xml") 
\end_layout

\begin_layout Plain Layout

@RunWith(SpringJUnit4ClassRunner.class)
\end_layout

\begin_layout Plain Layout

public class OrderedContributionIntegrationTest
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@Inject
\end_layout

\begin_layout Plain Layout

	@Named("valueHolder")
\end_layout

\begin_layout Plain Layout

	private ValueHolder stringHolder;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Test
\end_layout

\begin_layout Plain Layout

	public void testStringContribution()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		assertThat(stringHolder.getValues(),
\end_layout

\begin_layout Plain Layout

			is(Arrays.asList("String 1", "String 2")));
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Innerhalb des Unit-Tests wird die Konfiguration über die Spring-Annotation
 
\family sans
\shape italic
@ContextConfiguration
\family default
\shape default
 als Spring-Kontext in den Test mit eingebunden.
 Der Unit-Test überprüft dann die richtige Reihenfolge der einzelnen Strings
 innerhalb der Contribution-Liste.
 Die über die Konfiguration festgelegte Reihenfolge, also 
\begin_inset Quotes eld
\end_inset

String 1
\begin_inset Quotes erd
\end_inset

 vor allen anderen Elementen (before:*) und 
\begin_inset Quotes eld
\end_inset

String 2
\begin_inset Quotes erd
\end_inset

 nach dem Bean mit der id 
\begin_inset Quotes eld
\end_inset

string1
\begin_inset Quotes erd
\end_inset

 (after:string1) wird überprüft.
 Das erwartete Ergebnis wird in der aktuellen Version der 
\noun on
SpringContributions
\noun default
 auch geliefert.
 Der Unit-Test zeigt nicht nur die Funktionsweise der 
\noun on
SpringContributions
\noun default
, sondern stellt bei zukünftigen Adaptierungen bzw.
 Weiterentwicklungen des Moduls auch die Korrektheit der Änderungen sicher.
\end_layout

\begin_layout Subsection
Contributions mehrfach konsumieren
\begin_inset CommandInset label
LatexCommand label
name "sub:Contributions-mehrfach-konsumier"

\end_inset


\end_layout

\begin_layout Standard
Ein Vorteil gegenüber dem in 
\shape italic
Tapestry
\shape default
 angebotenen Contribution System ergibt sich in den 
\noun on
SpringContributions 
\noun default
aus dem Umstand, dass jede Contribution als eigenes Bean behandelt wird.
 Ein Contribution-Container-Bean kann also nicht nur von einem Konsumenten
 verwendet werden, sondern steht, wie jedes andere Bean, zur beliebigen
 Verwendung bereit.
 Nehmen also zum Beispiel zwei Services eine Liste von Klassen des 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
(Java) Konfiguration mit Mehrfachverwendung einer Contribution-Liste
\begin_inset CommandInset label
LatexCommand label
name "lis:Java-Konfiguration-mit-Mehrfachverwendung"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Bean(name="singletonValueHolderOne")
\end_layout

\begin_layout Plain Layout

public ValueHolder singletonValueHolderOne(OrderedContributionResolver<String>
 values)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return new ValueHolder(values.resolve("singletonValues"));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Bean(name="singletonValueHolderTwo")
\end_layout

\begin_layout Plain Layout

public ValueHolder singletonValueHolderTwo(OrderedContributionResolver<String>
 values)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return new ValueHolder(values.resolve("singletonValues"));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Contribution(to="singletonValues")
\end_layout

\begin_layout Plain Layout

@Bean
\end_layout

\begin_layout Plain Layout

public String singletonOne()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return "original";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Contribution(to="singletonValues")
\end_layout

\begin_layout Plain Layout

@Bean
\end_layout

\begin_layout Plain Layout

public String singletonTwo()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return "values";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset

selben Typs als Servicekonfiguration entgegen, so muss jedes Element dieser
 Liste, sofern sich die Liste in ihrer Zusammenstellung nicht unterscheiden
 soll, nur ein einziges Mal konfiguriert werden.
 Es ist also egal, von wie vielen Beans die Contribution anschließend verwendet
 wird.
 In 
\shape italic
Tapestry
\shape default
 müsste man für dasselbe Beispiel jedem Service eine eigene Contribution-Liste
 übergeben.
 Dafür wäre es notwendig, jedes Element für jede dieser Listen zu konfigurieren.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Java-Konfiguration-mit-Mehrfachverwendung"

\end_inset

 zeigt eine Java-Konfiguration in der zwei Services ein und die selbe Contributi
on-Liste verwenden.
\end_layout

\begin_layout Subsection*
Gefahren durch mehrfaches Konsumieren
\end_layout

\begin_layout Standard
Natürlich birgt die Möglichkeit der uneingeschränkten Verwendung von Contributio
ns durch mehrere Konsumenten auch Risiken, auf die in der Verwendung acht
 gegeben werden muss.
 So muss man in der derzeitigen Umsetzung der 
\noun on
SpringContributions
\noun default
 beachten, dass ein Bean eines Contribution-Containers als einzelnes Objekt
 existiert und somit dessen Zustand, also auch die Art und Anzahl seiner
 Elemente, von jedem Konsumenten verändert werden kann.
 Siehe dazu mehr im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Konfigurierbarkeit-der-Sichtbarkeit"

\end_inset

.
\end_layout

\begin_layout Standard
Ein Beispiel für diese Problematik zeigt der Test aus Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:JUnit-Test-zur-Veränderung-des_Contr-Container-Zustands"

\end_inset

.
 Dabei sind für den Test zwei Services konfiguriert, die beide auf den selben
 Contribution-Container zugreifen.
 Die Contribution-Liste besteht dabei aus Elementen, die einen einfachen
 Text enthalten.
 Der eine der beiden Services ist ein 
\family sans
\shape italic
ValueHolderConsumer
\family default
\shape default
 und gibt beim Aufruf seiner 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

consume
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode die Texte seiner Contribution-Elemente durch ein Leerzeichen getrennt
 zurück.
 Der zweite Service ist ein 
\family sans
\shape italic
ValueHolderManipulator
\family default
\shape default
 und fügt den Elementen der Contribution-Liste ein weiteres hinzu, das den
 Text 
\begin_inset Quotes eld
\end_inset

manipulated
\begin_inset Quotes erd
\end_inset

 enthält.
 Der 
\begin_inset VSpace bigskip
\end_inset


\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:JUnit-Test-zur-Veränderung-des_Contr-Container-Zustands"

\end_inset

JUnit-Test zur Veränderung des Contribution-Container Zustands
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

//Auszug aus einem JUnit-Test
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Inject
\end_layout

\begin_layout Plain Layout

@Named(value="singletonValueHolderConsumer")
\end_layout

\begin_layout Plain Layout

private ValueHolderConsumer singletonConsumer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Inject
\end_layout

\begin_layout Plain Layout

@Named(value="singletonValueHolderManipulator")
\end_layout

\begin_layout Plain Layout

private ValueHolderManipulator singletonManipulator;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Test
\end_layout

\begin_layout Plain Layout

public void testUsageAndManipulationWithSingletonContribution()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String beforeManipulation = singletonConsumer.consume();
\end_layout

\begin_layout Plain Layout

	singletonManipulator.manipulate();
\end_layout

\begin_layout Plain Layout

	String afterManipulation = singletonConsumer.consume();
\end_layout

\begin_layout Plain Layout

	assertEquals("original values ", beforeManipulation);
\end_layout

\begin_layout Plain Layout

	assertEquals("original values manipulated ", afterManipulation);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset

Test ruft nun zuerst die 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

consume
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode auf und bekommt dabei den Text 
\begin_inset Quotes eld
\end_inset

original values 
\begin_inset Quotes erd
\end_inset

 zurück.
 Danach wird die 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

manipulate
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode aufgerufen.
 Ein erneuter Aufruf der 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

consume
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode liefert nun den Text 
\begin_inset Quotes eld
\end_inset

original values manipulated 
\begin_inset Quotes erd
\end_inset

 zurück.
 Der Test zeigt also, dass das Verändern des Zustands der Contribution-Liste
 durch einen Konsumenten auch eine Auswirkung auf alle andere Konsumenten
 hat.
 Wie diese Problematik in der Konfiguration umgangen werden könnte, zeigt
 der Ausblick auf mögliche Erweiterungen für die 
\noun on
SpringContributions
\noun default
 im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Konfigurierbarkeit-der-Sichtbarkeit"

\end_inset

.
\end_layout

\begin_layout Section
\begin_inset Quotes eld
\end_inset

Strategy
\begin_inset Quotes erd
\end_inset

 Service
\begin_inset CommandInset label
LatexCommand label
name "sub:Strategy-Service"

\end_inset


\end_layout

\begin_layout Standard
Im letzten Abschnitt wurde die Adaption des von 
\shape italic
Tapestry
\shape default
 bekannten Contribution-Mechanismus für das Spring-Framework behandelt.
 Damit haben wir jetzt die Grundlage geschaffen, um uns einem weiteren Schritt
 zu widmen.
 Einer der, auf jeden Fall in der Porsche Informatik, am meisten genutzten
 Dienste, den das Tapestry-Framework aufbauend auf dem Contribution-Mechanismus
 anbietet, ist der des 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
StrategyBuilder
\family default
\shape default

\begin_inset Quotes erd
\end_inset

.
 Aus diesem Grund ist es ein notwendiges Ziel des praktischen Teils dieser
 Arbeit, auch diesen Dienst innerhalb der 
\noun on
SpringContributions
\noun default
 anzubieten.
 In diesem Abschnitt sollen nun die Funktionsweise dieses Dienstes beschrieben
 und seine Adaption für 
\shape italic
Spring
\shape default
 gezeigt werden.
\end_layout

\begin_layout Standard
Als Ausgangspunkt sei hier die Grundlage des Dienstes erwähnt.
 In 
\begin_inset Quotes eld
\end_inset


\shape italic
Design Patterns
\shape default

\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset

 wurde 1995 eine Sammlung von Designmustern veröffentlicht deren Verwendung
 sich im Allgemeinen positiv auf die Qualität von Software auswirken.
 Das 
\begin_inset Quotes eld
\end_inset


\shape italic
Strategy Pattern
\shape default

\begin_inset Quotes erd
\end_inset

, auf dem der Tapestry-Dienst 
\family sans
\shape italic
StrategyBuilder
\family default
\shape default
 basiert, ist dabei eines dieser Muster und dient dazu,
\end_layout

\begin_layout Quotation
eine Familie von Algorithmen zu definieren, wobei es einen jeden kapselt
 und austauschbar macht.
 Eine Strategy ermöglicht den Klienten, die sie verwenden, den Algorithmus
 unabhängig zu variieren.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset


\end_layout

\begin_layout Subsection
Tapestry-Variante
\end_layout

\begin_layout Standard

\shape italic
Tapestry
\shape default
 bietet mit dem 
\family sans
\shape italic
StrategyBuilder
\family default
\shape default
 Service einen Dienst an, der das 
\shape italic
Strategy Pattern
\shape default
 auf eine sehr intelligente Weise erweitert.
 Die Konfiguration, also welche Algorithmen in einer Strategy zur Verfügung
 stehen, geschieht in 
\shape italic
Tapestry
\shape default
 natürlich via Contribution.
 Das bedeutet, dass eine gewisse Anzahl an unterschiedlichen Strategien
 - damit sind gekapselte Algorithmen gemeint - dem Strategy-Service übergeben
 werden.
 Die Entscheidung eines Klienten, welche Strategie er verwenden will, wird
 in 
\shape italic
Tapestry
\shape default
 über Java-Klassen gesteuert.
 Das heißt, jeder Strategie ist als Schlüssel eine Java-Klasse zugeordnet,
 über die sie eindeutig bestimmt werden kann.
 Die Zuordnung von Java-Klasse und Strategie bedeutet im Detail, dass die
 Strategie einen Algorithmus kapselt, der Objekte vom Typ der Java-Klasse
 verarbeiten kann.
 Die Wörter Schlüssel und Contribution lassen hier gleich erkennen, dass
 sich der 
\shape italic
Tapestry
\shape default
 
\family sans
\shape italic
StrategyBuilder
\family default
\shape default
 eine Mapped-Configuration 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Mapped-Configuration"

\end_inset

 als Konfiguration erwartet.
\end_layout

\begin_layout Standard
Die 
\begin_inset Quotes eld
\end_inset

Intelligenz
\begin_inset Quotes erd
\end_inset

 des Strategy-Services zeigt sich in einem weiteren Detail.
 Will ein Klient eine Strategie auf ein Objekt anwenden, für dessen Klassen-Typ
 eigentlich keine Strategie konfiguriert wurde, so verhält sich das Stretegy-Ser
vice in 
\shape italic
Tapestry
\shape default
 folgendermaßen:
\end_layout

\begin_layout Standard
Wenn also für den konkreten Klassen-Typ des Objekts keine Strategie gefunden
 wurde, so wird für jede Superklasse geschaut, ob eine Strategie verfügbar
 ist.
 Die Suche wird für die komplette Hierarchie der Superklassen fortgesetzt,
 bis entweder eine Strategie gefunden wurde und diese auf das Objekt angewandt
 werden kann, oder bis man beim Klassen-Typ 
\family sans
\shape italic
Object
\family default
\shape default
 angelangt ist.
 Ist für diesen letzten Typ auch keine Strategie registriert, so wird die
 Suche abgebrochen.
\end_layout

\begin_layout Subsection

\noun on
SpringContributions
\noun default
 Variante
\end_layout

\begin_layout Standard
Um für die 
\noun on
SpringContributions
\noun default
 eine eigene Variante des 
\shape italic
Strategy Pattern
\shape default
 umsetzen zu können, war natürlich zuerst die Voraussetzung der Konfigurierbarke
it einer Contribution-Map zu realisieren.
 Danach musste mit der 
\family sans
\shape italic
StrategyFactoryBean
\family default
\shape default
 nur noch eine eigene 
\family sans
\shape italic
FactoryBean
\family default
\shape default
 implementiert werden, die dem Klienten die gesuchte Strategie als Bean
 instanziiert und zur Verfügung stellt.
 Implementierungen des Interfaces 
\family sans
\shape italic
FactoryBean
\family default
\shape default
 werden in 
\shape italic
Spring
\shape default
 verwendet, um Beans zu instanziieren.
 Ein wichtiges Ziel des praktischen Teils dieser Arbeit war, die Tapestry-Funkti
onalität innerhalb des Spring-Frameworks exakt nach zu empfinden (siehe
 Kapite 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Praxisteil"

\end_inset

).
 Um also sicherzustellen, dass sich die 
\noun on
SpringContributions
\noun default
 Variante, im Bezug auf die Suche nach der passenden Strategie für ein Objekt,
 nicht von der Tapestry-Variante unterscheidet, wurden die dafür zuständigen
 Tapestry-Klassen als Kopien in das 
\noun on
SpringContributions
\noun default
 Projekt übernommen.
 Diese Klassen finden dann innerhalb der 
\family sans
\shape italic
StrategyFactoryBean
\family default
\shape default
 ihre Verwendung.
\end_layout

\begin_layout Paragraph*
Beispiel:
\end_layout

\begin_layout Standard
Um nun eine bessere Vorstellung vom 
\shape italic
Strategy Pattern
\shape default
 in der 
\shape italic
Tapestry
\shape default
 bzw.
 
\noun on
SpringContributions
\noun default
 Variante zu erhalten, folgt hier nun ein Beispiel für dessen Anwendung
 anhand eines Unit-Tests.
 Die Listings 
\begin_inset CommandInset ref
LatexCommand ref
reference "XML:spring-contributions-strategy-building"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "Java:spring-contributions-strategy-building"

\end_inset

 zeigen eine XML-Konfiguration und deren Java-Äquivalent.
 In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "spring-contributions-strategy-test"

\end_inset

 ist der zugehörige Unit-Test zu sehen.
\end_layout

\begin_layout Standard
Das Beispiel zeigt, wie das 
\shape italic
Strategy Pattern
\shape default
 für die Anwendung unterschiedlicher Strategien zur Formatierung von Strings,
 verwendet werden kann.
 Dabei werden drei von einander verschiedene Algorithmen als Strategien
 konfiguriert.
 Jede dieser Strategien benötigt nun auch eine eigene Java-Klasse, die ihr,
 zur Identifizierung in der Contribution-Map, als Schlüssel zugewiesen wird.
 Ein Objekt dieser Schlüsselklasse wird in der Anwendung dann auch den zu
 formatierenden String enthalten.
 
\end_layout

\begin_layout Itemize
Die erste konfigurierte Strategie 
\family sans
\shape italic
UpperCaseStringFormatStrategy
\family default
\shape default
 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "spring-contributions-strategy-test-UpperCaseStringFormatStrategy"

\end_inset

), mit Schlüsselklasse 
\family sans
\shape italic
UpperCase,
\family default
\shape default
 soll einen String in eine Großbuchstabendarstellung umwandeln.
\end_layout

\begin_layout Itemize
Die zweite Strategie 
\family sans
\shape italic
BlankSeparatedStringFormatStrategy
\family default
\shape default
, mit Schlüsselklasse 
\family sans
\shape italic
BlankSeparated,
\family default
\shape default
 ändert einen String, indem sie nach jedem Zeichen ein Leerzeichen einfügt.
\end_layout

\begin_layout Itemize
Die dritte Strategie 
\family sans
\shape italic
ReversedStringFormatStrategy
\family default
\shape default
, mit Schlüsselklasse 
\family sans
\shape italic
Reversed,
\family default
\shape default
 dreht bei ihrer Anwendung den String so um, dass er von links nach rechts
 geschrieben wird.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "spring-contributions-strategy-test-UpperCaseStringFormatStrategy"

\end_inset

 
\family sans
\shape italic
UpperCaseStringFormatStrategy
\family default
\shape default
 mit Schlüsselklasse 
\family sans
\shape italic
UpperCase
\family default
\shape default
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Java-Klasse StringContainer Interface:
\end_layout

\begin_layout Plain Layout

public interface StringContainer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String getStingValue();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Java-Klasse UpperCase als Schlüsselklasse zur UpperCaseStringFormatStrategy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class UpperCase implements StringContainer
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private final String value;
\end_layout

\begin_layout Plain Layout

	public UpperCase(String value)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.value = value;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public String getStingValue()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

	return value;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Java-Klasse StringFormatStrategy:
\end_layout

\begin_layout Plain Layout

public interface StringFormatStrategy<T extends StringContainer>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String format(T valueContainer);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Java-Klasse UpperCaseStringFormatStrategy
\end_layout

\begin_layout Plain Layout

public class UpperCaseStringFormatStrategy implements StringFormatStrategy<Upper
Case>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public String format(UpperCase valueContainer)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return valueContainer.getStingValue().toUpperCase();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
XML-Konfiguration
\end_layout

\begin_layout Standard
In der XML-Konfiguration 
\begin_inset CommandInset ref
LatexCommand ref
reference "XML:spring-contributions-strategy-building"

\end_inset

 wird als erstes ein Bean vom Typ 
\family sans
\shape italic
StrategyFactoryBean
\family default
\shape default
 konfiguriert.
 Dieses Bean nimmt über den Konstruktor eine Contribution-Map entgegen.
 Die drei Elemente der Contribution-Map, also die drei Strategien zur String-For
matierung, werden gleich darauf, im selben XML-File, zuerst als Beans konfigurie
rt und dann der Contribution-Map hinzugefügt.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "XML:spring-contributions-strategy-building"

\end_inset

 (XML) Konfiguration einer Strategie in 
\noun on
SpringContributions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

<bean id="stringFormatStrategy" class="org.springframework.contributions.ioc.service
s.strategy.StrategyFactoryBean">
\end_layout

\begin_layout Plain Layout

	<constructor-arg value="org.springframework.contributions.strategy.StringFormatStra
tegy" />
\end_layout

\begin_layout Plain Layout

	<constructor-arg> 
\end_layout

\begin_layout Plain Layout

		<ctr:mapped-contribution-ref name="stringFormatStrategies" />
\end_layout

\begin_layout Plain Layout

	</constructor-arg>
\end_layout

\begin_layout Plain Layout

</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<bean id="upperCase" class="org.springframework.contributions.strategy.strategies.Upp
erCaseStringFormatStrategy" /> 
\end_layout

\begin_layout Plain Layout

<bean id="blankSeparated" class="org.springframework.contributions.strategy.strategi
es.BlankSeparatedStringFormatStrategy" />
\end_layout

\begin_layout Plain Layout

<bean id="reversed" class="org.springframework.contributions.strategy.strategies.Reve
rsedStringFormatStrategy" /> 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<ctr:mapped-contribution to="stringFormatStrategies">
\end_layout

\begin_layout Plain Layout

	<entry>
\end_layout

\begin_layout Plain Layout

		<key>
\end_layout

\begin_layout Plain Layout

			<value>org.springframework.contributions.strategy.entities.UpperCase</value>
\end_layout

\begin_layout Plain Layout

		</key>
\end_layout

\begin_layout Plain Layout

		<ref bean="upperCase" />
\end_layout

\begin_layout Plain Layout

	</entry>
\end_layout

\begin_layout Plain Layout

	<entry>
\end_layout

\begin_layout Plain Layout

		<key>
\end_layout

\begin_layout Plain Layout

			<value>org.springframework.contributions.strategy.entities.BlankSeparated</value>
\end_layout

\begin_layout Plain Layout

		</key>
\end_layout

\begin_layout Plain Layout

		<ref bean="blankSeparated" />
\end_layout

\begin_layout Plain Layout

	</entry>
\end_layout

\begin_layout Plain Layout

	<entry>
\end_layout

\begin_layout Plain Layout

		<key>
\end_layout

\begin_layout Plain Layout

			<value>org.springframework.contributions.strategy.entities.Reversed</value>
\end_layout

\begin_layout Plain Layout

		</key>
\end_layout

\begin_layout Plain Layout

		<ref bean="reversed" />
\end_layout

\begin_layout Plain Layout

	</entry>
\end_layout

\begin_layout Plain Layout

</ctr:mapped-contribution> ...
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Java-Konfiguration
\end_layout

\begin_layout Standard
Die Java-Konfiguration 
\begin_inset CommandInset ref
LatexCommand ref
reference "Java:spring-contributions-strategy-building"

\end_inset

 ist äquivalent zur XML-Konfiguration.
 Es wird ebenfalls das Bean vom Typ 
\family sans
\shape italic
StrategyFactoryBean
\family default
\shape default
 konfiguriert, gefolgt von der Konfiguration der benötigten Contribution-Map
 und ihrer Elemente.
 Im Unit-Test 
\begin_inset CommandInset ref
LatexCommand ref
reference "spring-contributions-strategy-test"

\end_inset

 wird nun diese Java-Konfiguration verwendet.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Java:spring-contributions-strategy-building"

\end_inset

 (Java) Konfiguration einer Strategy in 
\noun on
SpringContributions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

@EnableContributions
\end_layout

\begin_layout Plain Layout

@EnableAspectJAutoProxy
\end_layout

\begin_layout Plain Layout

public class StrategyFactoryBeanIntegrationTestConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@Bean(name="stringFormatStrategy")
\end_layout

\begin_layout Plain Layout

	public StrategyFactoryBean strategyCaller(MappedContributionResolver<Map<Class,
 Strategy>> strategies)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new StrategyFactoryBean(StringFormatStrategy.class, strategies.resolve("s
tringFormatStrategies"));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@ContributionMapped(to="stringFormatStrategies", keyClass=UpperCase.class)
\end_layout

\begin_layout Plain Layout

	@Bean(name="upperCase")
\end_layout

\begin_layout Plain Layout

	public StringFormatStrategy<UpperCase> upperCase()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new UpperCaseStringFormatStrategy();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@ContributionMapped(to="stringFormatStrategies", keyClass=BlankSeparated.class)
\end_layout

\begin_layout Plain Layout

	@Bean(name="blankSeparated")
\end_layout

\begin_layout Plain Layout

	public StringFormatStrategy<BlankSeparated> blankSeparated()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new BlankSeparatedStringFormatStrategy();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@ContributionMapped(to="stringFormatStrategies", keyClass=Reversed.class,
 bean="reversed")
\end_layout

\begin_layout Plain Layout

	@Bean(name="reversed")
\end_layout

\begin_layout Plain Layout

	public StringFormatStrategy<Reversed> reversed()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new ReversedStringFormatStrategy();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Anwendung des 
\shape italic
Strategy Pattern
\end_layout

\begin_layout Standard
In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "spring-contributions-strategy-test"

\end_inset

 wird nun die Spring Java-Konfiguration aus Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "Java:spring-contributions-strategy-building"

\end_inset

 über die Referenzierung der Klasse 
\family sans
\shape italic
StrategyFactoryBeanIntegrationTestConfiguration
\family default
\shape default
 verwendet.
\end_layout

\begin_layout Standard
Die Instanz der benötigten 
\family sans
\shape italic
StringFormatStrategy
\family default
\shape default
 wird über die Annotationen 
\family sans
@Inject
\family default
 und 
\family sans
@Named
\family default
 über 
\shape italic
Dependency Injection
\shape default
 aus dem Spring IOC-Container geholt.
 Dabei wird in der Annotation 
\family sans
@Named
\family default
 der Name des konfigurierten Bean 
\begin_inset Quotes eld
\end_inset

stringFormatStrategy
\begin_inset Quotes erd
\end_inset

 angegeben, damit der IOC-Container exakt Bescheid weiß, welches Bean er
 injizieren soll.
 Die Anwendung der vorhandenen Strategien wird in der Testmethode gezeigt.
 Dabei wird der String 
\begin_inset Quotes eld
\end_inset

foobar
\begin_inset Quotes erd
\end_inset

 dreimal in einen jeweils anderen 
\family sans
\shape italic
StringContainer
\family default
\shape default
 gepackt, der immer als Schlüsselklasse für eine der Strategien fungiert.
 Mit diesem Container, wird dann der String an die 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

format
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode 
\family sans
\shape italic
StringFormatStrategy
\family default
\shape default
 übergeben, wo dann die entsprechende Strategie gesucht und angewandt wird.
 Der Test zeigt, dass der Text je nach gewünschter Strategie formatiert
 wird.
 So wird also aus einem 
\begin_inset Quotes eld
\end_inset

foobar
\begin_inset Quotes erd
\end_inset

 im 
\family sans
\shape italic
UpperCase
\family default
\shape default
 Container, bei Anwendung der Strategie, ein 
\begin_inset Quotes eld
\end_inset

FOOBAR
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "spring-contributions-strategy-test"

\end_inset

 Strategy Anwendung als JUnit-Test
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// hier wird die JAVA-Konfiguration als Klasse angegeben
\end_layout

\begin_layout Plain Layout

@ContextConfiguration(
\end_layout

\begin_layout Plain Layout

	classes={StrategyFactoryBeanIntegrationTestConfiguration.class},
\end_layout

\begin_layout Plain Layout

	loader=AnnotationConfigContextLoader.class)
\end_layout

\begin_layout Plain Layout

public class AnnotationStrategyFactoryBeanIntegrationTest
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@Inject
\end_layout

\begin_layout Plain Layout

	@Named("stringFormatStrategy")
\end_layout

\begin_layout Plain Layout

	private StringFormatStrategy<StringContainer> stringFormatStrategy;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Test
\end_layout

\begin_layout Plain Layout

	public void testStringFormatStrategy()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		final String value = "foobar";
\end_layout

\begin_layout Plain Layout

		StringContainer upperCase = new UpperCase(value);
\end_layout

\begin_layout Plain Layout

		assertThat(stringFormatStrategy.format(upperCase),
\end_layout

\begin_layout Plain Layout

			is("FOOBAR"));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		StringContainer reversed = new Reversed(value);
\end_layout

\begin_layout Plain Layout

		assertThat(stringFormatStrategy.format(reversed),
\end_layout

\begin_layout Plain Layout

			is("raboof"));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		StringContainer blankSeparated = new BlankSeparated(value);
\end_layout

\begin_layout Plain Layout

		assertThat(stringFormatStrategy.format(blankSeparated),
\end_layout

\begin_layout Plain Layout

			is("f o o b a r"));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Zusammenfassung und Ausblick
\end_layout

\begin_layout Standard
Im praktischen Teil zu dieser Diplomarbeit ist es gelungen mit den 
\noun on
SpringContributions
\noun default
, ein Spring-Softwaremodul zu entwickeln, mit dessen Hilfe eine Spring-Anwendung
 um einen Contribution-Mechanismus, nach dem Vorbild des Apache Tapestry-Framewo
rks, erweitert wird.
 Dieser Mechanismus bietet die Möglichkeit, modulübergreifende 
\shape italic
Dependency Injection
\shape default
 für sogenannte Container-Beans in der Form von zwei komplexen Datentypen,
 dem der Liste und dem der Map, anzuwenden.
 Die Besonderheit an dem System liegt darin, dass die Elemente dieser, für
 die 
\shape italic
Dependency Injection
\shape default
 vorgesehenen, Container-Beans in den verschiedensten, auch durch Modulgrenzen
 von einander getrennten Softwarekonfigurationen definiert sein können.
\end_layout

\begin_layout Standard
Unter Verwendung der 
\noun on
SpringContributions
\noun default
 ist es nun also noch einfacher, im Zusammenspiel mit dem Spring-Framework,
 hoch konfigurierbare, multimodulare Softwareprojekte zu realisieren.
 Gleichzeitig besteht nun die Möglichkeit, eine auf dem Tapestry-Framework
 basierende Softwarearchitektur, ohne Einbußen in der Konfigurierbarkeit,
 mit 
\shape italic
Spring
\shape default
 zu kombinieren.
 Darüber hinaus ist es über die Verwendung der 
\noun on
SpringContributions
\noun default
 natürlich auch möglich, eine in 
\shape italic
Tapestry
\shape default
 entwickelte und auf dem Contribution-Mechanismus basierende Softwarekomponente
 von Tapestry-IOC auf Spring-IOC zu migrieren, ohne dabei die Konfigurierbarkeit
 der Software grundlegend anpassen zu müssen.
 Dies alles öffnet also den Weg dahin, zwei äußerst hilfreiche Frameworks
 effizient gemeinsam nutzen zu können.
\end_layout

\begin_layout Standard
Die Synergien der beiden Frameworks werden durch den Einsatz der 
\noun on
SpringContributions
\noun default
 in der Porsche Informatik bereits seit zwei Jahren produktiv genutzt.
 Die Version 1.1 der 
\noun on
SpringContributions
\noun default
 kommt hier innerhalb einer B2B Webapplikation zum Gebrauchtwagenverkauf,
 in einer Verrechnungssoftware und in der Neuentwicklung eines Händlersystems
 zum Einsatz.
 In dieser Version ist bereits die komplette XML-Konfiguration inklusive
 der 
\shape italic
Strategy Pattern
\shape default
 Unterstützung umgesetzt.
 Damit war es möglich, die zuerst nur mit 
\shape italic
Tapestry
\shape default
 entwickelte Webapplikation um den Funktionsumfang von 
\shape italic
Spring
\shape default
 zu erweitern.
 Die Weiterentwicklung der 
\noun on
SpringContributions
\noun default
 mit der ergänzten Möglichkeit der Java-Konfiguration ist ab der aktuellen
 Version 1.2 im Projekt enthalten.
 Ein Wechsel auf die aktuelle Version ist in der Porsche Informatik bereits
 geplant, da in der Entwicklung der B2B Webapplikation die Verwendbarkeit
 von Springs Java-Konfiguration benötigt wird.
 Das 
\noun on
SpringContributions
\noun default
 Projekt ist als 
\shape italic
Maven
\begin_inset Foot
status open

\begin_layout Plain Layout

\shape italic
Apache Maven
\shape default
 ist ein Build-Management Werkzeug zum standardisierten Erstellen von Java-Progr
ammen
\end_layout

\end_inset


\shape default
 Projekt entwickelt und wird bei Versionsrelease in öffentlichen Mavenrepositori
es für die freie Verwendung zur Verfügung gestellt.
 Das 
\noun on
SpringContributions
\noun default
 Projekt wird auf Googlecode gehostet
\begin_inset Foot
status open

\begin_layout Plain Layout
Die 
\noun on
SpringContributions
\noun default
 Projektseite ist unter folgender URL zu erreichen (10.12.2013):
\end_layout

\begin_layout Plain Layout
https://code.google.com/p/spring-contributions/
\end_layout

\end_inset

 und ist dort unter der 
\shape italic
Apache License, Version 2.0
\shape default

\begin_inset Foot
status open

\begin_layout Plain Layout
Die 
\shape italic
Apache License, Version 2.0
\shape default
 ist unter folgender URL zu erreichen (10.12.2013):
\end_layout

\begin_layout Plain Layout
http://www.apache.org/licenses/LICENSE-2.0
\end_layout

\end_inset

 veröffentlicht.
\end_layout

\begin_layout Standard
Bei der Entwicklung des 
\noun on
SpringContributions
\noun default
 Moduls wurde versucht, den gesamten Spielraum des aus dem Tapestry-Vorbild
 bekannten Konfigurationsmechanismus nachzubilden.
 Was die Funktionsweise betrifft wurde dieses Ziel im Rahmen des Praxisteils
 dieser Arbeit auch erreicht.
 Was den Komfort bezüglich der Schreibweise der 
\noun on
SpringContributions
\noun default
 Konfiguration betrifft, so besteht gerade für die Variante der Java-Konfigurati
on noch eine Verbesserungsmöglichkeit.
 Außerdem besteht generell noch Erweiterungspotential wenn es um die Sichtbarkei
t von Contribution-Containern geht.
 Diese beiden Aspekte werden nun noch kurz beleuchtet.
\end_layout

\begin_layout Subsection*
Konfiguration und Übergabe mehrerer Elemente an einen Contribution-Container
\end_layout

\begin_layout Standard
In der aktuellen Version der 
\noun on
SpringContributions,
\noun default
 ist es in der Java-Konfiguration nur möglich ein Bean pro Konfirurationsmethode
 zu definieren.
 Das kommt daher, da hier die Basisfunktionalität von 
\shape italic
Spring
\shape default
 verwendet wird und hier nicht mehrere Beans auf einmal definiert werden
 können.
 Dadurch kann natürlich auch immer nur ein Bean über die Annotierung seiner
 Konfigurationsmethode einem Contribution-Container hinzugefügt werden.
 Wollte man hier den selben Komfort, wie er aus dem Tapestry-Framework bekannt
 ist und wie er auch in der XML-Variante der Konfiguration in den 
\noun on
SpringContributions
\noun default
 umgesetzt ist, erreichen, so müsste das grundsätzliche Prinzip des Eingriffs
 in den Spring-Kofigurationsablauf umgestellt werden.
 Anstelle eines Beandefinition Postprozessing, über das die Contribution-Kofigur
ation im Moment umgesetzt ist, müsste man in den eigentlichen Prozess der
 Spring Beankonfiguration eingreifen (siehe Absatz 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Eingriff-während-der-Registrierung_Variante-1"

\end_inset

).
 Dies würde bedeuten, dass man den gesamten bereits von 
\shape italic
Spring
\shape default
 umgesetzten Prozess der Beandefinition-Erstellung für Java-Konfigurationen
 erneut selbst entwickeln müsste.
 Hierbei wäre es dann möglich, das Augenmerk darauf zu legen, eigens für
 die Contribution-Kofiguration geeignete Konfigurationsmethoden zu entwickeln,
 mit denen es auch möglich wäre, mehrere Beandefinitionen auf einmal anzulegen
 und dann an einen Contribution-Container zu übergeben.
\end_layout

\begin_layout Standard
Bei dieser Verbesserung müsste man aber mehrere Problemstellungen überwinden.
 Da der Prozess der Erstellung von Beandefinitionen nicht trivial ist, wäre
 es hier anzuraten, möglichst viel Funktionalität von 
\shape italic
Spring
\shape default
 wiederzuverwenden, beziehungsweise zu erweitern.
 Leider eignet sich die derzeitige Implementierung des Fameworks in dem
 Bereich nicht gut zur Wiederverwendung oder Erweiterung.
 Da die derzeitige Codebasis im Spring-Framework hier leider nicht leicht
 adaptierbar ist, müsste also sehr viel Funktionalität erneut geschrieben
 werden.
 Dadurch entsteht dann aber auch die Notwendigkeit, in diesem neuen Code,
 mit jeder neuen Spring-Version, die von den 
\noun on
SpringContributions
\noun default
 unterstützt werden soll, auf eventuelle Änderungen in der 
\shape italic
Spring
\shape default
 eigenen Erstellung von Beandefinitionen zu achten, und derartige Änderungen
 ebenso umzusetzen.
\end_layout

\begin_layout Subsection*
Konfigurierbarkeit der Sichtbarkeit für Contribution-Container-Beans
\begin_inset CommandInset label
LatexCommand label
name "sub:Konfigurierbarkeit-der-Sichtbarkeit"

\end_inset


\end_layout

\begin_layout Standard
In 
\shape italic
Spring
\shape default
 werden alle Bean-Objekte durch sogenannte 
\family sans
\shape italic
BeanFactory
\family default
\shape default
 Klassen erstellt.
 Eine 
\family sans
\shape italic
BeanFactory
\family default
\shape default
 liefert also auf Wunsch eine Instanz des gewünschten Beans.
 Da es sich bei Beans ja auch nur um gewöhnliche Java-Objekte handelt, sind
 hier augenscheinlich zwei grundsätzlich unterschiedliche Strategien möglich.
 Zum einen kann die 
\family sans
\shape italic
BeanFactory
\family default
\shape default
 immer eine neue Instanz erstellen und dem jeweiligen Konsumenten übergeben,
 wenn eine Anfrage nach einem Bean eines bestimmten Typs gemacht wird.
 Zum anderen ist es möglich, dass die 
\family sans
\shape italic
BeanFactory
\family default
\shape default
 einmalig eine Instanz des Beans erstellt und diese Instanz bei jedem Aufruf
 durch einen Konsumenten an diesen weitergibt.
\end_layout

\begin_layout Standard
Ein Konsument eines Beans erhält also im ersten Fall immer eine 
\begin_inset Quotes eld
\end_inset

eigene
\begin_inset Quotes erd
\end_inset

 Instanz des gewünschten Beans.
 Alle Zugriffe auf dieses Bean-Objekt liegen nun einzig in der Hand des
 Konsumenten.
 Diese Art der Sichtbarkeit (Scope) ist der Standardfall in 
\shape italic
Spring
\shape default
 und wird hier mit dem 
\begin_inset Quotes eld
\end_inset

Prototype Scope
\begin_inset Quotes erd
\end_inset

 bezeichnet.
 Bei der zweiten Möglichkeit existiert nur ein Bean-Objekt von einem bestimmten
 Typ im gesamten IOC-Container.
 Alle Konsumenten dieses Beans, haben also Zugriff auf ein und dasselbe
 Objekt und dessen 
\begin_inset Quotes eld
\end_inset

globalen
\begin_inset Quotes erd
\end_inset

 Zustand.
 Diese Variante der Sichtbarkeit wird in 
\shape italic
Spring
\shape default
 als 
\begin_inset Quotes eld
\end_inset

Singleton Scope
\begin_inset Quotes erd
\end_inset

 bezeichnet.
\end_layout

\begin_layout Standard
Welchen Scope man in einer Beandefinition konfiguriert, muss je nach Anwendungsf
all entschieden werden und hat damit Einfluss auf die Implementierung als
 auch auf die Verwendung des Beans.
 Bei der Verwendung der 
\noun on
SpringContributions
\noun default
 hat die Sichtbarkeit natürlich auch eine große Bedeutung.
 Hier ist es wichtig wie die Sichtbarkeit der Contribution-Container-Beans
 konfiguriert ist.
 Davon hängt es nämlich ab, ob ein Contribution-Container als einzelnes
 Objekt unter allen Konsumenten geteilt wird oder nicht.
 Der Unterschied ist deshalb wichtig, weil im Falle des Singleton Scope,
 ein Konsument nicht die alleinige Kontrolle über den Zustand des Containers
 und seiner Elemente inne hat.
 Es kann also vorkommen, dass die Art, als auch die Anzahl der Elemente
 in einem Container zur Laufzeit von anderen Konsumenten geändert werden.
 Dies kann, je nach Anwendungsfall, erwünscht oder auch nicht erwünscht
 sein.
\end_layout

\begin_layout Standard
In der derzeitigen Umsetzung der 
\noun on
SpringContributions
\noun default
, wird jeder Contribution-Container mit dem Singleton Scope angelegt.
 Der Benutzer der Komponente hat im Moment keine Möglichkeit in diese Konfigurat
ion einzugreifen.
 Ein Prototype Scope ist also derzeit nicht einstellbar.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Java:-Mögliche-Scope-Konfiguration"

\end_inset

(Java) Mögliche Scope-Konfiguration für Contribution-Listen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

// Java-Konfiguration mit Scope-Definition:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Contribution(to="prototypeContainer", scope="prototype")
\end_layout

\begin_layout Plain Layout

@Bean
\end_layout

\begin_layout Plain Layout

public SomeElement someElement()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return new SomeElementImpl();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset

Damit der Scope doch durch den Anwender festlegbar wird, müssten beiden
 Konfigurationsarten (XML, Java) für beide möglichen Contribution-Container
 (Liste, Map) um die Einstellung des Scope erweitert werden.
 Listings 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:XML:-Mögliche-Scope-Konfiguration"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Java:-Mögliche-Scope-Konfiguration"

\end_inset

 zeigen am Beispiel der Contribution-Liste wie das in den beiden Konfigurationsv
arianten aussehen könnte.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:XML:-Mögliche-Scope-Konfiguration"

\end_inset

(XML) Mögliche Scope-Konfiguration für Contribution-Listen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// XML-Konfiguration mit Scope Definition:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Konfiguration für XML-Element 'contribution-ref'
\end_layout

\begin_layout Plain Layout

<bean id="prototypeContributionConsumer" class="PrototypeContributionConsumerImp
l">
\end_layout

\begin_layout Plain Layout

	<constructor-arg>
\end_layout

\begin_layout Plain Layout

		<ctr:contribution-ref name="prototypeContainer" scope="prototype" />
\end_layout

\begin_layout Plain Layout

	</constructor-arg> 	
\end_layout

\begin_layout Plain Layout

</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Konfiguration für XML-Element 'contribution'
\end_layout

\begin_layout Plain Layout

<bean name="SomeElement" class="SomeElementImpl" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<ctr:contribution to="prototypeContainer" scope="prototype" >
\end_layout

\begin_layout Plain Layout

	<ctr:entry name="SomeElement" ref="SomeElement" />
\end_layout

\begin_layout Plain Layout

</ctr:contribution>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Konfiguration für XML-Element 'contribute'
\end_layout

\begin_layout Plain Layout

<bean name="AnotherElement" class="AnotherElementImpl" >
\end_layout

\begin_layout Plain Layout

	<ctr:contribute to="prototypeContainer" scope="prototype" />
\end_layout

\begin_layout Plain Layout

</bean>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "bibtex/literatur"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
