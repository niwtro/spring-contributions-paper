#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\usepackage{suetterl}
\usepackage[T1]{fontenc}
\usepackage{oldgerm}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset Quotes eld
\end_inset

Contribution Funktionalität
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Title
Objektorientierte, modulare Programmierung mit erweiterter Dependency Injection
\end_layout

\begin_layout Author
Ortwin Probst - 0026402
\end_layout

\begin_layout Abstract
Diese Arbeit beschäftigt sich mit Dependency Injection als einer Methode
 zur Unterstützung von modularer Softwareentwicklung.
 Im Detail werden die Vorteile des erweiterten Dependency Injection Mechanismus
 des Java-Frameworks Tapestry beleuchtet und als Inspiration für eine praktische
 Erweiterung des Java-Frameworks Spring herangezogen.
 Das Resultat ist die konkrete Umsetzung dieser Erweiterung in einem eigenen
 Spring Modul.
 Dabei werden parallele zwei unterschiedliche Konfigurationsmechanismen
 mit äquivalentem Funktionsumfang angeboten, um die Anforderungen innerhalb
 des Spring Frameworks zur Gänze erfüllen zu können.
 Beide Konfigurationsmechanismen werden im Detail auf deren Unterschiede
 in der Implementierung verglichen und in ihrer Anwendung gegenübergestellt.
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Erweitern
\end_layout

\end_inset


\end_layout

\begin_layout Dedication
Widmung
\end_layout

\begin_layout Dedication
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO Ich widme diese Arbeit allen die es mir ermöglicht haben in meinem
 Studium bis zu diesem Punkt zu kommen.
 Meinen Eltern für die Freiheit, die sie mir geschenkt haben.
 Meinen Betreuer Ao.Univ.Prof.
 Mag.Dr.
 Helge Hagenauer von der Universität Salzburg für seine sehr geschätzte
 Unterstützung und die hilfreiche Kritik.
 Meinem Betreuer Dipl.
 Ing.
 Christian Köberl auf Seiten der Porsche Informatik, für die Hilfe bei der
 Themenfindung, die Fachliche Unterstützung und die Entwicklung der Codebasis.
 Und meinem Studienkollegen Stefan Esterer für die Austauschmöglichkeit
 und die regelmäßige Portion Motivation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Einführung
\end_layout

\begin_layout Section*
Motivation
\end_layout

\begin_layout Standard
Meine Diplomarbeit fällt thematisch in den Bereich Modulare Softwareentwicklung
 für Java Enterprise Anwendungen.
 Im Detail stehen Konfigurationsmöglichkeiten für über Module verteilte
 Services zur Diskussion (distributed configuration).
 Dabei beschäftige ich mich im Speziellen mit der sogenannten 
\begin_inset Quotes eld
\end_inset

Contribution
\begin_inset Quotes erd
\end_inset

 Funktionalität 
\begin_inset CommandInset citation
LatexCommand cite
key "tapestry-iocConfig"

\end_inset

.
 Dies ist eine Service Konfigurationsmöglichkeit des IOC Containers, der
 das Kernstück des Apache Tapestry Frameworks 
\begin_inset CommandInset citation
LatexCommand cite
key "tapestry-home"

\end_inset

, einem Java Framework für Web-Anwendungen, bildet.
 Ziel ist es den Contribution Mechanismus auf das Spring Framework, einem
 weiteren auf 
\begin_inset Quotes eld
\end_inset

Inversion Of Control
\begin_inset Quotes erd
\end_inset

 (IOC) basierenden Java Framework, zu übertragen.
\end_layout

\begin_layout Standard
Software Module werden im Folgenden nicht als Werkzeug zur Anwendungsmodellierun
g sondern mehr als konkretes Mittel für die Programmierung mit einer Objektorien
tierten Programmiersprache betrachtet.
 Im Speziellen kann diese Art der Verwendung von Modulen auch als weiteres
 Mittel zur Kapselung in der Objektorientierten Entwicklung betrachtet werden.
\end_layout

\begin_layout Section*
Theorieteil
\end_layout

\begin_layout Standard
Der theoretische Teil der Arbeit soll sich, ausgehend von einer Betrachtung
 zu modularem Softwaredesign im Bereich von Java Enterprise Anwendungen,
 genauer mit den zur Verfügung stehenden Techniken für Modulare Entwicklung
 auseinandersetzen.
 Dabei solle einerseits die klassische IOC Technik der Dependency Injection
 sowie auch die Möglichkeit der Contributions und deren Nutzen erklärt und
 gezeigt werden.
 Im Detail wird dabei auf die Konfiguration der beiden IOC-Frameworks Tapestry
 und Spring eingegangen werden.
\end_layout

\begin_layout Section*
Praxisteil
\end_layout

\begin_layout Standard
Mein Ausgangspunkt ist das Interesse der Porsche Informatik, eine bestehende,
 modular entworfene und auf dem Apache Tapestry Framework basierende Java
 Webapplikation, auf das in der Firma zum Standard erklärte IOC Framework
 Spring umzustellen.
 Um einen hohen Grad an Modularität zu erreichen, wurde die Webapplikation
 ursprünglich auf dem Open Source Framework Tapestry 5 aufgebaut.
 Diese Framework bietet einige Techniken die ein modulares Programmieren
 erleichtern.
\end_layout

\begin_layout Standard
Konkret bietet das Framework Methoden, die es ermöglichen, die Konfiguration
 eines Services aus verschiedenen, von einander unabhängigen Modulen heraus
 zu erstellen.
 Dadurch können die gesamte Anwendung und all ihre Services, nur durch das
 Einhängen eines weiteren Moduls in den Classpath, um neue Funktionalität
 erweitert werden.
 Diese Technik wird in Tapestry 5 als Contribution bezeichnet.
\end_layout

\begin_layout Standard
Als anschauliches Beispiel kann man sich den Menü-Service einer Webanwendung
 vorstellen.
 Das Service dient dazu, automatisch ein Auswahlmenü über alle zur Verfügung
 stehenden Funktionen im Benutzerinterface bereit zu stellen.
 Dieses Service wird in Tapestry 5 aus der zusammengeführten Servicekonfiguratio
n aller Module aufgebaut.
 D.h.
 jedes Modul 
\begin_inset Quotes eld
\end_inset

contributet
\begin_inset Quotes erd
\end_inset

 so zu sagen seinen Teil der Menü Service Konfiguration.
 Durch das Ein- oder Aushängen eines Moduls, wird die Anwendung dann automatisch
 um dessen Menüpunkte erweitert oder verringert.
\end_layout

\begin_layout Standard
Das Ziel ist es nun zuerst die in Tapestry 5 vorhandene Technik des Contribution
s Mechanismus für das Spring Framework zu adaptieren und danach auf dieser
 Basis zusätzlich das Tapestry 
\begin_inset Quotes eld
\end_inset

StrategyBuilder
\begin_inset Quotes erd
\end_inset

-Service ebenfalls für Spring bereit zu stellen.
 Das Ergebnis dieser Arbeit soll ein eigenes Java Modul mit dem Namen
\noun on
 SpringContributions
\noun default
 sein, mit dem die bestehende Webapplikation so umgestellt werden kann,
 dass anstelle des Tapestry 5 Contribution Systems das neue 
\noun on
SpringContributions
\noun default
 System verwendet wird.
\end_layout

\begin_layout Standard
Da es in Spring zwei unterschiedliche Wege der Konfiguration gibt, ist es
 auch Ziel des Praxisteils je eine Lösung für diese beiden unterschiedlichen
 Wege umzusetzen.
 Es wird ein Augenmerk darauf gelegt werden, im Bezug auf Funktionsumfang
 und die Art der Anwendung, auf Gleichheit bzw.
 Ähnlichkeit der beiden Lösungen zu achten.
 Ebenso soll die Ähnlichkeit zum Vorbildsystem berücksichtigt werden und
 besonders auf Unterschiede die sich aus der Implementierung oder konzeptionelle
n Abweichungen von Tapestry zu Spring ergeben eingegangen werden.
 Probleme die sich auf dem Weg zu diesen Zielen ergeben sollen aufgezeigt
 und erläutert werden.
\end_layout

\begin_layout Chapter
Modulare Programmierung
\end_layout

\begin_layout Standard
In allen hoch automatisierten Industriellen Fertigungsbereichen ist der
 Ansatz der Modularisierung heute nicht mehr wegzudenken.
 Ein Paradebeispiel hierfür ist die Autoindustrie und ihr erfolgreicher
 Einsatz der Komponentenbauweise.
 Ohne die Komponentenbauweise wäre die Nachfrage nach Automobilen wahrscheinlich
 schon seit längerem nicht mehr zu decken.
\end_layout

\begin_layout Standard
Seit vielen Jahren wird auch in der Informatik versucht, das Konzept der
 Modularisierung auch in der Software Entwicklung anzuwenden.
 Das Ziel war es auch hier Softwarekomponenten zu bauen, die sich durch
 ihre Eigenschaften dazu eignen in unterschiedlichsten Kompositionen als
 neue gesamte Anwendung miteinander zusammen zu arbeiten.
 Mittlerweile sind Softwarekomponenten in der Form von Frameworks sehr verbreite
t und erfreuen sich auch großer Beliebtheit und Verwendung.
\end_layout

\begin_layout Standard
Liest man von Modularer Software Entwicklung, so ist der Blickwinkel meist
 der eines Anwendungsentwicklers.
 Hier hat man eine Sichtweise, die ausgehend von der Applikation als Große
 Einheit versucht deren modularisierten inneren Aufbau zu betrachten.
 Ich verwende hier mit Modularer Programmierung absichtlich einen leicht
 anderen Begriff für den inhaltlich gleichen Bereich der Informatik, um
 auf den etwas anderen Fokus dieser Arbeit hinzuweisen.
 In beiden Fällen beschäftigen wir uns mit Software Modulen, wenn ich aber
 Modulare Programmierung sage, dann meine ich nicht den Blickwinkel des
 Anwendungsentwicklers, sondern den des Modulentwicklers.
 Diese Sichtweise beschäftigt sich in ihrer Betrachtung mit der kleinen
 Einheit des Moduls, und deren Zusammenspiel mit anderen Modulen.
 Der Fokus liegt also auf den Modulen und nicht auf der Applikation.
\end_layout

\begin_layout Section
Software Modul bzw.
 Komponente
\end_layout

\begin_layout Paragraph*
Definition (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "Szyperski:1998"

\end_inset

)
\end_layout

\begin_layout Standard
Ein Software Modul ist eine nach außen hin über Schnittstellen definierte
 und gekapselte Einheit, die zur Kombination mit anderen Modulen vorgesehen
 ist.
 Die Kapselung bezieht sich dabei sowohl auf eine Zusammenfassung des Moduls
 in einer binären Einheit, als auch auf einen thematisch abgegrenzten Bereich.
 Die konkrete innere Struktur und Implementierung ist für den Benutzer irrelevan
t.
 Es kommt natürlich vor, dass ein Modul die zur Verfügung gestellte Funktionalit
ät nur in Zusammenarbeit mit anderen Modulen bewerkstelligen kann.
 Diese Abhängigkeiten sind jedoch nicht auf konkrete Implementierungen bezogen,
 sondern werden auch über Schnittstellen abgebildet.
 Das heißt ein Software Modul ist für sich genommen eine unabhängige Einheit.
 Die positiven Eigenschaften die Softwaremodule (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Positive-Eigenschaften-von-Software-Modulen"

\end_inset

) mit sich bringen, entstehen großteils aus diesem Aspekt der Unabhängigkeit
 von anderen konkreten Implementierungen.
 Da sich Module, wie sie im folgenden Kontext verwendet werden in ihren
 Eigenschaften, nach Szyperskis Definition, nicht von Komponenten unterscheiden,
 werden im Folgenden beide Begriffe als Synonyme verwendet.
\end_layout

\begin_layout Subsection
Service, Service Provider und Consumer
\end_layout

\begin_layout Subsubsection*
Definition
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO gibt es hier eine Quelle?
\end_layout

\end_inset

In dieser Arbeit wird der Begriff 
\begin_inset Quotes eld
\end_inset

Service
\begin_inset Quotes erd
\end_inset

 bzw.
 
\begin_inset Quotes eld
\end_inset

Dienst
\begin_inset Quotes erd
\end_inset

 als Zusammenfassung für, über Schnittstellen definierte und zur Verfügung
 gestellte Funktionalität verwendet.
 In der Informatik wird der Begriff häufig auch im Zusammenhang mit Verteilten
 Systemen gebraucht und assoziiert eventuell einen verteilten Kontext.
 Deshalb möchte ich hier explizit darauf hinweisen, dass im Bereich dieser
 Arbeit ein Service keine Eigenschaften für eine verteilte Anwendung mit
 sich bringt.
\end_layout

\begin_layout Standard
Da der Kontext in dem wir uns hier befinden, die objektorientierte Programmierun
g ist, verbirgt sich hinter einem Service im Grunde immer ein mehr oder
 weniger komplexes Objekt.
 Die Unterscheidung von einem Service zu einem normalen Objekt ist allerdings,
 dass die Funktionalität eines Service Objekts immer über ein Interface
 definiert sein muss.
\end_layout

\begin_layout Standard
Soll ein Service nicht nur innerhalb eines Moduls sondern auch über Modulgrenzen
 zur Verfügung gestellt werden, so muss natürlich die Interface Definition
 für andere Module sichtbar sein.
 Zur Darstellung der Verwendungsbeziehung eines Service werde ich die Begriffe
 Service Provider (Service) und Service Consumer (Konsument) verwenden.
\end_layout

\begin_layout Subsection
Positive Eigenschaften von Software Modulen
\begin_inset CommandInset label
LatexCommand label
name "sub:Positive-Eigenschaften-von-Software-Modulen"

\end_inset


\end_layout

\begin_layout Standard
Ein Softwaresystem in einem Modularen Design zu entwerfen, ist ein gutes
 Mittel um Wiederverwendbarkeit (reusability), Austauschbarkeit und Erweiterbark
eit (plugability), erleichterte Wartung (maintainability) und Testbarkeit
 (testability) zu ermöglichen.
\end_layout

\begin_layout Standard
David Parnas
\begin_inset CommandInset citation
LatexCommand cite
key "Parnas:1972"

\end_inset

spricht von folgenden drei Vorteilen die durch modulare Programmierung entstehen.
\end_layout

\begin_layout Enumerate
Verringerung der Entwicklungszeit, da Entwicklergruppen ohne viel Kommunikation
 getrennt an Modulen arbeiten können.
 
\end_layout

\begin_layout Enumerate
Steigerung der Flexibilität, durch die Möglichkeit Änderungen in einem Modul
 vor zu nehmen, ohne dabei andere Module anpassen zu müssen.
 
\end_layout

\begin_layout Enumerate
Erleichterung der Verständlichkeit des Gesamtsystems, und somit auch die
 Unterstützung eines besseren Designs.
\end_layout

\begin_layout Enumerate
Erleichterung im Testen durch die Trennung von Interface, Implementierung
 und Konfiguration.
\end_layout

\begin_layout Subsection
Modulentwicklung vs.
 Zusammenstellung modularer Anwendungen
\end_layout

\begin_layout Standard
Betrachtet man die modulare Softwareentwicklung, so muss man dabei zwei
 Bereiche klar voneinander abgrenzen.
 Zum einen die Entwicklung eines Softwaremoduls und zu anderen der Aufbau
 einer Modularen Anwendung.
\end_layout

\begin_layout Standard
Die Entwicklung eines Moduls ist die Aufgabe eines Modulentwicklers.
 Dieser ist zuständig für die interne Implementierung und die Definition
 der Modulschnittstellen.
\end_layout

\begin_layout Standard
Der Aufbau einer modularen Anwendung hingegen wird durch einen Anwendungsentwick
ler durchgeführt und beschäftigt sich nicht mehr mit der Implementierung,
 sondern mit der Auswahl, der Kombination und der Konfiguration mehrerer
 Komponenten zu einer bestimmten Anwendung.
\end_layout

\begin_layout Section
Grundvoraussetzungen für Modularisierung
\end_layout

\begin_layout Standard
Auf Implementierungsebene gibt es mehrere Voraussetzungen, die zur Entwicklung
 von Komponenten notwendig sind.
\end_layout

\begin_layout Subsubsection*
Lose Kopplung
\end_layout

\begin_layout Standard
In der klassischen Objektorientierung entstehen schon zum Zeitpunkt der
 Programmierung Abhängigkeiten zwischen Objekten.
 Benötigt zum Beispiel der Konstruktor bzw.
 die Initialisierungsmethode einer Klasse eine Konkrete andere Klasse, so
 entsteht hier eine feste Kopplung 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset

 hin auf eine ganz bestimmte Implementierung.
 Für die Entwicklung von Services einer Komponenten muss es aber möglich
 sein, Klassen zu schreiben, deren Laufzeitverhalten nicht schon zum Implementie
rungszeitpunkt festgelegt ist 
\begin_inset CommandInset citation
LatexCommand cite
key "Fabresse:2012"

\end_inset

.
 Es ist also nötig die Implementierung auf Schnittstellendefinitionen aufzubauen
 um die Funktionalität zwar zu definieren, aber von einer konkreten Implementier
ung unabhängig zu halten.
 So kann die Voraussetzung geschaffen werden, damit Komponenten erst zum
 Zeitpunkt der Softwareverteilung (deployment), also zum Installationszeitpunkt
 der Anwendung, oder sogar erst zum Ausführungszeitpunkt eine konkrete Verbindun
g untereinander aufbauen.
 So ist es auch für eine Anwendungsentwickler, der keinen Einfluss auf die
 Implementierung einzelner Komponenten hat, möglich mehrere Softwarekomponente
 zu einer Anwendung zu kombinieren.
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Rückverweis hierher wenn Details zur Testability und Unittests geschrieben
 sind
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Kapselung
\end_layout

\begin_layout Standard
Um eine Lose Kopplung zu ermöglichen, benötigt man Mittel zur Kapselung
 von Programmeinheiten.
 In der objektorientierten Programmierung ist der Begriff Kapselung, für
 das Zusammenfassen von Funktionalität in von außen nur über Schnittstellen
 definierte und angreifbare Einheiten, definiert 
\begin_inset CommandInset citation
LatexCommand cite
key "Snyder:1986:EncapsulationAndInheritance"

\end_inset

.
 Wenn ich hier im Zusammenhang mit der modularen Programmierung von Kapselung
 spreche, so meine ich hier die Gleiche Definition.
 Im modularen Kontext verschiebt sich nur die Betrachtungsebene der Kapselung
 von der Objektebene auf die des Moduls.
 Module kapseln also ihre Funktionalität in sich und bilden somit eine zusammeng
ehörige, nur durch Interfaces nach außen definierte und angreifbare Einheit.
\end_layout

\begin_layout Subsubsection*
Schnittstellen
\end_layout

\begin_layout Standard
Betrachtet man die Lose Kopplung und Kapselung als Grundvoraussetzung für
 Modularität, so folgt daraus die Möglichkeit von Schnittstellendefinitionen
 als weitere Grundvoraussetzung.
 Die Möglichkeit von Schnittstellen bzw.
 Interfaces ist auf Klassenebene prinzipiell in allen Objektorientierten
 Sprachen gegeben.
 Mit diesen ersten drei Grundvoraussetzungen ist es in der objektorientierten
 Programmierwelt möglich Softwaremodule zu entwickeln.
\end_layout

\begin_layout Subsubsection*
Bereitstellung und Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Bereitstellung-und-Konfiguration"

\end_inset


\end_layout

\begin_layout Standard
Sind die nötigen Schnittstellen einmal definiert und sind die dazugehörigen
 Modulimplementierungen vorhanden, so ist das nächste zu lösende Problem
 die Bereitstellung der Services für andere Module.
 Es muss also ein Weg gefunden werden eine bestimmte Interface Implementierung
 überall dort zur Laufzeit zur Verfügung zu stellen, wo das Interface verwendet
 wird.
\end_layout

\begin_layout Standard
Dieses Problem kann durch Konfigurationsmechanismen gelöst werden.
 Man benötigt also eine von den Modulimplementierungen losgelöste Konfiguration,
 in der im einfachsten, aber nicht unbedingt elegantesten Fall, direkt alle
 Service Instanzen modulübergreifend für die gesamte Anwendung angelegt
 und initialisiert werden.
 Diese Konfiguration bildet dann zusammen mit allen zugehörigen Modulen
 eine Anwendung.
\end_layout

\begin_layout Standard
Es gibt verschiedenste Ansätze, um die Konfiguration möglichst elegant zu
 lösen.
 Einige davon werden im Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Konfiguration"

\end_inset

 noch genauer beleuchtet werden.
 Alle Ansätze haben dabei aber die Gemeinsamkeit, dass sie sich auf einen
 zentralen Dienst stützen.
 Dieser Dienst bietet zum einen eine Möglichkeit zur Serviceregistrierung,
 mittels der jedes Modul die Zuordnung von Service Interface zur moduleigenen
 Implementierung selbst als Konfiguration durchführen kann.
 Zum anderen stellt er eine Möglichkeit dar, die registrierten Services
 abzurufen und somit zu verwenden.
 Dienste die diesen Zweck erfüllen werden oft mit dem Begriff 
\begin_inset Quotes eld
\end_inset

Service Registry
\begin_inset Quotes erd
\end_inset

 bezeichnet.
\end_layout

\begin_layout Standard
Je nach Flexibilitätsgrad ergeben sich unterschiedliche Zeitpunkte zu denen
 die Anwendungskonfiguration zur Verwendung kommt.
 Beginnend bei der einfachsten Lösungen über direkte programmatische Instanziier
ung und Initialisierung, die also schon zur Kompilierzeit die Anwendungszusammen
stellung genau festlegt.
 Die konkrete Servicelandschaft der Anwendung erst bei der Anwendungsinstallatio
n festzulegen, kann zum Beispiel über interne, also sich innerhalb des physische
n Anwendungspakets befindlichen, Konfigurationsfiles oder Klassen, im Zusammensp
iel mit Dynamischen Assemblerdiensten (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Dependency-Injection"

\end_inset

) gelöst werden.
 Liegen die Konfigurationsfiles oder der Konfigurationscode außerhalb des
 physischen Anwendungspakets, so verschiebt sich der Zeitpunkt der Auflösung
 auf den Systemstart.
\end_layout

\begin_layout Standard
Es gibt sogar Ansätze zur Konfiguration von modularen Anwendungen, die eine
 Einflussnahme auf Modulabhängigkeiten und Service Konfigurationen noch
 zur Laufzeit ermöglichen.
 Ein Komponentensoftwaresystem zur Laufzeit anzupassen, d.h.
 neue Komponenten einzufügen, andere zu entfernen und gewisse Verbindungen
 umzustellen, ist eine Eigenschaft die wegen des Aufwands nicht alle komponenten
orientierten Entwicklungsansätze verfolgen.
 Als Beispiel für die Anpassbarkeit zu Laufzeit kann hier OSGI, als Spezifikatio
n einer Modul und Serviceplattform für Java, erwähnt werden.
 OSGI ist unter anderem im später noch genauer beschriebenen Spring Framework
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Spring-Konfiguration"

\end_inset

) umgesetzte.
 Die Möglichkeit der Anwendungskonfiguration zur Laufzeit, soll hier aber
 nur der Vollständigkeit wegen erwähnt sein und wird im Weiteren nicht mehr
 genauer behandelt.
\end_layout

\begin_layout Section
Modularisierung mit 
\begin_inset Quotes eld
\end_inset

Inversion of Control
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Moderne Java Frameworks zur Unterstützung von modularer Softwareentwicklung
 bieten oftmals IOC Container an.
 Diese Container sind spezielle Formen von Serviceregistries (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Bereitstellung-und-Konfiguration"

\end_inset

) mit deren Hilfe eine Entkopplung von Service Consumer und Provider realisiert
 werden kann.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Ergänzung um Alternativen zu IOC Container Frameworks (siehe ev 1997-Johnso
n-Frameworks.pdf)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Inversion of Control
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
„Inversion of Control“ kurz IOC bezeichnet ganz allgemein die Umkehrung
 eines Kontrollflusses.
 Kontrollflussumkehrung ist aber ein sehr allgemeines Prinzip und wird somit
 auch in verschiedensten Ausprägungen in der Softwareentwicklung verwendet.
 Die für den aktuellen Kontext wichtige Ausprägungsform von IOC als 
\begin_inset Quotes eld
\end_inset

Dependency Injection
\begin_inset Quotes erd
\end_inset

 wird im nächsten Abschnitt genauer beschrieben (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Dependency-Injection"

\end_inset

).
 IOC und das Dependency Injection Pattern sind Methoden deren Anwendung
 meist direkt auf Objektebene verwendet wird.
 Beide Prinzipien können aber ohne weiteres auch auf der Komponenten Ebene
 ihre Anwendung finden.
\end_layout

\begin_layout Paragraph*
Geschichte
\end_layout

\begin_layout Standard
Martin Fowler 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler:2005"

\end_inset

 liefert eine eine Erklärung und Informationen zur Herkunft des Begriffs
 
\begin_inset Quotes eld
\end_inset

Inversion of Control
\begin_inset Quotes erd
\end_inset

 in der Informatik.
 So findet sich bei Ralph E.
 Johnson 
\begin_inset CommandInset citation
LatexCommand cite
key "Johnson:1988"

\end_inset

 eine frühe Verwendung des Begriffes, wenn die Autoren selbst, wieder auf
 einen anderen, nicht bekannten Schöpfer des Begriffes verweisen.
 Mit dem 
\begin_inset Quotes eld
\end_inset

Hollywood Principle
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Sweet:1985"

\end_inset

 existierte schon seit 1985 ein weiterer Begriff für das selbe Prinzip auf
 den auch Erich Gamma et.al.
 in ihrem bekannten Buch zu Design Patterns 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset

 Bezug nehmen 
\begin_inset Quotes eld
\end_inset

Don'tcall us, we'll call you
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Das Pico Container Framework liefert auf seiner Homepage 
\begin_inset CommandInset citation
LatexCommand cite
key "Pico:IOC-History"

\end_inset

weitere Erläuterungen zur Geschichte des IOC Begriffs.
 Als Wegbereiter des heutigen IOC Begriffs werden hier Robert C.
 Martin, der unter der Bezeichnung 
\begin_inset Quotes eld
\end_inset

Dependency Inversion
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Martin:1996"

\end_inset

 über die Umkehrung von Abhängigkeiten zur Erreichung von unabhängigen Modulen
 schreibt, Michael Mattesson 
\begin_inset CommandInset citation
LatexCommand cite
key "Mattsson96object-orientedframeworks"

\end_inset

, Brian Foote und Joseph Yoder 
\begin_inset CommandInset citation
LatexCommand cite
key "Foote:1998-BallOfMud"

\end_inset

 sowie Ralph E.
 Johnson und Brian Foote 
\begin_inset CommandInset citation
LatexCommand cite
key "Johnson:1998-DesigningReusableClasses"

\end_inset

 erwähnt.
 Weiters finden hier die ersten Umsetzungen des IOC Prinzips mit den Projekten
 Apache Avalon und OSGi ihre Erwähnung.
 Folgende Grafik soll die Historie von Fowler und die Timeline von Pico
 Container zusammenführen und ergänzen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Meilensteine des IOC Pattern 
\begin_inset CommandInset label
LatexCommand label
name "fig:Meilensteine-des-IOC"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace defskip
\end_inset


\begin_inset Graphics
	filename pics/IOC Timeline.eps
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Bedeutung
\end_layout

\begin_layout Standard
Die allgemeine Bedeutung von IOC als Kontrollfluss Umkehr beschreibt Fowler
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler:2004"

\end_inset

 am Beispiel vom Wechsel von einer Kommandozeilen gesteuerten Anwendung,
 die den Benutzer Schritt für Schritt nach Eingaben fragt, hin zu einem
 User Interface Steuerung, bei der das UI Benutzereingaben entgegen nimmt
 und diese an die Anwendung weiterleitet.
 Hier wurde also der ursprüngliche Kontrollfluss umgekehrt.
\end_layout

\begin_layout Standard
Der IOC Begriff wird aber nicht immer so allgemein betrachtet.
 Das Pico Container Framework zum Beispiel verwendet den Begriff als Zusammenfas
sung dreier ganz konkreter Techniken (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Pico-Container"

\end_inset

).
\end_layout

\begin_layout Standard
Das allgemeine IOC Prinzip kann als eine Haupteigenschaft von Frameworks
 betrachtet werden.
 Frameworks haben im Gegensatz zu einfachen Programmbibliotheken die Kontrolle
 über ihre Funktionalität großteils selbst inne.
 Eine Programmbibliothek stellt lediglich Funktionalität für einen Konsumenten
 zur Verfügung, die Kontrolle über die Funktion geht hier aber vom Konsumenten
 aus.
 Ein Framework stellt zwar auch Funktionalität zur Verfügung, im Gegensatz
 zur Programmbibliothek wird hier aber mit verschiedenen Methoden (Subclassing,
 Plugins) das eigene Programmverhalten in das Framework eingebunden.
 Das Verhalten des Frameworks wird so zu sagen für die eigenen Anwendungsbedürfn
isse konfiguriert.
\end_layout

\begin_layout Standard
Dieses Prinzip der externen Konfiguration des Programmverhaltens und der
 gleichzeitigen Beibehaltung der eigenen Kontrolle des Frameworks über die
 Funktionen an sich, kann nicht nur auf Frameworks, sondern auch auf Module
 angewandt werden.
 Ein Modul, wie zum Beispiel ein Verrechnungsmodul, kapselt einen bestimmten
 Fachlichen Aspekt und die dazu bereitgestellte Funktionalität (Rechnungserstell
ung, Stornierung, ...), das konkrete Verhalten im jeweiligen Anwendungskontext
 des Moduls, muss jedoch von eben diesem Anwendungskontext als Konfiguration
 bereitgestellt werden.
 D.h.
 die Services eines Moduls werden von außen konfiguriert, behalten selbst
 aber die Kontrolle über ihre primäre Funktionalität.
 Um derartige Services realisieren und in einem Modul kapseln zu können,
 muss es möglich sein die Funktionalität eines Services von dessen konkreten
 Konfiguration zu entkoppeln.
 Dieses Entkoppeln, als die Möglichkeit zum Auflösen von konkreten Abhängigkeite
n, ist also eine Hauptvoraussetzung für Modulares Programmieren.
\end_layout

\begin_layout Standard
In der Objektorientierten Programmierwelt ist IOC eine der wichtigsten Techniken
 um eben diese Entkopplung zu erreichen.
 Auch wenn hier im Allgemeinen oft von IOC gesprochen wird, so ist im Konkreten
 oft Dependency Injection, eine ganz spezielle Form von IOC gemeint.
\end_layout

\begin_layout Subsection
Dependency Injection
\begin_inset CommandInset label
LatexCommand label
name "sub:Dependency-Injection"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Dependency Injection
\begin_inset Quotes erd
\end_inset

 (DI) ist ein von Martin Fowler
\begin_inset CommandInset citation
LatexCommand citet
key "Fowler:2004"

\end_inset

 genauer beschriebenes Pattern für die objektorientierte Programmierung,
 mit dessen Hilfe es möglich wird, einen sogenannten Plugin Mechanismus
 zu realisieren.
 D.h.
 ein Service Consumer muss nur den Interface Typ des benötigten Services
 kennen, die konkrete Service Implementierung wird durch einen Assembler
 von außen als Plugin in den Consumer injiziert oder eingehängt (siehe Abbildung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Dependency Injection"

\end_inset

).
 In Java gibt es für den Vorgang der Injection mehrere unterschiedliche
 Ansätze, die je nach Anwendungsfall vor und Nachteile haben können.
 In der folgenden Auflistung können die ersten drei als die klassischen
 Wege für Dependency Injection betrachtet werden.
 Die Annotation Injection ist eine eher neuere Ausprägung des Injection
 Patterns.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Dependency Injection Pattern
\begin_inset CommandInset label
LatexCommand label
name "fig:Dependency Injection"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/Dependency Injection-base.eps
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Konstruktor-Injection
\end_layout

\begin_layout Standard
Bei dieser Form von Injektion werden alle nötigen Plugins über den Konstruktor
 des Consumers injiziert.
 Alle Plugins werden hier also schon bei der Erstellung des Consumers benötigt.
 Daraus ergeben sich in der Praxis oftmals Probleme
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Verweis auf konkrete Problembeschreibung im Praxiskapitel z.B.
 Zyklus
\end_layout

\end_inset

, für deren Lösung moderne IOC Frameworks verschiedene Wege (z.B.
 Lazy Loading, Proxying) anbieten.
 Für den Assembler ist es hier wichtig einen bestimmten Konstruktor für
 den Injizierungsvorgang zur Verfügung zu haben.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Paragraph
Setter-Injection
\end_layout

\begin_layout Standard
Wie auch hier schon der Name sagt, werden bei dieser Art der DI, Plugins
 über, vom Consumer selbst zur Verfügung gestellte Setter, in den Consumer
 eingehängt.
 Man benötigt hier für jedes Plugin einen eigenen Setter.
 Ein besonderer Vorzug der Setter Injection gegenüber der Konstruktor Injection,
 ist hier, dass der Assembler den Zeitpunkt der Injection beliebig nach
 der Objekterstellung wählen kann.
\end_layout

\begin_layout Paragraph
Interface-Injection
\end_layout

\begin_layout Standard
Anstelle von einem Setter pro Plugin, gibt es bei dieser Art der DI für
 jede Instanzvariable eine über ein Injection Interface definierte Inject
 Methode zum setzen des jeweiligen Plugins.
 Das Injection Interface wird immer zusammen mit dem Plugininterface angeboten.
 Jeder Consumer der Plugins vom Typ des Plugininterfaces verwenden möchte,
 muss gleichzeitig auch das Injection Interface für diesen Plugintyp implementie
ren wenn er Plugins injiziert bekommen möchte.
 Somit stehen dem Assembler die Inject Methode für das Plugin zur Verfügung.
\end_layout

\begin_layout Paragraph
Annotation-Injection
\end_layout

\begin_layout Standard
Nachdem im Java Release 5.0 Annotationen eingeführt worden waren, wurde dieses
 neue Feature sogleich von verschiedensten IOC Frameworks verwendet, um
 eine für den Entwickler sehr komfortable neue Art der DI zu realisieren.
 Dabei dienen nun Annotationen wie @Autowired (Spring IOC) als Marker für
 das IOC Framework, mit denen der Entwickler Instanzvariablen für eine durchzufü
hrende Injection kennzeichnen kann.
 Wichtig ist hier aber, dass die Instanzvariable eben nicht über einen explizite
n Setter oder einen Konstruktor injiziert wird.
 Der Assembler injiziert die Instanzvariable direkt über Java Reflection
 in das Objekt.
\begin_inset Newline newline
\end_inset

Natürlich kann und wird die Markierfunktion von Annotationen auch in Zusammenhan
g mit allen anderen DI Arten benutzt.
 In diesen Fällen werden die Annotationen aber lediglich dazu verwendet,
 um Mehrdeutigkeiten für eine Injection Methode aufzulösen.
 Für den Fall, dass mehrere Klassen vom selben Typ existieren der injiziert
 werden soll, bieten viele IOC Frameworks die Möglichkeit an, die Klasse
 über Injektion-Annotationen und deren Parameter genauer zu spezifizieren,
 so dass die zu injizierende Klasse wieder eindeutig festzustellen ist.
 Eine weitere Markierfunktion wird oft angeboten um einen bestimmten Konstruktor
 für die Konstruktor Injection zu kennzeichnen oder um bestimmte Methoden
 als Setter für die Setter-Injektion zu markieren.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Service Locator
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:Service-Locator"

\end_inset


\end_layout

\begin_layout Standard
Eine Alternative zur Entkopplung von Klassen mittels Dependency Injection
 ist die Verwendung des 
\begin_inset Quotes eld
\end_inset

Service Locator
\begin_inset Quotes erd
\end_inset

 Patterns.
 Diese Methode stützt sich auf die zentrale Klasse des 
\begin_inset Quotes eld
\end_inset

Service Locators
\begin_inset Quotes erd
\end_inset

, der Methoden anbietet, über die man Objekte von einem gewünschten Typ
 erhält.
 Anstatt einer Klasse bei ihrer Erstellung nun all ihre Abhängigkeiten mit
 zu geben, gibt man diese Klasse initial nur den Service Locator mit.
 Die Kontrolle über das Instanziieren von Instanzvariablen obliegt bei diesem
 Pattern nun wieder dem Objekt selbst.
 Benötigt das Objekt nun ein anderes Objekt, so kann es dieses über den
 Service Locator bekommen.
 Hier kommt es also nicht zu einer Kontrollfluss Umkehrung wie bei der DI.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Service Locator Pattern
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/Service Locator.eps
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Plugin Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:seperating configuration from use"

\end_inset


\end_layout

\begin_layout Standard
Egal welche Art der DI verwendet wurde um einen Consumer für Plugins vorzubereit
en, man benötigt zudem eine Plugin Konfiguration, wenn man den Code in einem
 Programm zur Laufzeit nutzen möchte.
 
\end_layout

\begin_layout Section
IOC-Frameworks für modulares Entwickeln
\end_layout

\begin_layout Standard
Die im letzten Abschnitt beschriebenen Varianten des 
\begin_inset Quotes eld
\end_inset

Inversion of Control
\begin_inset Quotes erd
\end_inset

 Pattern sind heute Kernstücke unterschiedlicher IOC-Frameworks.
 
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Matrix von Frameworks und IOC
\end_layout

\end_inset

 Durch die Eigenschaft der Entkopplungsmöglichkeit die diese Frameworks
 bieten, können sie sehr hilfreich als Basis für eine modulare Softwareentwicklu
ng eingesetzt werden.
 In der Praxis setzt mittlerweile ein Großteil der Namhaften Softwareentwickler
 IOC-Frameworks zur leichteren Modularisierung ihrer Software ein.
 Mit dem selbst entwickelten IOC-Framework Google Guice setzt z.B.
 auch der Suchmaschinen Anbieter ganz stark auf IOC.
 Neben Guice gibt es weiter IOC-Frameworks wie PicoContainer, Silk DI, Apaches
 Tapestry oder Oracles CDI.
 Manche dieser IOC-Frameworks sind sehr spezialisiert, wie z.B.
 das Tapestry Framework rein auf die Entwicklung von Webanwendungen ausgerichtet
 ist.
\end_layout

\begin_layout Standard
Der wahrscheinlich bekannteste Vertreter aus der Gruppe der IOC-Frameworks
 ist unter dem Namen 
\begin_inset Quotes eld
\end_inset

Spring
\begin_inset Quotes erd
\end_inset

 bekannt.
 Mit 
\begin_inset Quotes eld
\end_inset

Spring
\begin_inset Quotes erd
\end_inset

 ist die Zusammenfassung einer Vielzahl von Modulen gemein deren Einsatzbereich
 sehr breit gestreut ist.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Matrix von Spring Modulen
\end_layout

\end_inset

Bei aller Vielfalt der durch Spring zur Verfügung gestellten Funktionalität,
 bleibt aber der IOC-Container mit seiner Dependency Injection Funktionalität
 das Herzstück.
 Dieses Herzstück ermöglicht zum einen den eigenen modularen Aufbau des
 Spring Frameworks und kann auch für die Entwicklung von eigenständiger
 modularer Java-Software eingesetzt werden.
\end_layout

\begin_layout Chapter
IOC Konfiguration
\end_layout

\begin_layout Standard
Wie bereits im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:seperating configuration from use"

\end_inset

 erklärt wurde, muss man bei der Verwendung des Dependency Injection Pattern
 immer auch eine konkrete Konfiguration für die zur Verfügung stehenden
 und benötigten Plugins bereit stellen.
 Wie diese Konfiguration für bestimmte IOC Container konkret aussieht soll
 im Folgenden beleuchtet werden.
\end_layout

\begin_layout Section
Spring
\end_layout

\begin_layout Standard
Spring ist ein mittlerweile sehr weit verbreitetes, und äußerst umfangreiches
 Java Framework.
 Ungeachtet der zahlreichen Erweiterungen die das Framework seit seinem
 ersten Release erfahren hat , ist der Kern des Spring Frameworks immer
 noch dessen IOC-Container.
 Die zentrale Rolle des IOC-Containers führte auch dazu, dass im laufe der
 Framework Entwicklung mehrere verschiedene Arten zur IOC-Konfiguration
 entstanden sind und aus Gründen der Flexibilität parallel angeboten werden.
 Der gesamten folgende Text bezieht sich immer auf Spring in der Releasversion
 3.0.
 
\end_layout

\begin_layout Standard
Das Java Interface 
\family sans
\shape italic
org.springframework.beans.factory.BeanFactory
\family default
\shape default
 repräsentiert den Spring IOC-Container.
 Über dieses Interface werden alle notwendigen Aktionen abgedeckt.
 Eine FactoryBean Implementierung kann also zum Registrieren von Objekten
 (Plugins), zum Instanziieren von registrierten Objekten sowie zur Aufbewahrung
 und Rückgabe dieser Instanzen verwendet werden.
 Darüber hinaus übernimmt eine BeanFactory die Aufgabe des Assemblers aus
 dem DI Pattern.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spring IOC Konfiguration 
\begin_inset CommandInset citation
LatexCommand cite
key "Spring:3.0:TheIoCcontainer"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Spring-IOC-Konfiguration"

\end_inset


\end_layout

\end_inset


\begin_inset Graphics
	filename pics/container-magic.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Eine Klasse deren Lebenszyklus durch den Spring IOC Container verwaltet
 wird, nennt man ein 
\begin_inset Quotes eld
\end_inset

Bean
\begin_inset Quotes erd
\end_inset

.
 Innerhalb eine Spring Anwendung existieren sowohl Beans als auch ganz normale
 Java-Klassen nebeneinander.
 Beans sind ebenso ganz normale Java-Klassen, nur eben mit dem Zusatz, dass
 sie durch den IOC-Container verwaltet werden.
 Um deren Verwaltung überhaupt durchführen zu können, benötigt der IOC Container
 eine Konfiguration für die Menge der Beans.
 Diese Konfiguration wird als 
\begin_inset Quotes eld
\end_inset

Configuration Metadata
\begin_inset Quotes erd
\end_inset

 bezeichnet und enthält Metadaten, die Aussage darüber geben welche Beans
 überhaupt in einer Anwendung zur Verfügung stehen und welche Abhängigkeiten
 diese Beans untereinander haben.
 Spring bietet verschiedenste Implementierungen des FactoryBean Interfaces
 an.
 Dabei besteht unter anderem die Möglichkeit die Configuration Metadata
 direkt über Javacode, über Annotationen mit 
\begin_inset Quotes eld
\end_inset

Component scanning
\begin_inset Quotes erd
\end_inset

, über Java-Konfigurationsklassen, oder über XML-Konfigurationsfiles die
 aus der historischen Entwicklung heraus in Spring als Standardkonfigurationsmet
hode gelten, festzulegen.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Spring-IOC-Konfiguration"

\end_inset

 gibt einen Überblick zur Verwendung des Spring IOC Containers.
\end_layout

\begin_layout Subsection
Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sec:Spring-Konfiguration"

\end_inset


\end_layout

\begin_layout Standard
Dieser Abschnitt gibt eine kurze Einführung in die beiden Möglichkeiten
 der Konfiguration (XML-Konfiguration und Java-Konfiguration)
\begin_inset Foot
status open

\begin_layout Plain Layout
Die beiden Konfigurationsmethoden werden in der gesamten Arbeit abwechselnd
 behandelt.
 Um in Überschriften anschaulich zu kennzeichnen welche Methode gerade gemeint
 ist, wird der Überschrift entweder (XML) bzw (Java) vorangestellt.
\end_layout

\end_inset

, die in Spring zu Verfügung stehen.
 Die beiden Listings (
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Spring-Bean-Definition-in-XML"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Spring-Bean-Definition-in-Java"

\end_inset

) zeigen die einfache Definition eines Service (MyServiceImpl) als Bean.
 In beiden Varianten wird das selbe Bean konfiguriert.
 Um die jeweilige Konfiguration zur Anwendung zu bringen, muss sie nur dem
 Spring IOC-Container übergeben werden.
\end_layout

\begin_layout Subsubsection*
XML-Variante der Spring Konfiguration
\end_layout

\begin_layout Standard
Ein Spring XML-Konfiguration besteht aus mindestens einer XML-Datei.
 Innerhalb dieser XML-Datei können nur beliebig viele Bean Definitionen
 konfiguriert werden.
 Diese sind durch den XML-Tag 
\family sans
\series bold
<bean>
\family default
\series default
 gekennzeichnet.
 Alle Bean Definitionen werden innerhalb des Wurzelelements 
\family sans
\series bold
<beans>
\family default
\series default
 angelegt.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout
\align left

\begin_inset Caption

\begin_layout Plain Layout
Spring Bean-Definition in XML-Datei
\begin_inset CommandInset label
LatexCommand label
name "lis:Spring-Bean-Definition-in-XML"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout

	<beans
\end_layout

\begin_layout Plain Layout

			xmlns="http://www.springframework.org/schema/beans" 
\end_layout

\begin_layout Plain Layout

			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
\end_layout

\begin_layout Plain Layout

			xsi:schemaLocation="http://www.springframework.org/schema/beans
\end_layout

\begin_layout Plain Layout

			http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<bean id="MyBeanId" class="MyServiceImpl">
\end_layout

\begin_layout Plain Layout

			<!-- weitere Metadaten zum jeweiligen Bean -->
\end_layout

\begin_layout Plain Layout

		</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	</beans>
\end_layout

\begin_layout Plain Layout

</xml>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
Java-Variante der Spring Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Java-Variante-der-Spring-Konfig"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Ergänzung um Beschreibung zu Componentscanning & @Autowired Beschreibung
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Eine Spring Java-Konfiguration besteht aus mindestens einer Java-Klasse,
 die, mit der Annotation 
\family sans
\series bold
@Configuration 
\family default
\series default
über dem Klassenenamen, als Spring-Konfiguration markiert ist.
 Um nun in dieser Java-Klasse ein Bean zu definieren wird eine mit der Annotatio
n 
\family sans
\series bold
@Bean()
\family default
\series default
 gekennzeichnete Methode benötigt, die eine Instanz der gewünschten Bean-Klasse
 zurück gibt.
 Der Name des Bean kann innerhalb der 
\family sans
\series bold
@Bean()
\family default
\series default
 Annotation über den Parameter 
\begin_inset Quotes eld
\end_inset


\family sans
\series bold
name
\family default
\series default

\begin_inset Quotes erd
\end_inset

 angegeben werden.
 Wird der name nicht explizit definiert, so wird der Methodenname als Name
 für das Bean herangezogen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Spring Bean-Definition in Java-Klasse
\begin_inset CommandInset label
LatexCommand label
name "lis:Spring-Bean-Definition-in-Java"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import org.springframework.context.annotation.Configuration;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@Bean()
\end_layout

\begin_layout Plain Layout

	public static MyServiceInterface myBeanId()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyServiceImpl();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Im folgenden Kapitel wird das Tapestry-Framework beschrieben werden.
 Dieses diente als Inpiration und Vorbild für die 
\noun on
SpringContributions.

\noun default
 Dabei kann die gerade beschriebene Spring Java-Konfiguration, durch den
 Umstand, dass diese ebenfalls in Java-Klassen durchgeführt wird, wohl etwas
 einfacher mit der Tapestry Variante verglichen werden.
 Das Selbe gilt auch für alle späteren Abschnitte.
\end_layout

\begin_layout Section
Tapestry
\end_layout

\begin_layout Standard
Apache Tapestry ist ein Framework zur Entwicklung von Webanwendungen mit
 Java.
 Tapestry unterstützt dabei auch besonders den modularen Aufbau einer Webanwendu
ng.
 Auch hier bildet ein Framework eigener IOC Container zusammen mit eine
 Reihe von Services das Kernstück, um die Konfiguration der Module und ihrer
 Dienste zu ermöglichen.
 Durch die Verwendung eines IOC Containers findet die Dependency Injection
 in ihren verschiedensten Ausprägungen (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Dependency-Injection"

\end_inset

) eine umfassende Verwendung innerhalb aller Teile eines Tapestry Moduls.
\end_layout

\begin_layout Standard
Ein mit Tapestry entwickeltes Modul wird als Java Archiv (.jar) gepackt und
 lässt sich in dieser Form mit anderen Tapestry Modulen kombinieren.
 Innerhalb des Archivs wird ein Tapestry Modul durch eine Modul Klasse repräsent
iert.
 Diese Klasse stellt dem Framework Informationen über die im Modul vorhandenen
 Services zur Verfügung.
 Der Inhalt der Modul Klasse entspricht hier dem der Konfiguration Metadaten
 des Spring Frameworks (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Spring-Konfiguration"

\end_inset

).
\end_layout

\begin_layout Subsection
Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Konfiguration"

\end_inset


\end_layout

\begin_layout Standard
Die Konfiguration eines Tapestry Moduls besteht aus reinem Javacode.
 Tapestry bietet für das Festlegen der Modul Konfiguration innerhalb der
 Modul Klasse eigene Namenskonventionen und Annotationen an.
 Das Framework erkennt dann zum Beispiel am Anfang eines Methodennamen,
 dass es sich hier um eine Servicedefinition handelt.
 In der Modul Klasse stehen mehrere Konfigurationsmöglichkeiten zur Verfügung.
 Folgende vier Arten zeigen einen Großteil der essentiellen Möglichkeiten,
 wobei wir uns später nur noch mit den ersten beiden beschäftigen werden.
\end_layout

\begin_layout Itemize

\noun on
\begin_inset Quotes eld
\end_inset

Bind
\begin_inset Quotes erd
\end_inset


\noun default
: Das Definieren eines Services, durch zuweisen einer Service Implementierung
 zu dem zugehörigen Service Interface
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\noun on
Contribute
\noun default

\begin_inset Quotes erd
\end_inset

: Das Bereitstellen von Service Konfigurationsdaten
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\noun on
Build
\noun default

\begin_inset Quotes erd
\end_inset

: Das Definieren und Bauen eines Services durch expliziten Javacode
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\noun on
Decorate
\noun default

\begin_inset Quotes erd
\end_inset

: Das Dekorieren eines Services, wie es aus dem 
\begin_inset Quotes eld
\end_inset

Decorator Pattern
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset

 bekannt ist
\end_layout

\begin_layout Standard
Eine Servicedefinition in Tapestry entspricht in etwa einer Bean Definition
 in der Spring Konfiguration.
 In beiden Fällen handelt es sich um Konfigurationsdaten die dem jeweiligen
 IOC Container die nötigen Informationen geben, um dem System eine, über
 ein Interface definierte Funktionalität, bereitstellen zu können.
\end_layout

\begin_layout Standard
In Tapestry gibt es verschiedenen Möglichkeiten ein Service zu definieren.
 Im Allgemeinen existiert für ein Tapestry Service ein Interface und mindestens
 eine zugehörige Implementierung.
 Um das Service dem System bekannt zu geben wird die 
\family sans
\shape italic
bind()
\family default
\shape default
 Methode in Zusammenspiel mit dem 
\family sans
\shape italic
org.apache.tapestry5.ioc.ServiceBinder
\family default
\shape default
 verwendet.
 Über den 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

ServiceBinder
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 wird das Framework informiert, welche Serviceimplementierung für ein Service
 Interface zur Verwendung hinterlegt werden soll (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "tapestry-bind"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tapestry-bind"

\end_inset

 Tapestry: Registrierung eines Dienstes 
\begin_inset Quotes eld
\end_inset

binding
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void bind(ServiceBinder binder)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		binder.bind(MyServiceInterface.class, MyServiceImpl.class);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Eine weitere Möglichkeit der Service Definition passiert über eine sogenannte
 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

build
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode, die mit dem Service Interface als Rückgabewert definiert wird.
 Bei dieser Art der Servicedefinition können auch gleich Setupmethoden auf
 dem Serviceobjekt durchgeführt werden (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "tapestry-build"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tapestry-build"

\end_inset

 Tapestry: Definition einer Serviceimplementierung innerhalb der Modulklasse
 
\begin_inset Quotes eld
\end_inset

build
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static MyServiceInterface build()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyServiceInterface()
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			//service methods and implementation
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Der Konfigurationsmechanismus im Tapestry Framework unterstützt aber nicht
 nur das Definieren von Services.
 Eine der besonderen Stärken des Frameworks liegt in der Möglichkeit via
 IOC einem Service eine Liste von Objekten des selben Interfacetyps zu übergeben.
 Diese Art der Konfiguration wird in Tapestry mit 
\begin_inset Quotes eld
\end_inset

Contribution
\begin_inset Quotes erd
\end_inset

 bezeichnet.
 Eine genaue Beschreibung des Tapestry 
\begin_inset Quotes eld
\end_inset

Contribution
\begin_inset Quotes erd
\end_inset

 Mechanismus mit allen möglichen Übergabeformen wird im nächsten Kapitel
 genauer beschrieben.
\end_layout

\begin_layout Chapter
Contribution Services
\end_layout

\begin_layout Section
Tapestry Contributions
\end_layout

\begin_layout Standard
Die meisten Services können die Dienste die sie anbieten nicht komplett
 selbstständig erledigen.
 Also haben Services oft Abhängigkeiten auf andere Services.
 Es gibt viele Fälle in denen eine solche Abhängigkeit nicht nur eine 1:1
 Beziehung darstellt.
 Es kommt vor, dass sich ein Service einer ganzen Liste an Implementierungen
 eines anderen Serviceinterfaces bedient, um seine Aufgaben zu lösen.
 In einer herkömmlichen Java Anwendung würde diese Liste, bei der Initialisierun
g des Dienstes, an diesen mitgegeben werden.
 In einer durch einen IOC Container verwalteten Anwendung, benötigen wir
 die Möglichkeit, diese Liste als Konfiguration für das Service bereit zu
 stellen.
 In Tapestry erledigen wir diese Aufgabe über eine 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode.
 Laut Namenskonvention beginnt diese Konfigurationsmethode mit der Bezeichnung
 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
contribute
\family default
\shape default

\begin_inset Quotes erd
\end_inset

, gefolgt von dem Namen des Services, für den die Konfiguration, und somit
 die Liste gedacht ist (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "tapestry-contribute"

\end_inset

).
 Dadurch entsteht eine eindeutige Zuordnung zwischen der Liste und dem Service
 das sie konsumiert.
\end_layout

\begin_layout Standard
Ein großer Vorteil, den diese Art der Servicekonfiguration durch die Indirektion
 über den IOC Container mit sich bringt, ist die Möglichkeit, der Liste,
 derer sich der Service bedienen soll, modulübergreifend weitere Implementierung
en hinzuzufügen.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Configuration
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Wenn man nun einem Service eine Liste von Objekten übergeben möchte, so
 bedient man sich innerhalb der 
\family sans
\shape italic

\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset


\family default
\shape default
 Methode eines Konfiguration Objekts
\end_layout

\begin_layout Standard
(
\family sans
\shape italic
org.apache.tapestry5.ioc.Configuration<T>
\family default
\shape default
), in dem man die einzelnen Objektdefinitionen ablegen kann.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tapestry-contribute"

\end_inset

 Tapestry: Einfache Listenübergabe
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void contributeMyServiceInterface(Configuration<MyServiceDependen
cyElement> configuration)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		configuration.add(new MyServiceDependencyElementImplOne());
\end_layout

\begin_layout Plain Layout

		configuration.add(new MyServiceDependencyElementImplTwo());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// ...
 more Elements to be added to the list
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Der Konfigurationsmechanismus im Tapestry Framework unterstützt aber nicht
 nur eine einfache Listenübergabe über das Interface 
\end_layout

\begin_layout Standard

\family sans
\shape italic
org.apache.tapestry5.ioc.Configuration<T>
\family default
\shape default
 als Servicecontribution, sondern bietet noch weitere komplexere Übergabeformen.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Ordered Configuration
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Es gibt Anwendungsfälle in denen es nicht ausreicht, einem Service eine
 einfache Liste von Objekten zu übergeben.
 Bei der Verwendung der übergebenen Liste wird diese üblicherweise sequenziell
 abgehandelt.
 Man kann sich nun leicht Fälle vorstellen, bei denen die Reihenfolge der
 Objekte in der Liste nicht beliebig sein kann.
 Wenn zum Beispiel Abhängigkeiten zwischen den einzelnen Diensten aus der
 Liste bestehen, so hat die Reihenfolge ihrer Abarbeitung Auswirkungen auf
 das Ergebnis.
 Für den Fall, dass man also die Reihenfolge der Dienste in der Liste beeinfluss
en möchte bzw.
 muss, bietet Tapestry die Übergabeform einer geordneten Liste über das
 Interface
\end_layout

\begin_layout Standard

\family sans
\shape italic
org.apache.tapestry5.ioc.OrderedConfiguration<T> 
\family default
\shape default
an.
 Wie eine derartige 
\begin_inset Quotes eld
\end_inset

Ordered Contribution
\begin_inset Quotes eld
\end_inset

 als Konfiguration durchgeführt wird zeigt folgendes Codebeispiel.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Tapestry: Sortierte Listenübergabe
\begin_inset CommandInset label
LatexCommand label
name "lis:tapestry-ordered-contribution"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void contributeMyServiceInterface(OrderedConfiguration<MyServiceD
ependencyElement> configuration)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		configuration.add("last", new LastService(), "after:*");
\end_layout

\begin_layout Plain Layout

		configuration.add("second", new SecondService(), "after:first");
\end_layout

\begin_layout Plain Layout

		configuration.add("first", new FirstService(), "before:*");
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		// ...
 more Elements to be added to the ordered list
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tapestry-ordered-contribution"

\end_inset

 wird eine Servicekonfiguration durchgeführt, in der festgelegt ist, dass
 einem Service, der das Interface 
\family sans
\shape italic
MyServiceInterface
\family default
\shape default
 implementiert, eine sortierte Liste von Services übergeben werden soll.
 Die Sortierung der Liste kann dabei durch die Schlüsselwörter 
\begin_inset Quotes eld
\end_inset


\family sans
before
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
after
\family default

\begin_inset Quotes erd
\end_inset

 in Zusammenhang mit dem Wildcardzeichen 
\family sans

\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset


\family default
 oder dem direkten Bezug auf ein anderes Element der Liste beschrieben werden.
 Um den direkten Bezug auf andere Elemente zu ermöglichen, müssen den einzelnen
 Elementen eindeutige Namen zugeordnet werden.
 Die Sortierung der Liste ist im Beispiel so eingestellt, dass der Service
 
\family sans
\shape italic
FirstService
\family default
\shape default
 an erster Stelle, vor allen anderen kommt, gefolgt von dem Service 
\family sans
\shape italic
SecondService
\family default
\shape default
 und dem Service 
\family sans
\shape italic
LastService
\family default
\shape default
, der das Ende der Liste bildet.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Mapped-Configuration
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:Mapped-Configuration"

\end_inset


\end_layout

\begin_layout Standard
Es lassen sich aber auch Anwendungsfälle finden, in denen die Datenstruktur
 einer Liste, sei sie geordnet oder ungeordnet, als Übergabeform für ein
 zu konfigurierendes Service nicht ausreicht, um die ihm gestellten Aufgaben
 zu bewältigen.
 In manchen Fällen ist es notwendig Services anhand von Schlüsselelementen
 zu identifizieren.
 Für dieses Mapping kann eine Listenstruktur nicht mehr verwendet werden.
 Sehr wohl aber lässt sich eine derartige Anforderung in Java durch den
 Objekttyp einer 
\family sans
\shape italic
Map
\family default
\shape default
 realisieren.
 Damit es nun auch möglich ist Services, mit Schlüsseln in Beziehung zu
 bringen, und dies auch als Konfiguration im IOC Container abzulegen, bietet
 Tapestry das Interface 
\family sans
\shape italic
org.apache.tapestry5.ioc.MappedConfiguration<K,V>
\family default
\shape default
 an.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Tapestry: Serviceübergabe mit Schlüsselmapping
\begin_inset CommandInset label
LatexCommand label
name "lis:tapestry-mapped-ordered-contribution"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public static void contributeMyServiceInterface(MappedConfiguration<String,
 MyServiceDependency> configuration)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		configuration.add("keyFoo", new FooService());
\end_layout

\begin_layout Plain Layout

		configuration.add("keyFooFoo", new FooFooService());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// ...
 more key/value pairs to be added to the map
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tapestry-mapped-ordered-contribution"

\end_inset

 wird die Verwendung einer 
\begin_inset Quotes eld
\end_inset

Mapped Contribution
\begin_inset Quotes erd
\end_inset

 gezeigt.
 Dabei wird eine Servicekonfiguration angelegt, die einem Service, der das
 Interface 
\family sans
\shape italic
MyServiceInterface
\family default
\shape default
 implementiert, eine Map übergibt.
 Über die Schlüssel 
\begin_inset Quotes eld
\end_inset


\family sans
keyFoo
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
keyFooFoo
\family default

\begin_inset Quotes erd
\end_inset

 kann der Service dann Zugriff auf die zwei darunter hinterlegten Objekte
 erhalten.
\end_layout

\begin_layout Section
Bean-Listen und Bean-Maps in Spring
\end_layout

\begin_layout Standard
In Spring gibt es von Haus aus die Möglichkeit unterschiedliche Beans vom
 selben Interfacetype in Listen oder in Maps zusammenzufassen und via Dependency
 Injection an andere Beans weiterzugeben.
 Dieses Service des IOC-Containers ist in seiner Form etwas wie eine leichtgewic
htige Minimalform des Tapestry Contributionservices.
 Spring stellt diese Funktionalität automatisch zur Verfügung und sieht
 dafür keine eigenständige Konfigurationssyntax vor.
 Der Mechanismus läuft dabei folgendermaßen ab: Sobald der IOC-Container
 ein Bean instanziieren muss, dessen Konstruktor eine Liste von Objekten
 erwartet, die das selbe Interface implementieren, werden alle im IOC-Container
 befindlichen Beans auf die diese Eigenschaft zutrifft, in eine Liste verpackt
 und dem konsumierenden Bean bei der Erstellung übergeben.
\end_layout

\begin_layout Standard
Das Selbe Prinzip wird auch für Map-Parameter angewandt, wobei die einzelnen
 Beans nun als Values in einer Map zusammengefasst werden.
 Als Key wird jeweils der in der Konfiguration festgelegte Name des Beans
 herangezogen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Spring: 
\begin_inset Quotes eld
\end_inset

leichtgewichtige
\begin_inset Quotes erd
\end_inset

 Standard-Contribution
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- Java-Implementierung eines Listen-Konsumenten -->
\end_layout

\begin_layout Plain Layout

public class ListValueHolder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public ListValueHolder(List<String> contributedStringList){}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- Java-Implementierung eines Map-Konsumenten -->
\end_layout

\begin_layout Plain Layout

public class MapValueHolder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public MapValueHolder(Map<String, String> contributedStringMap){}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Bean Konfig des Listen-Konsumenten -->
\end_layout

\begin_layout Plain Layout

<bean name="listValueHolder" class="org.springframework.contributions.ListValueHold
er" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Bean Konfig des Map-Konsumenten -->
\end_layout

\begin_layout Plain Layout

<bean name="mapValueHolder" class="org.springframework.contributions.MapValueHolder
" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Konfiguration der Contribution Elemente für die Liste und die
 Map-->
\end_layout

\begin_layout Plain Layout

<bean name="string1" class="java.lang.String" value="String 1" />
\end_layout

\begin_layout Plain Layout

<bean name="string2" class="java.lang.String" value="String 2" />
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO: Beschreibung des Listing mit Beispiel zur Konfiguration
\end_layout

\end_inset


\end_layout

\begin_layout Section

\noun on
SpringContributions: 
\noun default
Umsetzung als Spring Erweiterung
\end_layout

\begin_layout Standard
Das Spring Framework ist selbst aus Komponenten aufgebaut.
 Aus diesem Grund bietet das Framework auch die einfache Möglichkeit, neue
 Komponenten in das Framework zu integrieren.
 Dies hat sowohl Vorteile für die interne Weiterentwicklung, wie auch für
 die Entwicklung von Erweiterungen durch Außenstehende.
 Um die aus dem Tapestry Framework bekannte Contribution Funktionalitäten
 auch in Spring einführen zu können, wurde genau diese Möglichkeiten verwendet
 und die eigene Spring Komponente 
\noun on
SpringContributions
\noun default
 entwickelt.
\end_layout

\begin_layout Standard
Seit den Anfängen der Spring Framework Entwicklung gibt es auch den klassischen
 XML-Konfigurationsmechanismus des Framework.
 Wenn das Framework um neue Funktionalität und damit einhergehend die Konfigurat
ion um neue Schlüsselwörter erweitert wurden, so geschah dies also immer
 über die Definition von XML-Elementen.
 Im Rahmen dieser Arbeit, wurde zu Beginn genau dieser klassische Weg gewählt,
 um die 
\noun on
SpringContributions 
\noun default
Erweiterung umzusetzen.
\end_layout

\begin_layout Standard
Seit der Hauptversion 3.0 bietet Spring, parallel zur XML-Konfiguration,
 einen weiteren Weg der Konfiguration an.
 Die neue Möglichkeit, Spring zu verwenden, nennt sich 
\begin_inset Quotes eld
\end_inset

Java Configuration
\begin_inset Quotes erd
\end_inset

 und wurde aus der zuvor eigenständig entwickelten Projekt 
\begin_inset Quotes eld
\end_inset

Spring JavaConfig
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "SpringJavaConfig:2013"

\end_inset

 in das Spring Framework übernommen.
 Dabei handelt es sich, wie der Name bereits vermuten lässt, um eine Möglichkeit
, mittels der man die gesamte Spring Konfiguration eines Projektes in Java
 Klassen vornehmen kann.
 Es ist ein Einfaches, sich vorzustellen, dass es viele Vorteile geben kann,
 die Konfiguration eines Projektes, statt in einer Auszeichnungssprache
 wie XML, in einer Programmiersprache wie Java durchführen zu können.
 Daher war es auch ein Ziel bei der Entwicklung der 
\noun on
SpringContributions 
\noun default
Erweiterung, eben auch diese zweite Konfigurationsmöglichkeit anzubieten.
 Wie die Herangehensweise bei der Umsetzung des jeweiligen Konfigurationsmechani
smus aussieht wird in den Unterabschnitten 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-Erweiterung-mittels-XML-Config"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-Erweiterung-mittels_Java-Config"

\end_inset

 behandelt.
\end_layout

\begin_layout Subsection
Konzeptionelle Unterschiede von Tapestry zu 
\noun on
SpringContributions
\end_layout

\begin_layout Standard
Das Spring IOC Modell unterscheidet sich in manchen Punkten deutlich vom
 Tapestry IOC Modell.
 Einer der Unterschiede wirkt sich dabei auch maßgeblich auf die Umsetzung
 und die Funktionalität der 
\noun on
SpringContributions
\noun default
 aus.
 Es handelt sich dabei um den Umstand, dass in Spring jedes Konfigurationseinhei
t in ein Bean abgebildet wird.
 Das Bean-Konzept in Spring schreibt vor, dass jedes Bean auf jeden Fall
 eine eindeutige Identifikation besitzen muss.
 Dieser Umstand wurde in der Konzeption der 
\noun on
SpringContributions
\noun default
 mit einbezogen und konnte dafür genutzt werden, durch eine kleine Abweichung
 vom Vorbild des Tapestry Contributionmechanismus, einen Mehrwert in den
 Verwendungsmöglichkeiten zu gewinnen.
\end_layout

\begin_layout Standard
In Tapestry verhält es sich so, dass eine Contribution immer eindeutig einem
 Konsumenten zugeordnet ist.
 In der Spring-Konfiguration wird jede Contribution als eigenes Konfigurationsel
ement und somit als eigenes Objekt bzw.
 Bean behandelt.
 Wie bereits erwähnt, erhält nun jedes Bean zur Identifikation auch einen
 eigenen, eindeutigen Namen.
 Daraus ergibt, dass in Spring eine Contribution, die ja als eigenes und
 über den eindeutigen Namen, eindeutig referenzierbares Objekt existiert,
 nicht nur von einem bestimmten, sondern von vielen beliebigen Konsumenten
 verwendet werden kann.
 Ist ein Contribution-Bean also einmal definiert, so kann jedes Bean, dass
 sich nun dieser Contribution anschließen, oder sich ihrer bedienen will,
 über deren eindeutigen Namen das tatsächliche Bean referenzieren.
 Dieser Vorteil und die ebenso zu beachtenden Risiken bei der mehrfachen
 Verwendung einer Contributions, wird im Unterabschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Contributions-mehrfach-konsumier"

\end_inset

 noch genauer beleuchtet.
\end_layout

\begin_layout Standard
Der eben erwähnten Mehrwert in der Verwendung bringt aber auch gleichzeitig
 neue Herausforderungen für den Anwender.
 Dieser ist nämlich selbst für die Vergabe von Namen für Contributions verantwor
tlich und muss sich deshalb selbst um deren Eindeutigkeit kümmern.
 Wie der Name für ein Contribution-Bean definiert wird, ist im Detail im
 Unterabschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Contribution-Bean-Identifikation"

\end_inset

 beschrieben.
\end_layout

\begin_layout Standard
Zusätzlich ist es im Unterschied zur Tapestry Vorlage, durch das Wegfallen
 der eindeutigen Zuordnung einer Contribution zu genau einem Konsumenten,
 nötig den Namen der Contribution innerhalb der Konfiguration des Konsumenten
 zu wissen und anzugeben.
 Das automatische Auflösen der Referenzen von Konsument zu Contribution
 durch den IOC-Container kann also in den 
\noun on
SpringContributions
\noun default
 nur mehr auf Basis des eindeutigen Namen funktionieren.
\end_layout

\begin_layout Standard
Ein weiterer, konzeptioneller Unterschied zur Tapestry Vorlage betrifft
 die Abbildung der Listenform eine Contribution.
 In den 
\noun on
SpringContributions
\noun default
 wird nicht mehr extra zwischen unsortierten und sortierten Listen unterschieden.
 Dieser Weg wurde gewählt, um die Menge der unterschiedlichen Konfigurationselem
ente möglichst gering zu halten.
 Es wird also nur mehr ein Konfigurations-Element für eine Contribution-Liste
 benötigt, egal ob diese sortiert oder unsortiert sein soll.
 Die Angabe einer Reihenfolge der Listenelemente wird über eine optionale
 sortierungs Angabe ermöglicht.
 Demnach besteht nur noch die Unterscheidung zwischen Listenübergabe und
 
\begin_inset Quotes eld
\end_inset

gemappter
\begin_inset Quotes erd
\end_inset

 Übergabeform.
 Im 
\noun on
SpringContributions
\noun default
-Kontext werden für diese beiden Übergabeformen von nun an die Bezeichnungen
 Contribution-Liste und Contribution-Map verwendet.
\end_layout

\begin_layout Subsection
Die zwei Wege der Spring Erweiterung
\end_layout

\begin_layout Standard
Dieser Abschnitt soll zeigen was genau gemacht werden muss, wenn man Spring
 mit einer der beiden angebotenen Möglichkeiten um ein Modul erweitern möchte.
\end_layout

\begin_layout Subsubsection
Erweiterung mittels Spring XML-Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Spring-Erweiterung-mittels-XML-Config"

\end_inset


\end_layout

\begin_layout Standard
Entscheidet man sich, bei der Erweiterung von Spring dafür, den klassischen
 Weg der XML-Konfiguration anzubieten, so sind die Ausgangspunkte in der
 Entwicklung der neuen Komponente, ein eigener Namensraum und das zugehöriges
 XML-Schema.
 Die für Spring ab der Version 3.0 entwickelten 
\noun on
SpringContributions
\noun default
 verwenden das XML-Schema 
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset


\family sans
\size footnotesize
http://www.springframework.org/schema/contributions/spring-contributions-3.0.xsd
\family default
\size default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
mit dem XML-Namensraum 
\begin_inset Quotes eld
\end_inset


\family sans
\size footnotesize
http://www.springframework.org/schema/contributions
\family default
\size default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Um die Grundlage für den Spring eigenen 
\begin_inset Quotes eld
\end_inset

Contribution
\begin_inset Quotes erd
\end_inset

 Mechanismus zu legen, werden im XML-Schema einige neue Konfigurationselemente
 definiert.
 Jede dieser Konfigurationsmöglichkeiten wird in Unterabschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:XML--und-Java-Konfiguration-im-Detail"

\end_inset

genauer beschrieben werden.
 Dabei werden die zur Verwendung stehenden XML-Elemente und XML-Attribute,
 ausgehend von deren Schemadefinition und im Hinblick auf ihre Anwendung
 eingeführt.
\end_layout

\begin_layout Subsubsection
Spring Erweiterung mittels Java-Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Spring-Erweiterung-mittels_Java-Config"

\end_inset


\end_layout

\begin_layout Standard
Will man für eine eigene Spring Komponente die Konfiguration auch als Spring
 Java-Konfiguration (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Java-Variante-der-Spring-Konfig"

\end_inset

) ermöglichen, so gibt es zwei unterschiedliche Wege der Umsetzung.
 Zum einen bietet Spring einen Eingriffsmöglichkeit, bei der man sich direkt
 in die früheste Phase der Registrierung von Beandefinitionen einschalten
 kann (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Spring-Java-Konfiguration_Eingriff während der Bean Definition Registrierung"

\end_inset

).
 Zum anderen kann man nach Ablauf der Standardregistrierung von Beandefinitionen
 eingreifen und die bestehenden Definitionen verwenden, anpassen und auch
 neue Definitionen hinzufügen (siehe Listeing 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Spring-Java-Konfiguration_Eingriff nach der Bean Definition Registrierung"

\end_inset

).
 Für eine erste Umsetzung der Java-Konfiguration für die 
\noun on
SpringContributions
\noun default
 habe ich mich für die zweite Variante entschieden.
 Auf die Gründe für diese Entscheidung werde ich etwas später eingehen.
 Zuvor werde ich noch die beiden möglichen Varianten der Umsetzung etwas
 genauer vorstellen.
\end_layout

\begin_layout Paragraph*
Eingriff während der Bean Definition Registrierung (Variante 1):
\end_layout

\begin_layout Standard
Ebenso wie ein XML-Konfigurationsfile muss auch eine Spring Java-Konfigurationsk
lasse zu aller erst geparst werden.
 Danach werden alle Annotationen (
\family sans
\series bold
@PropertySource
\family default
\series default
, 
\family sans
\series bold
@ComponentScan
\family default
\series default
, 
\family sans
\series bold
@Import
\family default
\series default
,
\family sans
\series bold
 @Bean
\family default
\series default
, ...
 ) und deren Metadaten in einer fixen Reihenfolge abgearbeitet.
 Jeder Schritt in dieser Abarbeitungskette behandeln eine ganz bestimmte
 Annotation und den zugehörigen Konfigurationscode.
 Dabei bietet die Abarbeitung der 
\family sans
\series bold
@Import
\family default
\series default
 Annotationen, die noch vor der 
\family sans
\series bold
@Bean
\family default
\series default
 Annotation an dritter Stelle behandelt wird, den Anknüpfungspunkt für eigene
 Erweiterungen der Java-Konfiguration.
 Über diesen Weg lässt sich ein eigener 
\family sans
\shape italic
ImportBeanDefinitionRegistrar
\family default
\shape default
 definieren, in den die Logik zum Registrieren der Beandefinitionen kommt.
 Dieser Klasse lässt sich dann über die 
\family sans
\series bold
@Import
\family default
\series default
 Annotation an eine eigens definierte Annotation (z.B.
 
\family sans
\series bold
@EnableContributions
\family default
\series default
) binden.
 Verwendet man nun diese selbst definierte Annotation innerhalb einer Java-Konfi
guration, so wird also beim Abarbeiten der Imports die 
\family sans
\shape italic
registerBeanDefinitions
\family default
\shape default
 Methode der 
\family sans
\shape italic
ImportBeanDefinitionRegistrar
\family default
\shape default
-Klasse aufgerufen und die eigenen Logik zum registrieren von Beandefinitionen
 angewandt.
\end_layout

\begin_layout Standard
Bei diesem Weg der Erweiterung befindet man sich zeitlich noch vor der Spring
 eigenen Beandefinition Registrierung und damit sehr früh in der Abfolge
 der IOC-Registry Erstellung.
 Das würde den Vorteil ergeben, dass alle mit 
\family sans
\series bold
@Bean
\family default
\series default
 definierten Services bereits die Contribution-Konfiguration verwenden könnten.
 Umgekehrt besteht natürlich nicht die Möglichkeit, bei der Abarbeitung
 der Contribution-Konfiguration, bereits auf die Beandefinitionen zuzugreifen.
 Wenn man also die Beans für die Contribution schon zu diesem Zeitpunkt
 benötigte, so müsste man sich ebenfalls selbst darum kümmern.
 Das heißt, man müsste äquivalent zur 
\family sans
\series bold
@Bean
\family default
\series default
 Annotation, eine eigene Konfiguration für Beans anbieten.
 Darüber könnte man schließlich Beans definieren deren Definition dann bereits
 zum Erstellungszeitpunkt der Contribution-Konfiguration zur Verfügung stehen
 würden.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spring Java-Konfiguration Erweiterung (Variante 1)
\begin_inset CommandInset label
LatexCommand label
name "fig:Spring-Java-Konfiguration_Eingriff während der Bean Definition Registrierung"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/CreatingBeanDefinitionsFromConfigurations (JAVA).eps
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph*
Eingriff nach der Bean Definition Registrierung (Variante 2):
\begin_inset CommandInset label
LatexCommand label
name "par:Java-Konfig-Variante2"

\end_inset


\end_layout

\begin_layout Standard
Bei dieser Variante kann mittels eines Postprozessors, beim Erstellen des
 ApplicationContext, die vom Spring-Kern erstellte IOC-Konfiguration, in
 einer zuletzt gereihten Phase, angepasst werden.
 Zu diesem späten Zeitpunkt sind bereits alle Spring eigenen Standardkonfigurati
onen als Beandefinitionen in der IOC-Registry abgelegt.
 Nun kann man innerhalb einer Implementierung des Interfaces 
\family sans
\shape italic
BeanDefinitionRegistryPostProcessor
\family default
\shape default
 den Code zur Abarbeitung der 
\noun on
SpringContributions
\noun default
-Konfiguration realisieren.
 Hier ist es dann natürlich möglich, alle bereits bestehenden Beandefinitionen
 in der Abarbeitung der Contribution-Konfiguration zu berücksichtigen und
 zu referenzieren.
 Man hat hier also den Vorteil, sich nur um die Cotribution-Bean-Erstellung,
 und nicht um die normale Bean-Erstellung selbst kümmern zu müssen, da diese
 ja bereits im Standardablauf von Spring erstellt wurden.
\end_layout

\begin_layout Standard
Natürlich besteht bei dieser Variante nicht die Möglichkeit, dass in der
 normalen Beandefinition Abarbeitung bereits auf die Contribution-Definitionen
 zugegriffen werden kann, da diese ja erst im Postprozessor erstellt werden.
 Konkret bedeutet das für die Umsetzung der 
\noun on
SpringContributions
\noun default
, dass für die normalen mit 
\family sans
\series bold
@Bean
\family default
\series default
 annotierten Bean-Konfigurationen eine Indirektion zum Zugriff auf Conribution-B
eans verwendet werden muss.
 Dazu müssen eigene 
\begin_inset Quotes eld
\end_inset

Resolver
\begin_inset Quotes erd
\end_inset

-Services angeboten werden, die schon zum Erstellungszeitpunkt der Beans
 zur Verfügung stehen und später einen Zugriff auf die Contribution-Beans
 ermöglichen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spring Java-Konfiguration Erweiterung (Variante 2)
\begin_inset CommandInset label
LatexCommand label
name "fig:Spring-Java-Konfiguration_Eingriff nach der Bean Definition Registrierung"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/CreatingBeanDefinitionsFromConfigurations (JAVA)_postprocess.eps
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Bei der Konzeption der Contribution-Map Funktionalität für die Java-Konfiguratio
n ergaben sich einige Probleme dabei, exakt dasselbe Set an Konfigurationsmöglic
hkeiten zur Verfügung zu stellen wie es bereits in der XML-Variante umgesetzt
 wurde.
 In Spring hat man sich bei der Java-Konfiguration dafür entschieden Konfigurati
onsmetadaten über Annotationen abzubilden.
 Aus Gründen der Konsistenz baut die Java-Konfiguration der 
\noun on
SpringContributions
\noun default
 ebenfalls auf Annotationen auf.
 Durch diese Vorgabe ergaben sich jedoch einige Schwierigkeiten in der Umsetzung
 der Funktionsumfangs.
 Die momentane Implementierung bildet daher einen Kompromiss aus dem Streben
 nach Äquivalenz zur XML-Konfiguration und dem Bemühen, die die Java-Konfigurati
on überschaubar und verwendbar zu gestalten.
 So wurde zum Beispiel die Möglichkeit weggelassen, konkrete Beans beziehungswei
se Objekte als Schlüsselelement der Map verwenden zu können.
 Auf diese Möglichkeit musste verzichtet werden, da man in einer Annotation
 keine konkreten Objektinstanzen übergeben kann.
\end_layout

\begin_layout Standard
Da Enumerationen sich, seit ihrer Einführung in Java, einer sehr hohen Beliebthe
it erfreuen, war es wichtig die Möglichkeiten der Verwendung von Enumerationen
 als Schlüssel der Contribution-Map umzusetzen.
 Dies konnte leider, wieder auf Grund der Eigenschaften von Annotationen,
 nur über die Verwendung von zwei Parametern Enumeration-Klasse und Enumeration-
Wert verwirklicht werden (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(Java)-Contribution-Map:-Enumeration Key Definition"

\end_inset

).
 Die direkte Angabe einer konkreten Enumeration wie dies in der XML-Konfiguratio
n möglich ist, konnte nicht umgesetzt werden.
 Daraus bewirkt, dass sich der Vorteil der IDE-Unterstützung bezüglich der
 Referenzsuche im Javacode im Falle der Konfiguration für eine Contribution-Map
 nicht voll ausnutzen lässt.
\end_layout

\begin_layout Standard
Ein letzter wichtiger Punkt war die Verwendung von Klassen als Schlüssel
 der Contribution-Map.
 Da es bei der Verwendung des Strategy-Services (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Strategy-Service"

\end_inset

) unbedingt notwendig ist Klassen als Schlüssel in einer Contribution-Map
 zu verwenden, konnte auf diese Funktionalität nicht verzichtet werden.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Ergänzung: wie ging das? Probleme?
\end_layout

\begin_layout Plain Layout
Wie kann bei der Erweiterung von Spring um ein neues Modul, dessen Funktionalitä
t mittels Java-Konfiguration gesteuert werden
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
XML- und Java-Konfiguration im Detail
\begin_inset CommandInset label
LatexCommand label
name "sub:XML--und-Java-Konfiguration-im-Detail"

\end_inset


\end_layout

\begin_layout Subsubsection
(XML) Contributions Referenzieren
\begin_inset CommandInset label
LatexCommand label
name "sub:SpringContribution:XML-cotribution-ref"

\end_inset


\end_layout

\begin_layout Standard
Die folgenden beiden XML-Elemente können verwendet werden um Contributions
 der verschiedenen Typen zu referenzieren.
\end_layout

\begin_layout Subparagraph
XML-Element 
\begin_inset Quotes eld
\end_inset

contribution-ref
\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset

mapped-contribution-ref
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
Über das Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 wird ein Contribution-Listen Objekt referenziert.
 Möchte man eine Contribution-Map referenzieren, so muss man das XML-Element
 
\begin_inset Quotes eld
\end_inset


\family sans
mapped-contribution-ref
\family default

\begin_inset Quotes erd
\end_inset

 verwenden.
 Für beide Typen gilt, dass in dem XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
name
\family default

\begin_inset Quotes erd
\end_inset

 der Name des zu verwendenden Contribution-Bean angegeben wird.
 Beide XML-Elemente können nun an allen möglichen Stellen, also z.B.
 innerhalb einer Konstruktor Definition oder auch in einer Setter Definition
 eines Beans als Referenzierung auf das Contribution-Bean verwendet werden
 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:Contribution-Reference"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
SpringContributions: 
\noun default
XML-Schema für die XML-Elemente 
\begin_inset Quotes eld
\end_inset

contribution-ref
\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset

mapped-contribution-ref
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="contribution-ref" type="ContributionType" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="mapped-contribution-ref" type="ContributionType" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:complexType name="ContributionType">
\end_layout

\begin_layout Plain Layout

	<xsd:attribute name="name" type="xsd:string">
\end_layout

\begin_layout Plain Layout

		<xsd:annotation>
\end_layout

\begin_layout Plain Layout

			<xsd:documentation><![CDATA[The name of the contribution, beans were
 added to.]]></xsd:documentation>
\end_layout

\begin_layout Plain Layout

		</xsd:annotation>
\end_layout

\begin_layout Plain Layout

	</xsd:attribute>
\end_layout

\begin_layout Plain Layout

</xsd:complexType>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:Contribution-Reference"

\end_inset


\noun on
SpringContributions: 
\noun default
Verwendung von Contribution Referenzen für Konstruktor- und Setter-Injection
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout

	<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w
3.org/2001/XMLSchema-instance"	xmlns:ctr="http://www.springframework.org/schema/con
tributions" xsi:schemaLocation="http://www.springframework.org/schema/beans	
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springfr
amework.org/schema/contributions http://www.springframework.org/schema/contribution
s/spring-contributions-3.0.xsd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<!-- Referenzierung einer Contribution-Liste und einer Mapped Configuration
 in einem Bean mit Konstruktor-Injektion -->
\end_layout

\begin_layout Plain Layout

		<bean id="constructorClassName" class="MyConstructorInitializedService">
\end_layout

\begin_layout Plain Layout

			<constructor-arg>
\end_layout

\begin_layout Plain Layout

				<ctr:contribution-ref name="contributionName" />
\end_layout

\begin_layout Plain Layout

				<ctr:mapped-contribution-ref name="mappedContributionName" />
\end_layout

\begin_layout Plain Layout

			</constructor-arg>
\end_layout

\begin_layout Plain Layout

			<!-- weitere Metadaten zum jeweiligen Bean -->
\end_layout

\begin_layout Plain Layout

		</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<!-- Referenzierung einer Contribution-Liste und einer Contribution-Map
 in einem Bean mit Setter-Injektion -->
\end_layout

\begin_layout Plain Layout

		<bean id="setterClassName" class="MySetterInitializedService" >
\end_layout

\begin_layout Plain Layout

			<property name="listDependency" >
\end_layout

\begin_layout Plain Layout

				<value>
\end_layout

\begin_layout Plain Layout

					<ctr:contribution-ref name="contributionName" />
\end_layout

\begin_layout Plain Layout

				</value>
\end_layout

\begin_layout Plain Layout

			</property>
\end_layout

\begin_layout Plain Layout

			<property name="mappedDependency" >
\end_layout

\begin_layout Plain Layout

				<value>
\end_layout

\begin_layout Plain Layout

					<ctr:mapped-contribution-ref name="mappedContributionName" />
\end_layout

\begin_layout Plain Layout

				</value>
\end_layout

\begin_layout Plain Layout

			</property>
\end_layout

\begin_layout Plain Layout

		</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	</beans>
\end_layout

\begin_layout Plain Layout

</xml>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
(Java) Contributions Referenzieren
\end_layout

\begin_layout Standard
Für die 
\noun on
SpringContributions
\noun default
 wurden zwei 
\begin_inset Quotes eld
\end_inset

Resolver
\begin_inset Quotes erd
\end_inset

-Services (OrderedContributionResolver und MappedContributionResolver) implement
iert, mit deren Hilfe es leicht möglich ist ein Contribution-Objekt, nur
 durch die Angabe des Contributionnamen, zu erhalten.
 Die Notwendigkeit für diese beiden Services kommt daher, da die Java-Konfiguati
on der 
\noun on
SpringContributions
\noun default
 in ihrer aktuellen Umsetzung (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Java-Konfig-Variante2"

\end_inset

) erst nach der Standard-Beankonfiguration durchgeführt wird.
 Zur Abarbeitungszeit der Standard-Beankonfiguration steht also noch keine
 Contribution-Objekte bereit und die Abhängigkeiten von Beans auf Contribution-O
bjeke können vom IOC-Kontainer also noch nicht aufgelöst werden.
 Würde man also in einer Beankonfiguration direkt auf ein Contribution-Objekt
 zugreifen wollen, so müsste das zu einem Fehler führen.
 Durch die Indirektion über die beiden 
\begin_inset Quotes eld
\end_inset

Resolver
\begin_inset Quotes erd
\end_inset

-Services kann dieses Problem umgangen werden.
 In der XML-Konfiguration werden die beiden Services nicht benötigt, da
 diese gleichzeitig mit der normalen Spring-XML-Konfiguration verarbeitet
 wird und somit Contribution-Objekte wie Beans so zu sagen 
\begin_inset Quotes eld
\end_inset

gleichzeitig
\begin_inset Quotes erd
\end_inset

 erstellt werden.
\end_layout

\begin_layout Standard
Die 
\begin_inset Quotes eld
\end_inset

Resolver
\begin_inset Quotes erd
\end_inset

-Services bieten, wegen der Typisierbarkeit ihrer Rückgabe, auch noch den
 Vorteil, dass im Vergleich zu einem Bean-Objek das man direkt aus dem Spring-Ap
plicationcontext bezieht, keine Typspezifizierung mittels 
\begin_inset Quotes eld
\end_inset

Cast
\begin_inset Quotes erd
\end_inset

-Befehl mehr auf das gelieferte Objekt angewendet werden muss.
\end_layout

\begin_layout Standard
Zusätzlich kommt den 
\begin_inset Quotes eld
\end_inset

Resolver
\begin_inset Quotes erd
\end_inset

-Services noch die Aufgabe der Fehlerbehandlung zu.
 Für den Fall, dass ein Contribution-Objekt tatsächlich nicht vorhanden
 ist, wird durch sie eine Warnung ausgegeben.
 Anstatt des Contribution-Objekts wird dann eine leere Liste oder Map zurückgege
ben.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO
\end_layout

\begin_layout Plain Layout
Ergänzung: Zusätzlich Unterstützung durch automatisches Ergänzen des Contributio
nnamenprefixes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
SpringContributions 
\noun default
Java: Einfache und sortierte Listenübergabe
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Referenzierung einer Contribution-Liste und einer Contribution-Map in
 einem Bean mit Konstruktor
\end_layout

\begin_layout Plain Layout

	@Bean()
\end_layout

\begin_layout Plain Layout

	public static MyConstructorInitializedService constructorClassName(
\end_layout

\begin_layout Plain Layout

		OrderedContributionResolver<MyListElement> list,
\end_layout

\begin_layout Plain Layout

		MappedContributionResolver<MyMapElement> map)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyKonstructorServiceImpl(list.resolve("contributionName"), map.resolv
e("mappedContributionName");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Referenzierung einer Contribution-Liste und einer Contribution-Map in
 einem Bean mit Setter
\end_layout

\begin_layout Plain Layout

	@Bean()
\end_layout

\begin_layout Plain Layout

	public static MySetterInitializedService setterClassName(
\end_layout

\begin_layout Plain Layout

		OrderedContributionResolver<MyListElement> list,
\end_layout

\begin_layout Plain Layout

		MappedContributionResolver<MyMapElement> map)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		MySetterInitializedService service = new MySetterServiceImpl();
\end_layout

\begin_layout Plain Layout

		service.setList(list.resolve("contributionName"));
\end_layout

\begin_layout Plain Layout

		service.setMap(map.resolve("mappedContributionName"));
\end_layout

\begin_layout Plain Layout

		return service;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
(XML) Hinzufügen von Beans zu einer Contribution-Liste
\begin_inset CommandInset label
LatexCommand label
name "sub:Die-Contribution-Liste-in-XML"

\end_inset


\end_layout

\begin_layout Standard
Da uns in XML sowohl Elemente als auch Attribute zur Verfügung stehen, haben
 wir aus Flexibilitätsgründen die Möglichkeit zum Hinzufügen von Beans zu
 einer Contribution-Liste auf drei Arten realisiert.
\end_layout

\begin_layout Standard
Will man also ein Bean zu einer Contribution-Liste hinzuzufügen, so kann
 man sich der drei folgenden Varianten bedienen: 
\end_layout

\begin_layout Subparagraph
XML-Attribut 
\begin_inset Quotes eld
\end_inset

contributeTo
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
Mit diesem Attribut legt man in der Konfiguration fest, dass das eben definierte
 Bean ein Element der Contribution-Liste, mit dem im XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
contributeTo
\family default

\begin_inset Quotes erd
\end_inset

 definierten Namen, werden soll (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contributeTo"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
SpringContributions: 
\noun default
XML-Schema für das XML-Attribut 
\begin_inset Quotes eld
\end_inset

contributeTo
\begin_inset Quotes erd
\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:attribute name="contributeTo" type="xsd:string"></xsd:attribute>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:contributeTo"

\end_inset


\noun on
SpringContributions XML: 
\noun default
Einfache Elementdefinition für normale Listenkonfiguration über XML-Attribut
 
\begin_inset Quotes eld
\end_inset

contributeTo
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout

	<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w
3.org/2001/XMLSchema-instance"	xmlns:ctr="http://www.springframework.org/schema/con
tributions" xsi:schemaLocation="http://www.springframework.org/schema/beans	
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springfr
amework.org/schema/contributions http://www.springframework.org/schema/contribution
s/spring-contributions-3.0.xsd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<bean id="className" class="classToBeContributed"
\end_layout

\begin_layout Plain Layout

			contributeTo="contributionName">
\end_layout

\begin_layout Plain Layout

			<!-- weitere Metadaten -->
\end_layout

\begin_layout Plain Layout

		</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	</beans>
\end_layout

\begin_layout Plain Layout

</xml>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset VSpace bigskip
\end_inset

XML-Element 
\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
Mit dem XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribute
\family default

\begin_inset Quotes erd
\end_inset

 erreicht man dasselbe Ergebnis wie mit dem XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
contributeTo
\family default

\begin_inset Quotes erd
\end_inset

 und kann also ein Bean zu einer Contribution-Liste hinzufügen (siehe Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contribute"

\end_inset

).
 Zusätzlich ist es bei dieser Methode aber möglich das 
\begin_inset Quotes eld
\end_inset


\family sans
constraints
\family default

\begin_inset Quotes eld
\end_inset

 Attribut zu verwenden, um damit die Reihenfolge des Elements in der Contributio
n-Liste zu beeinflussen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
SpringContributions: 
\noun default
XML-Schema für das XML-Element 
\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="contribute">
\end_layout

\begin_layout Plain Layout

	<xsd:complexType>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="to" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation><![CDATA[The name of the contribution this bean is
 added to.]]></xsd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="constraints" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation><![CDATA[The sort constraints for this contribution.]]></x
sd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

	</xsd:complexType>
\end_layout

\begin_layout Plain Layout

</xsd:element>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:contribute"

\end_inset


\noun on
SpringContributions XML: 
\noun default
Einfache Elementdefinition für normale Listenkonfiguration über XML-Element
 
\begin_inset Quotes eld
\end_inset

contribute
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout

	<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w
3.org/2001/XMLSchema-instance"	xmlns:ctr="http://www.springframework.org/schema/con
tributions" xsi:schemaLocation="http://www.springframework.org/schema/beans	
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springfr
amework.org/schema/contributions http://www.springframework.org/schema/contribution
s/spring-contributions-3.0.xsd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<bean id="className" class="classToBeContributed">
\end_layout

\begin_layout Plain Layout

			<contribute to="contributionName" constraints="after:*"/>
\end_layout

\begin_layout Plain Layout

			<!-- weitere Metadaten -->
\end_layout

\begin_layout Plain Layout

		</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	</beans>
\end_layout

\begin_layout Plain Layout

</xml>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subparagraph
XML-Element 
\begin_inset Quotes eld
\end_inset

contribution
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
Über das XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribution
\family default

\begin_inset Quotes erd
\end_inset

 ist es möglich, gleich mehrere Beans zu einer Contribution-Liste hinzu
 zu fügen.
 Die Angabe des Namens des Contributionobjekts, zu dem die Elemente hinzugefügt
 werden sollen, wird auch hier über das Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
to
\family default

\begin_inset Quotes erd
\end_inset

 bewerkstelligt.
 Im Gegensatz zum Tapestry Contribution Mechanismus unterscheiden die 
\noun on
SpringContributions 
\noun default
nicht zwischen der sortierten und der unsortierten Listenübergabeform.
 Jede Konfiguration einer Contribution-Liste kann über das XML-Attribut
 
\begin_inset Quotes eld
\end_inset


\family sans
constraints
\family default

\begin_inset Quotes erd
\end_inset

 optional mit Sortierungsinformationen versehen werden.
 Lässt man die Sortierungsinformationen weg, so bestimmt die Reihenfolge
 des Vorkommens im Konfigurationstext die Ordnung der Elemente in der Liste.
 Die Syntax für die Sortierung wird, wie innerhalb einer Tapestrykonfiguration,
 über die Schlüsselwörter 
\begin_inset Quotes eld
\end_inset


\family sans
before
\family default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
after
\family default

\begin_inset Quotes erd
\end_inset

 in Verbindung mit einem konkreten Elementnamen, der Stern Wildcard 
\begin_inset Quotes eld
\end_inset


\family sans
*
\family default

\begin_inset Quotes erd
\end_inset

 oder einem regulären Ausdruck festgelegt.
\end_layout

\begin_layout Standard
Das XML-Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
ref
\family default

\begin_inset Quotes erd
\end_inset

 wird wie auch sonst in der Spring Konfiguration als Verweis auf ein an
 einer anderen Stelle definiertes Bean verwendet.
 Das bedeutet, dass zu jedem über das XML-Element 
\begin_inset Quotes eld
\end_inset


\family sans
Entry
\family default

\begin_inset Quotes erd
\end_inset

 definierte Element der Contribution-Liste, eine referenzierbare Beandefinition
 innerhalb der Konfigurationsfiles vorliegen muss (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contribution-Element"

\end_inset

).
 Die Beandefinition muss aber im Konfigurationsfile nicht wie im Beispiel
 direkt vor seiner Referenzierung platziert werden.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
SpringContributions: 
\noun default
XML-Schema für das XML-Element 
\begin_inset Quotes eld
\end_inset

contribution
\begin_inset Quotes erd
\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="contribution">
\end_layout

\begin_layout Plain Layout

	<xsd:annotation>
\end_layout

\begin_layout Plain Layout

		<xsd:documentation source="java:org.springframework.beans.factory.config.ListFactor
yBean">
\end_layout

\begin_layout Plain Layout

			Builds a List instance, populated with the specified content.
\end_layout

\begin_layout Plain Layout

		</xsd:documentation>
\end_layout

\begin_layout Plain Layout

		<xsd:appinfo>
\end_layout

\begin_layout Plain Layout

			<tool:annotation>
\end_layout

\begin_layout Plain Layout

				<tool:exports type="java.util.List"/>
\end_layout

\begin_layout Plain Layout

			</tool:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:appinfo>
\end_layout

\begin_layout Plain Layout

	</xsd:annotation>
\end_layout

\begin_layout Plain Layout

	<xsd:complexType>
\end_layout

\begin_layout Plain Layout

		<xsd:group ref="contributionElements"/>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="to" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation><![CDATA[The name of the contribution this bean is
 added to.]]></xsd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

	</xsd:complexType>
\end_layout

\begin_layout Plain Layout

</xsd:element>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:group name="contributionElements">
\end_layout

\begin_layout Plain Layout

	<xsd:sequence>
\end_layout

\begin_layout Plain Layout

		<xsd:element ref="beans:description" minOccurs="0"/>
\end_layout

\begin_layout Plain Layout

		<xsd:element name="entry" minOccurs="1" maxOccurs="unbounded">
\end_layout

\begin_layout Plain Layout

			<xsd:complexType>
\end_layout

\begin_layout Plain Layout

				<xsd:complexContent>
\end_layout

\begin_layout Plain Layout

					<xsd:extension base="beans:propertyType">
\end_layout

\begin_layout Plain Layout

						<xsd:attribute name="constraints" type="xsd:string">
\end_layout

\begin_layout Plain Layout

							<xsd:annotation>
\end_layout

\begin_layout Plain Layout

								<xsd:documentation>
\end_layout

\begin_layout Plain Layout

									<![CDATA[The sort constraints for this contribution.]]>
\end_layout

\begin_layout Plain Layout

								</xsd:documentation>
\end_layout

\begin_layout Plain Layout

							</xsd:annotation>
\end_layout

\begin_layout Plain Layout

						</xsd:attribute>
\end_layout

\begin_layout Plain Layout

					</xsd:extension>
\end_layout

\begin_layout Plain Layout

				</xsd:complexContent>
\end_layout

\begin_layout Plain Layout

			</xsd:complexType>
\end_layout

\begin_layout Plain Layout

		</xsd:element>
\end_layout

\begin_layout Plain Layout

	</xsd:sequence>
\end_layout

\begin_layout Plain Layout

</xsd:group>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:contribution-Element"

\end_inset

SpringContributions XML: 
\noun default
Mehrfache Elementdefinition für normale und sortierte Listenkonfiguration
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout

	<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w
3.org/2001/XMLSchema-instance" xmlns:ctr="http://www.springframework.org/schema/con
tributions" xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springfr
amework.org/schema/contributions http://www.springframework.org/schema/contribution
s/spring-contributions-3.0.xsd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<bean name="myContributedService" class="MyContributedService" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<ctr:contribution to="contributionName">
\end_layout

\begin_layout Plain Layout

			<ctr:entry name="myContributedService" ref="myContributedService" constraints
="after:*" />
\end_layout

\begin_layout Plain Layout

			<!-- weitere Elemente -->
\end_layout

\begin_layout Plain Layout

		</ctr:contribution>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	</beans>
\end_layout

\begin_layout Plain Layout

</xml>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
(Java) Hinzufügen von Beans zu einer Contribution-Liste
\end_layout

\begin_layout Paragraph*
Die Contribution-Liste in Java:
\end_layout

\begin_layout Standard
In der Java-Konfiguration gibt es nicht wie in der XML-Konfiguration drei
 Schreibweisen (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Die-Contribution-Liste-in-XML"

\end_inset

), sondern nur noch eine Möglichkeit ein Bean zu einer Contribution-Liste
 hinzuzufügen.
 Dafür wird die Annotation 
\series bold
@Contribution()
\series default
 mit dem Parameter 
\begin_inset Quotes eld
\end_inset

to
\begin_inset Quotes erd
\end_inset

 verwendet.
 Ob das Element eine festgelegte Position in der Contribution-Liste erhalten
 soll oder nicht, wird über das Hinzufügen oder Weglassen des Attributs
 
\begin_inset Quotes eld
\end_inset

constraints
\begin_inset Quotes erd
\end_inset

 gesteuert.
 In Listing 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
SpringContributions 
\noun default
Java: Einfache und sortierte Listenübergabe
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Ein Bean das der Contribution-Liste "elements" als Element hinzugefügt
 wird;
\end_layout

\begin_layout Plain Layout

	// ohne Information zu Positionierung in der Liste
\end_layout

\begin_layout Plain Layout

	@Contribution(to="elements")
\end_layout

\begin_layout Plain Layout

	@Bean(name="MyServiceDependencyElementImplOne")
\end_layout

\begin_layout Plain Layout

	public MyServiceDependencyElement one()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyServiceDependencyElementImplOne();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Ein weiteres Bean das der Contribution-Liste "elements" als Element
 hinzugefügt wird;
\end_layout

\begin_layout Plain Layout

	// mit Information zur Positionierung in der Liste
\end_layout

\begin_layout Plain Layout

	@Contribution(to="elements", constraints="after:*")
\end_layout

\begin_layout Plain Layout

	@Bean(name="MyServiceDependencyElementImplTwo")
\end_layout

\begin_layout Plain Layout

	public MyServiceDependencyElement two()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyServiceDependencyElementImplTwo();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
(XML) Hinzufügen von Beans zu einer Contribution-Map
\end_layout

\begin_layout Subparagraph
XML-Element 
\begin_inset Quotes eld
\end_inset

mapped-contribution
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
Möchte man mehrere Elemente zu einer Contribution-Map (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Mapped-Configuration"

\end_inset

) hinzufügen, so muss man sich des XML-Elements 
\begin_inset Quotes eld
\end_inset

mapped-contribution
\begin_inset Quotes erd
\end_inset

 bedienen.
 Der innere Komplexe Datentyp dieses Elements entspricht dem einer 
\family sans
\shape italic
java.util.Map
\family default
\shape default
, und benötigt daher für jedes Element auch die Angabe von Schlüssel und
 zugeordneten Werten über die Attribute 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
key
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
value
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 bzw.
 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
key-ref
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Quotes eld
\end_inset


\family sans
\shape italic
value-ref
\family default
\shape default

\begin_inset Quotes erd
\end_inset

 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:mapped-contribution-Element"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
SpringContributions: 
\noun default
XML-Schema für das XML-Element 
\begin_inset Quotes eld
\end_inset

contribution
\begin_inset Quotes erd
\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="mapped-contribution">
\end_layout

\begin_layout Plain Layout

	<xsd:annotation>
\end_layout

\begin_layout Plain Layout

		<xsd:documentation source="java:org.springframework.beans.factory.config.MapFactory
Bean">
\end_layout

\begin_layout Plain Layout

			Builds a Map instance of the specified type, populated with the specified
 content.
\end_layout

\begin_layout Plain Layout

		</xsd:documentation>
\end_layout

\begin_layout Plain Layout

		<xsd:appinfo>
\end_layout

\begin_layout Plain Layout

			<tool:annotation>
\end_layout

\begin_layout Plain Layout

				<tool:exports type="java.util.Map"/>
\end_layout

\begin_layout Plain Layout

			</tool:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:appinfo>
\end_layout

\begin_layout Plain Layout

	</xsd:annotation>
\end_layout

\begin_layout Plain Layout

	<xsd:complexType>
\end_layout

\begin_layout Plain Layout

		<xsd:complexContent>
\end_layout

\begin_layout Plain Layout

			<xsd:extension base="beans:mapType">
\end_layout

\begin_layout Plain Layout

				<xsd:attribute name="to" type="xsd:string">
\end_layout

\begin_layout Plain Layout

					<xsd:annotation>
\end_layout

\begin_layout Plain Layout

						<xsd:documentation><![CDATA[The name of the contribution this bean
 is added to.]]></xsd:documentation>
\end_layout

\begin_layout Plain Layout

					</xsd:annotation>
\end_layout

\begin_layout Plain Layout

				</xsd:attribute>
\end_layout

\begin_layout Plain Layout

			</xsd:extension>
\end_layout

\begin_layout Plain Layout

		</xsd:complexContent>
\end_layout

\begin_layout Plain Layout

	</xsd:complexType>
\end_layout

\begin_layout Plain Layout

</xsd:element>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-XML:mapped-contribution-Element"

\end_inset

SpringContributions XML: 
\noun default
Mehrfache Elementdefinition für eine Contribution-Map
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout

	<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w
3.org/2001/XMLSchema-instance" xmlns:ctr="http://www.springframework.org/schema/con
tributions" xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springfr
amework.org/schema/contributions http://www.springframework.org/schema/contribution
s/spring-contributions-3.0.xsd">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<bean name="myContributedService" class="MyContributedService" />
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		<ctr:mapped-contribution to="contributionName">
\end_layout

\begin_layout Plain Layout

			<ctr:entry key="myServiceKey" value-ref="myContributedService" />
\end_layout

\begin_layout Plain Layout

			<!-- weitere Elemente -->
\end_layout

\begin_layout Plain Layout

		</ctr:mapped-contribution>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	</beans>
\end_layout

\begin_layout Plain Layout

</xml>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
(Java) Hinzufügen von Beans zu einer Contribution-Map
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Beschreibung zum Konfigurationsbeispiel Listing
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\noun on
\begin_inset CommandInset label
LatexCommand label
name "lis:SpringContributions-Java:mapped-contribution-Element"

\end_inset

SpringContributions 
\noun default
Java
\noun on
: 
\noun default
Bean Definition und Übergabe an eine Contribution-Map
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

public class MyModulConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@ContributionMapped(bean="myContributedService",
\end_layout

\begin_layout Plain Layout

		to="contributionName", key="myServiceKey")
\end_layout

\begin_layout Plain Layout

	@Bean(name="myContributedService")
\end_layout

\begin_layout Plain Layout

	public MyContributedService myService()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new MyContributedServiceImpl();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section

\noun on
SpringContributions:
\noun default
 Realisierung
\end_layout

\begin_layout Standard
In den letzten Abschnitten wurden die Anwendungsmöglichkeiten der 
\noun on
SpringContributions
\noun default
 gezeigt, in diesem Abschnitt soll nun in drei Teilen ein Einblick in die
 Implementierung des Moduls gegeben werden.
\end_layout

\begin_layout Standard
Zuerst wird gezeigt wie der über traditionelle XML gesteuerte Spring Konfigurati
onsmechanismus erweitert wird, damit die neuen Schlüsselwörter wie z.B.
 
\begin_inset Quotes eld
\end_inset

contribution
\begin_inset Quotes eld
\end_inset

 erkannt und in Beandefinitionen umgewandelt werden können.
\end_layout

\begin_layout Standard
Die 
\noun on
SpringContributions 
\noun default
unterstützen für auch die in Spring neu vorhandene Möglichkeit der Java-Konfigur
ation.
 Ein weiterer Unterabschnitt zeigt ebenfalls die dafür nötigen Erweiterungen
 im Detail.
\end_layout

\begin_layout Standard
Abschließend wird die, für beide Konfigurationsarten gleiche, Erstellung
 der Beandefinitionen genauer beschrieben und ein Überblick über das Zusammenspi
el von Spring und der neu entstandene Spring Konfiguration gegeben.
\end_layout

\begin_layout Subsection
(XML) Erweiterung der Spring Konfiguration
\end_layout

\begin_layout Standard
Spring bietet von Haus aus eine Möglichkeit zur Erweiterung seines XML-Konfigura
tionsmechanismus.
 Konkret werden von dem Framework die abstrakte Klasse 
\family sans
\shape italic
NamespaceHandlerSupport 
\family default
\shape default
und die Interfaces 
\family sans
\shape italic
NamespaceHandler, BeanDefinitionParser 
\family default
\shape default
und
\family sans
\shape italic
 BeanDefinitionDecorator
\family default
\shape default
 bereit gestellt.
 Die Implementierung des Interfaces 
\family sans
\shape italic
NamespaceHandler
\family default
\shape default
 als Erweiterung der Klasse 
\family sans
\shape italic
NamespaceHandlerSupport
\family default
\shape default
 ermöglicht es, einen eigenen XML-Namensraum für die Spring Konfiguration
 festzulegen.
 Die Umsetzung für die 
\noun on
SpringContributions
\noun default
 geschieht in der Klasse 
\family sans
\shape italic
ContributionsNamespaceHandler
\family default
\shape default
 zusammen mit dem Namensraum http://www.springframework.org/schema/contributions.
\end_layout

\begin_layout Standard
Das dazugehörige XML-Schema 
\family sans
\shape italic
spring-contributions-3.0.xsd
\family default
\shape default
 - ein Auszug ist in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:XML-Schema:-spring-contributions"

\end_inset

 zu sehen - beschreibt alle benötigten Elemente und Attribute und legt damit
 die Syntax der 
\noun on
SpringContributions
\noun default
 Konfiguration fest.
 Spring erhält die Information über den neuen Namensraum über zwei Konfiguration
sfiles im META-INF Verzeichnis des 
\noun on
SpringContributions
\noun default
 Moduls.
 In dem einen 
\begin_inset Quotes eld
\end_inset

spring.schemas
\begin_inset Quotes erd
\end_inset

 wird das neue XML-Schema www.springframework.org/schema/contributions/spring-cont
ributions-3.0.xsd, in dem anderen 
\begin_inset Quotes eld
\end_inset

spring.handlers
\begin_inset Quotes erd
\end_inset

 die dazugehörige Klasse 
\family sans
\shape italic
ContributionsNamespaceHandler
\family default
\shape default
 eingetragen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:XML-Schema:-spring-contributions"

\end_inset

XML-Schema Auszug aus 
\family sans
\shape italic
spring-contributions-3.0.xsd
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:attribute name="contributeTo" type="xsd:string"></xsd:attribute>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<xsd:element name="contribute">
\end_layout

\begin_layout Plain Layout

	<xsd:complexType>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="to" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation>
\end_layout

\begin_layout Plain Layout

					<![CDATA[The name of the contribution this bean is added to.]]>
\end_layout

\begin_layout Plain Layout

				</xsd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

		<xsd:attribute name="constraints" type="xsd:string">
\end_layout

\begin_layout Plain Layout

			<xsd:annotation>
\end_layout

\begin_layout Plain Layout

				<xsd:documentation>
\end_layout

\begin_layout Plain Layout

					<![CDATA[The sort constraints for this contribution.]]>
\end_layout

\begin_layout Plain Layout

				</xsd:documentation>
\end_layout

\begin_layout Plain Layout

			</xsd:annotation>
\end_layout

\begin_layout Plain Layout

		</xsd:attribute>
\end_layout

\begin_layout Plain Layout

	</xsd:complexType> 	
\end_layout

\begin_layout Plain Layout

</xsd:element>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Damit der 
\family sans
\shape italic
NamespaceHandler
\family default
\shape default
 mit neu definierten, für Spring bisher unbekannten, XML-Elementen umgehen
 und aus ihnen Beandefinitionen erstellen kann, nimmt die Klasse 
\family sans
\shape italic
NamespaceHandlerSupport
\family default
\shape default
 Implementierungen des Interfaces 
\family sans
\shape italic
BeanDefinitionParser
\family default
\shape default
 entgegen.
 Für die beiden Contibution Basistypen der Contibution Liste und der Contibution
 Map werden hier zwei separate Parser, der 
\family sans
\shape italic
OrderedContributionBeanDefinitionParser
\family default
\shape default
 und der
\family sans
\shape italic
 MappedContributionBeanDefinitionParser
\family default
\shape default
 verwendet.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:NamespaceExtentionUML"

\end_inset

 gibt einen Überblick zu den erwähnten Klassen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
UML zur Namensraum Erweiterung
\begin_inset CommandInset label
LatexCommand label
name "fig:NamespaceExtentionUML"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/ExtendingSpringKonfiguration.eps
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
(Java) Erweiterung der Spring Konfiguration
\end_layout

\begin_layout Standard
Wie in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-Erweiterung-mittels_Java-Config"

\end_inset

 beschrieben ist die Java-Konfiguration der 
\noun on
SpringContributions
\noun default
 über die Implementierung des Interfaces 
\family sans
\shape italic
BeanDefinitionRegistryPostProcessor
\family default
\shape default
 umgesetzt worden.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Beschreibung zur Implementierung
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
(XML) Von der Konfiguration zum Spring Bean
\end_layout

\begin_layout Standard
Damit es möglich ist, selbst definierte XML Attribute und Elemente innerhalb
 von allen XML-Beandefinitionen zu verwenden, bietet Spring das Interface
 
\family sans
\shape italic
BeanDefinitionDecorator
\family default
\shape default
 an.
 Für die 
\noun on
SpringContributions
\noun default
 werden das Attribut 
\begin_inset Quotes eld
\end_inset


\family sans
contributeTo
\family default

\begin_inset Quotes erd
\end_inset

 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contributeTo"

\end_inset

) und das für die selbe Verwendung bestimmte Element 
\begin_inset Quotes eld
\end_inset


\family sans
contribute
\family default

\begin_inset Quotes erd
\end_inset

 (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:SpringContributions-XML:contribute"

\end_inset

) in der 
\family sans
\shape italic
BeanDefinitionDecorator
\family default
\shape default
 Implementierung 
\family sans
\shape italic
ContributionBeanDefinitionDecorator 
\family default
\shape default
behandelt.
 Dieser 
\family sans
\shape italic
BeanDefinitionDecorator 
\family default
\shape default
wird im 
\family sans
\shape italic
ContributionsNamespaceHandler
\family default
\shape default
 registriert.
 Der Spring Parser identifiziert dann über den Namensraum im XML-Konfigurationsf
ile den 
\family sans
\shape italic
NamespaceHandler
\family default
\shape default
 und erhält von diesem den registrierten
\family sans
\shape italic
 BeanDefinitionDecorator
\family default
\shape default
.
 Einen schematischen Überblick zur Namensraumerweiterung gibt Abbildung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:NamespaceExtentionFlow"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spring Namensraum Erweiterung
\begin_inset CommandInset label
LatexCommand label
name "fig:NamespaceExtentionFlow"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/CreatingBeanDefinitionsFromConfigurations.eps
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Der 
\family sans
\shape italic
ContributionBeanDefinitionDecorator
\family default
\shape default
 ist dann dafür zuständig, die eigentliche Beandefinition zu erstellen und
 in einem 
\family sans
\shape italic
OrderedContribution-Bean
\family default
\shape default
 abzulegen.
 Innerhalb dieses Objekts werden auch die Parametern des 
\begin_inset Quotes eld
\end_inset


\family sans
constraints
\family default

\begin_inset Quotes eld
\end_inset

 Attributs, zur Festlegung der Position des Beans innerhalb der Contribution-Lis
te, abgelegt.
\end_layout

\begin_layout Standard
Anschließend wird das 
\family sans
\shape italic
OrderedContribution-Bean
\family default
\shape default
 als Element zur Contribution-Liste hinzugefügt und somit innerhalb der
 
\family sans
\shape italic
OrderedConfigurationFactoryBean
\family default
\shape default
 abgelegt.
 Wenn das entsprechende Bean das erste Element ist, dass zur Contribution-Liste
 hinzugefügt wird, dann muss vor dem Hinzufügen zuerst noch das Bean der
 Contribution-Liste selbst angelegt und in der 
\begin_inset Quotes eld
\end_inset

Registry
\begin_inset Quotes erd
\end_inset

 dem IOC-Container registriert werden (siehe Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Registrierung-eines-Beans"

\end_inset

).
 Auf die gleiche Weise arbeiten auch die beiden 
\family sans
\shape italic
BeanDefinitionParser
\family default
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Registrierung-eines-Beans"

\end_inset

Registrierung eines Beans zu einer Contribution-Liste: Auszug aus dem 
\family sans
\shape italic
ContributionBeanDefinitionDecorator
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private void addToContributionService(String contributionName, BeanDefinition
 contribution,                                           ParserContext parserCon
text)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	final String beanName = ORDERED_CONTRIBUTION_PREFIX + contributionName;
\end_layout

\begin_layout Plain Layout

	final BeanDefinitionRegistry registry = parserContext.getRegistry();
\end_layout

\begin_layout Plain Layout

	if (registry.containsBeanDefinition(beanName))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		BeanDefinition beanDefinition = parserContext.getRegistry().getBeanDefinition(be
anName);
\end_layout

\begin_layout Plain Layout

		List list =
\end_layout

\begin_layout Plain Layout

			(List) beanDefinition.getPropertyValues().getPropertyValue("contributionList").g
etValue();
\end_layout

\begin_layout Plain Layout

		list.add(contribution);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		BeanDefinitionBuilder builder = 
\end_layout

\begin_layout Plain Layout

			BeanDefinitionBuilder.rootBeanDefinition(OrderedConfigurationFactoryBean.class)
;
\end_layout

\begin_layout Plain Layout

		List contributionList = new ManagedList();
\end_layout

\begin_layout Plain Layout

		contributionList.add(contribution);
\end_layout

\begin_layout Plain Layout

		builder.addPropertyValue("contributionList", contributionList);       
      		parserContext.getRegistry().registerBeanDefinition(beanName, builder.getBea
nDefinition());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Um die Sortierung der Beans in der Liste zu ermöglichen, implementiert die
 Klasse 
\family sans
\shape italic
OrderedContribution
\family default
\shape default
 das Interface 
\family sans
\shape italic
Orderable
\family default
\shape default
.
 Dadurch kann die 
\family sans
\shape italic
OrderedConfigurationFactoryBean
\family default
\shape default
, mit Hilfe der Klasse 
\family sans
\shape italic
Orderer
\family default
\shape default
, die einzelnen Positionierungsangaben der Listen Elemente berücksichtigen
 (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Contributionliste"

\end_inset

).
\end_layout

\begin_layout Standard
Wenn nun ein Bean, das eine Contribution-Liste benötigt, von der Spring
 IOC-Registry instanziiert wird, so bedient sich diese der 
\family sans
\shape italic
OrderedConfigurationFactoryBean
\family default
\shape default
 um die Contribution-Liste zu erhalten.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Contribution-Liste 
\begin_inset CommandInset label
LatexCommand label
name "fig:Contributionliste"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/OrderedContribution.eps
	scale 40
	rotateOrigin center

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
(Java) Von der Konfiguration zum Spring Bean
\end_layout

\begin_layout Standard
Will man eine Bean zu einer Contribution-Map hinzufügen und dabei als Schlüssele
lement eine Enumeration verwenden, so kann dies über die Verwendung der
 optionalen Attribute 
\family sans
\shape italic
keyEnumClass
\family default
\shape default
 und 
\family sans
\shape italic
keyEnumValue
\family default
\shape default
 erreicht werden.
 Die Verwendung von zwei Attributen ist hier deshalb notwendig, da es nicht
 möglich ist direkt eine Enumeration in einer Annotation zu referenzieren.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO noch mehr Beschreibung
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:(Java)-Contribution-Map:-Enumeration Key Definition"

\end_inset

(Java) Contribution-Map: Enumeration Key Definition
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Hinzufügen eines Key/Value-Paares zu einer Contribution-Map mit einer
 Enumeration als Schlüssel
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ContributionMapped(to="myMappedContribution", keyEnumClass=KeyEnum.class,
 keyEnumValue="keyOne")
\end_layout

\begin_layout Plain Layout

@Bean(name="enumOneKeyObject")
\end_layout

\begin_layout Plain Layout

public Object enumOneKeyObject()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return new Object();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Die verwendete Enumeration-Klasse mit ihren Werten
\end_layout

\begin_layout Plain Layout

public enum KeyEnum
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	keyOne,
\end_layout

\begin_layout Plain Layout

	keyTwo;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Contribution-Bean Identifikation
\begin_inset CommandInset label
LatexCommand label
name "sub:Contribution-Bean-Identifikation"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Woraus wird die Identifikation gebildet (Name + Prefix).
 Wie kann ein Anwender die Eindeutigkeit der Identifikation sicherstellen?
 -> Durch die Verwendung des Modulnamen als Prefix in jedem Contributionnamen,
 kann die Eindeutigkeit der Contibution Identifikation zumindest über Modulgrenz
en hinweg sichergestellt werden.
 Innerhalb einer Modulkonfiguration kann man mit ähnlichen Vorgaben ebenfalls
 Namenskollisionen vermeiden.
\end_layout

\end_inset


\end_layout

\begin_layout Section

\noun on
SpringContributions
\noun default
 Anwendungsbeispiele
\end_layout

\begin_layout Standard
In den folgenden Anwendungsbeispielen folgt den Listings mit XML-Konfiguration
 sogleich ein Listing mit äquivalenter Java-Konfiguration.
\end_layout

\begin_layout Subsection
(XML / Java) ValueHolder-Service und sortierte Contribution-Liste
\end_layout

\begin_layout Standard
Ein Anwendungsbeispiel des 
\noun on
SpringContributions
\noun default
 Mechanismus wird in den folgenden drei Listings und 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:OrderedContributionTest-Test"

\end_inset

 gegeben.
\end_layout

\begin_layout Standard
Dabei handelt es sich in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(XML) OrderedContributionTest-Konfiguration"

\end_inset

 um eine XML-Konfiguration einer Contribution-Liste und ihres Konsumenten.
 In Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:(Java) OrderedContributionTest-Konfiguration"

\end_inset

wird als Gegenüberstellung zur XML-Konfiguration die analoge Java-Konfiguration
 angegeben.
\end_layout

\begin_layout Standard
In dem Beispiel wird ein 
\family sans
\shape italic
ValueHolder
\family default
\shape default
 Service als Spring Bean sowie eine
\family sans
\shape italic
 
\family default
\shape default
sortierte Contribution-Liste mit dem Namen 
\family sans
\shape italic
"value-list"
\family default
\shape default
 definiert werden.
 Der 
\family sans
\shape italic
ValueHolder
\family default
\shape default
 Service erwartet die Contribution-Liste als Konstruktor-Argument.
 Innerhalb der Contribution-Liste sind drei Strings ("
\family sans
\shape italic
String 1
\family default
\shape default
", "
\family sans
\shape italic
String 2
\family default
\shape default
") als Elemente definiert.
 Jedem Element wird durch seine jeweilige 
\family sans
\shape italic
constraints
\family default
\shape default
 Einstellung eine bestimmte Position innerhalb der Liste zugewiesen.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:(XML) OrderedContributionTest-Konfiguration"

\end_inset

 (XML) Spring Bean und Sortierte Contribution-Liste Test-Konfiguration
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Bean Konfig des Konsumenten -->
\end_layout

\begin_layout Plain Layout

<bean class="org.springframework.contributions.ValueHolder">
\end_layout

\begin_layout Plain Layout

	<constructor-arg>
\end_layout

\begin_layout Plain Layout

		<ctr:contribution-ref name="value-list" />
\end_layout

\begin_layout Plain Layout

	</constructor-arg>
\end_layout

\begin_layout Plain Layout

</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<!-- (XML) Konfiguration der Contribution-Listen Elemente -->
\end_layout

\begin_layout Plain Layout

<ctr:contribution to="value-list">
\end_layout

\begin_layout Plain Layout

	<ctr:entry name="string2" value="String 2"
\end_layout

\begin_layout Plain Layout

		constraints="after:string1" />
\end_layout

\begin_layout Plain Layout

	<ctr:entry name="string1" value="String 1"
\end_layout

\begin_layout Plain Layout

		constraints="before:*" />
\end_layout

\begin_layout Plain Layout

</ctr:contribution>
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:(Java) OrderedContributionTest-Konfiguration"

\end_inset

 (Java) Spring Bean und Sortierte Contribution-Liste Test-Konfiguration
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// (Java) Bean Konfig des Konsumenten
\end_layout

\begin_layout Plain Layout

@Bean(name="valueHolder") public ValueHolder valueHolder(OrderedContributionReso
lver<String> values)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return new ValueHolder(values.resolve("value-list"));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// (Java) Konfiguration der Contribution-Listen Elemente
\end_layout

\begin_layout Plain Layout

@Contribution(to="value-list", constraints="after:string1")
\end_layout

\begin_layout Plain Layout

@Bean(name="string2") public String string2()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return "String 2";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Contribution(to="value-list", constraints="before:*")
\end_layout

\begin_layout Plain Layout

@Bean(name="string1") public String string1()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return "String 1";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Im zweiten Listing findet sich zum Einen die Implementierung des 
\family sans
\shape italic
ValueHolder
\family default
\shape default
 Service.
 Zum Anderen wird die zuvor definierte Spring Konfiguration in einem JUnit
 Test (
\family sans
\shape italic
OrderedContributionIntegrationTest
\family default
\shape default
) verwendet.
\end_layout

\begin_layout Standard
Innerhalb des Unit Tests wird die Konfiguration über die Spring Annotation
 
\family sans
\shape italic
@ContextConfiguration
\family default
\shape default
 als Spring Kontext in den Test mit eingebunden.
 Der Unit Test überprüft dann die richtige Reihenfolge der einzelnen Strings
 innerhalb der Contribution-Liste.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:OrderedContributionTest-Test"

\end_inset

 
\family sans
\shape italic
ValueHolder
\family default
\shape default
 Service Klasse und Ordered Contribution Anwendung als JUnit Test
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Java-Klasse ValueHolder:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class ValueHolder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private final List<String> values;
\end_layout

\begin_layout Plain Layout

	public ValueHolder(final List<String> values)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		this.values = values;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public List<String> getValues()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return values;
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// JUnit Test OrderedContributionIntegrationTest:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// hier wird das XML-Konfigurationsfile angegeben
\end_layout

\begin_layout Plain Layout

// oder die äquivalente Java-Konfiguration als Klasse
\end_layout

\begin_layout Plain Layout

// z.B.
 OrderedContributionIntegrationTestConfiguration.class
\end_layout

\begin_layout Plain Layout

@ContextConfiguration("classpath:spring-contributions-ordered.xml") 
\end_layout

\begin_layout Plain Layout

@RunWith(SpringJUnit4ClassRunner.class)
\end_layout

\begin_layout Plain Layout

public class OrderedContributionIntegrationTest
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@Inject
\end_layout

\begin_layout Plain Layout

	@Named("valueHolder")
\end_layout

\begin_layout Plain Layout

	private ValueHolder stringHolder;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Test
\end_layout

\begin_layout Plain Layout

	public void testStringContribution()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		assertThat(stringHolder.getValues(),
\end_layout

\begin_layout Plain Layout

			is(Arrays.asList("String 1", "String 2")));
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Contributions mehrfach konsumieren
\begin_inset CommandInset label
LatexCommand label
name "sub:Contributions-mehrfach-konsumier"

\end_inset


\end_layout

\begin_layout Standard
Ein großer Vorteil gegenüber des in Tapestry angebotenen Contribution Systems
 ergibt sich in den 
\noun on
SpringContributions 
\noun default
aus dem Umstand, dass jede Contribution als eigenes Bean behandelt wird.
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Beschreibung von Anwendungsfällen, Vorteilen mit Codebeispielen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Natürlich birgt die Möglichkeit der uneingeschränkten Verwendung von Contributio
ns durch mehrere Konsumenten auch Risiken, auf die in der Verwendung acht
 gegeben werden muss.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Beschreibung von Problemen und Risiken mit Codebeispielen
\end_layout

\end_inset


\end_layout

\begin_layout Section

\noun on
SpringContributions 
\noun default
Dienste
\end_layout

\begin_layout Standard
Im letzten Abschnitt wurde die Adaption des von Tapestry bekannten Contribution
 Mechanismus für das Spring Framework behandelt.
 Damit haben wir jetzt die Grundlage geschaffen, um uns dem nächsten Schritt
 zu widmen.
 Im folgenden Abschnitt sollen nun die Funktionsweise der Tapestry Service
 Builder (StrategyBuilder, Chain Of Command, Pipeline und Shadow Services)
 beschrieben und deren Adaption für Spring gezeigt werden.
 Wie schon der Contribution Mechanismusm, werden alle Service Builder wiederum
 Modulübergreifend zur Verfügung gestellt\SpecialChar \@.

\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Strategy
\begin_inset Quotes erd
\end_inset

 Service
\begin_inset CommandInset label
LatexCommand label
name "sub:Strategy-Service"

\end_inset


\end_layout

\begin_layout Standard
Tapestry bietet mit dem 
\begin_inset Quotes eld
\end_inset

StrategyBuilder
\begin_inset Quotes erd
\end_inset

 Service eine Dienst an, der das aus 
\begin_inset CommandInset citation
LatexCommand cite
key "Gamma:1995"

\end_inset

 bekannte Konzept des 
\begin_inset Quotes eld
\end_inset

Strategy
\begin_inset Quotes erd
\end_inset

 Pattern auf eine sehr intelligente Weise erweitert.
 In Tapestry wird die Auswahl der Strategie über Objekttypen gesteuert.
 Das bedeutet, dass immer der Typ des ersten Parameters einer 
\begin_inset Quotes eld
\end_inset

Strategy
\begin_inset Quotes erd
\end_inset

-Methode darüber entscheidet, welche Strategie zum Zuge kommt.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Erweiterte Beschreibung des Patterns und seiner Anwendung
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Text zum Tapestry Codebeispiel
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tapestry-strategy-builder-service"

\end_inset

 Tapestry StrategyBuilder Service
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface StrategyBuilder
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    <S> S build(StrategyRegistry<S> registry);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//TODO Vervollständigen des Beispiels
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Text zum Spring Contributions Codebeispiel
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "XML:spring-contributions-strategy-building"

\end_inset

 (XML) Konfiguration einer Strategie in SpringContributions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

<bean id="stringFormatStrategy" class="org.springframework.contributions.ioc.service
s.strategy.StrategyFactoryBean">
\end_layout

\begin_layout Plain Layout

	<constructor-arg value="org.springframework.contributions.strategy.StringFormatStra
tegy" />
\end_layout

\begin_layout Plain Layout

	<constructor-arg> 
\end_layout

\begin_layout Plain Layout

		<ctr:mapped-contribution-ref name="stringFormatStrategies" />
\end_layout

\begin_layout Plain Layout

	</constructor-arg>
\end_layout

\begin_layout Plain Layout

</bean>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<bean id="upperCase" class="org.springframework.contributions.strategy.strategies.Upp
erCaseStringFormatStrategy" /> 
\end_layout

\begin_layout Plain Layout

<bean id="blankSeparated" class="org.springframework.contributions.strategy.strategi
es.BlankSeparatedStringFormatStrategy" />
\end_layout

\begin_layout Plain Layout

<bean id="reversed" class="org.springframework.contributions.strategy.strategies.Reve
rsedStringFormatStrategy" /> 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<ctr:mapped-contribution to="stringFormatStrategies">
\end_layout

\begin_layout Plain Layout

	<entry>
\end_layout

\begin_layout Plain Layout

		<key>
\end_layout

\begin_layout Plain Layout

			<value>org.springframework.contributions.strategy.entities.UpperCase</value>
\end_layout

\begin_layout Plain Layout

		</key>
\end_layout

\begin_layout Plain Layout

		<ref bean="upperCase" />
\end_layout

\begin_layout Plain Layout

	</entry>
\end_layout

\begin_layout Plain Layout

	<entry>
\end_layout

\begin_layout Plain Layout

		<key>
\end_layout

\begin_layout Plain Layout

			<value>org.springframework.contributions.strategy.entities.BlankSeparated</value>
\end_layout

\begin_layout Plain Layout

		</key>
\end_layout

\begin_layout Plain Layout

		<ref bean="blankSeparated" />
\end_layout

\begin_layout Plain Layout

	</entry>
\end_layout

\begin_layout Plain Layout

	<entry>
\end_layout

\begin_layout Plain Layout

		<key>
\end_layout

\begin_layout Plain Layout

			<value>org.springframework.contributions.strategy.entities.Reversed</value>
\end_layout

\begin_layout Plain Layout

		</key>
\end_layout

\begin_layout Plain Layout

		<ref bean="reversed" />
\end_layout

\begin_layout Plain Layout

	</entry>
\end_layout

\begin_layout Plain Layout

</ctr:mapped-contribution>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},breaklines=true,language=Java,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Java:spring-contributions-strategy-building"

\end_inset

 (Java) Konfiguration einer Strategie in SpringContributions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Configuration
\end_layout

\begin_layout Plain Layout

@EnableAspectJAutoProxy
\end_layout

\begin_layout Plain Layout

public abstract class StrategyFactoryBeanIntegrationTestConfiguration
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	@Bean(name="stringFormatStrategy")
\end_layout

\begin_layout Plain Layout

	public StrategyFactoryBean strategyCaller(MappedContributionResolver<Map<Class,
 Strategy>> strategies)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new StrategyFactoryBean(StringFormatStrategy.class, strategies.resolve("s
tringFormatStrategies"));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@ContributionMapped(to="stringFormatStrategies", keyClass=UpperCase.class)
\end_layout

\begin_layout Plain Layout

	@Bean(name="upperCase")
\end_layout

\begin_layout Plain Layout

	public StringFormatStrategy<UpperCase> upperCase()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new UpperCaseStringFormatStrategy();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@ContributionMapped(to="stringFormatStrategies", keyClass=BlankSeparated.class)
\end_layout

\begin_layout Plain Layout

	@Bean(name="blankSeparated")
\end_layout

\begin_layout Plain Layout

	public StringFormatStrategy<BlankSeparated> blankSeparated()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new BlankSeparatedStringFormatStrategy();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@ContributionMapped(to="stringFormatStrategies", keyClass=Reversed.class,
 bean="reversed")
\end_layout

\begin_layout Plain Layout

	@Bean(name="reversed")
\end_layout

\begin_layout Plain Layout

	public StringFormatStrategy<Reversed> reversed()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return new ReversedStringFormatStrategy();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO Anwendungsbeispiel zu der zuvor angelegten Konfiguration als Unit-Test
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Vergleich von XML-Konfiguration und Java-Konfiguration
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "bibtex/literatur"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
